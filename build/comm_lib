#!/usr/bin/ksh
#set -x
#############################################################################################
#名 称: comm_lib                                                                            #
#功 能: 提供公共函数库                                                                      #
#声 明: [公开]对外公开,供产品二次开发脚本调用                                               #
#       [私有、废弃]为框架私有,不保证其完全通用及有效                                       #
#--------------------------------------函数列表---------------------------------------------#
##01.read_value                     读取配置文件中某个健的值**************************[公开]#
##02.log_echo                       日志输出函数**************************************[公开]#
##03.report_cluster_state           记录双机状态**************************************[公开]#
##04.uncompress_pkg                 解压Z包*******************************************[私有]#
##05.untar_pkg                      解压tar包*****************************************[私有]#
##06.make_dir                       创建目录******************************************[私有]#
##07.message_echo                   日志输出函数**************************************[私有]#
##08.message_end                    日志输出函数**************************************[私有]#
##09.message_error                  日志输出函数**************************************[私有]#
##10.message_log                    日志输出函数**************************************[私有]#
##11.message_rate                   日志输出函数**************************************[私有]#
##12.message_file                   日志输出函数**************************************[私有]#
##13.is_integer                     检查是否是整数************************************[私有]#
##14.validate_ip                    校验ip是否连通************************************[私有]#
##15.initiate                       初始化,包括创建目录,获取包************************[私有]#
##16.set_constants                  设置环境常量**************************************[私有]#
##17.transfer_file_via_ftp          使用ftp协议传输文件*******************************[私有]#
##18.add_file_record                增加一条记录到文件 ideploy_file_history中*********[公开]#
##19.config_value_decrypt           将加密后的配置项解密******************************[公开]#
##20.standard_decrypt               将使用标准算法加密后的密文解密********************[公开]#
##21.get_cfgtable_record_num        获取表量的记录数**********************************[公开]#
##22.get_cfgtable_field_name_list   获取表量的字段名称列表****************************[公开]#
##23.get_cfgtable_field_value       获取表量的字段值**********************************[公开]#
##24.get_pkg_name                   获取压缩包名称和目录，支持正则表达式**************[公开]#
##25.read_xml_node_value            获取XML节点的值***********************************[公开]#
##26.getOriginalFile                收集升级前配置文件********************************[公开]#
##27.getModifiedFile                收集升级后配置文件********************************[公开]#
##28.getRollbackFile                收集回滚后配置文件********************************[公开]#
##29.message_migrate_service        日志输出函数**************************************[私有]#
#############################################################################################
#history:2007-05-23:Tag first label
#add:get_via_ftp新增一个参数tarns_port
#delete:删除log_echo对end以及error的支持
#2007-05-30:label:增加对ftp错误码555的捕捉
#2007-05-30:modify:修改文件传输大小的对比方法，以及信息提示
#2007-06-06:add:增加dispatch包分发的功能
#2007-06-11:add:将cfg_file中的函数合入
#2007-06-13:将500作为错误码捕捉,get_via_ftp中对比文件大小前先进行非空判断
#2007-06-13:add:将用户家目录下的ideploy_wrap.sh等文件删除
#2007-06-18:convert,convert_files,search_dir三个函数,用于文件格式转换,initiate中添加调用
#2007-06-20:modify:修改了conf目录下文件格式的处理，优化了ideploy_del的处理
#2007-08-29:modify:修改了conf目录下文件的删除与文件格式的处理，不在需要另外传输properties文件
#2007-08-30:modify:修改ftp中用户名与密码的打印方式，避免将反斜杠转义
#2007-10-19:modify:修改get_via_ftp,使支持文件名称中含有空格的情况,以及支持suse10
#2007-10-30:add & modify:新增get_apps_pkg与get_script_pkg,用于分解包分发步骤;
#                        修改set_constants中定义的全局常量名称,避免与产品定义的变量冲突
#2007-12-20:add & modify:新增message_file用于显示只写入文件不在界面显示的日志；修改set_constants在写入全局变量之前删除
#                       ideploy.inc中已经存在的
#2007-12-28:modify:修改ideploy_del函数，将ideploy.inc的copy操作移到分发二次开发包中，只进行一次；
#                  将cfgdispatch包的分发移到二次开发包分发完成后进行；
#                  取消分发业务包前对是否含有键的检查(1.框架已经做了相关的检查2.hp平台上包列表总长超过3000时该检查会抛出awk错误)
#2008-06-13:modify:扩展进度接口，将conf目录下的propertise文件统一命名为config.properties
#2008-07-04:modify:问题单AR5D06432,通过使用全局变量IDEPLOY_NULL替换/dev/null,避免系统中/dev/null没有写入权限的问题
#2008-12-09:modify:修改cfg_update_sec_key_value中行注释的获得算法，对部分方法添加set -o noglob
#2008-12-17:modify:修改get_via_ftp中使用ftp指令获取文件的指令，支持redhat
#2009-4-10:add 增加修改IP、修改IP获取策略、绑定网卡、重启网卡的相关函数
#2009-4-24:modify:修改生产调测过程中发现的绑定网卡、改IP的相关问题
#2009-4-27:modify:修改使用ftp获取文件的函数get_via_ftp为支持获取(get)和发送(put)文件的函数transfer_file_via_ftp
#2009-5-7:modify:修改modify_eth_card_ip、modify_eth_card_bond函数的返回值；分发二次开发和业务包时，从ftpserver文件中读取的ftp密码增加解密处理
#2009-5-19:modify:修改is_integer方法只判断是否由数字组成，而不判断是否超过了最大整数2147483647
#2009-5-23:modify:修改modify_hostip_obtain_policy，在修改IP的函数中调用该方法进行修改IP获取策略，不用单独调用
#2009-6-1:add:添加sftp发包的方法，同时调整原来的ftp发包，方法调用过程如下
#get_all_pkg
#    get_script
#        transfer_file_via_ftp/transfer_file_via_sftp
#    get_apps
#        transfer_file_via_ftp/transfer_file_via_sftp
#get_script_pkg
#    get_script
#        transfer_file_via_ftp/transfer_file_via_sftp
#get_apps_pkg
#    get_apps
#        transfer_file_via_ftp/transfer_file_via_sftp
#2009-6-8:modify：修改transfer_file_via_ftp方法中ftp获取文件的指令，如果安装了kerberos协议的机器，
#                 ftp增加-u选项，suse机器增加epsv4指令，其他的机器按照原来的使用-inv选项，不需要增加epsv4指令
#2010-11-26:add:增加全局工具发包的三个函数：get_golbaltool_apps_pkg、get_golbaltool_script_pkg、get_golbaltool_all_pkg
#2014-06-10:add:增加收集配置文件的三个函数：getOriginalFile、getModifiedFile、getRollbackFile
#2014-06-10:add:增加打印割接业务日志函数：message_migrate_service
#############################################################################################

#########################################################################################
#read_value
#读取properties文件,返回脚本需要的值
#参数1,properties文件(包含绝对路径),可以缺省
#参数2,key键值,不可缺省
#参数3,allow_empty,缺省为false,即不允许为key值为空
#########################################################################################
function read_value
{
    #set -x
    typeset func_name="read_value"
    typeset file_name=""
    typeset key=""
    typeset value=""
    typeset allow_empty="iDeploy_False"
    
    #若count为0,说明指定的键名不存在
    typeset -i count=0
    RETURN[0]=""
    if [ $# -eq 1 ];then
        file_name="${CONFIG_DIR}/${CONFIG}"
        key="$1"
    elif [ $# -eq 2 ];then
        if [ "X$2" = "XiDeploy_False" -o "X$2" = "XiDeploy_True" ];then
            file_name="${CONFIG_DIR}/${CONFIG}"
            key="$1"
            allow_empty="$2"
        else
            file_name="$1"
            key="$2"
        fi
    elif [ $# -eq 3 ];then
        file_name="${CONFIG_DIR}/${CONFIG}"
        key="$1"
        allow_empty="$2"
    else
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}!"
        return 1
    fi

    #检查文件是否存在
    if [ ! -f ${file_name} ];then
        log_echo "error" "${func_name}" "\"${file_name}\" ${IS_NOT_A_FILE}!"
        return 1
    fi
    if [ ! -r ${file_name} ];then
        log_echo "error" "${func_name}" "You have no permission for read \"${file_name}\"!"
        return 1
    fi
    #
    count=`cat ${file_name}|$AWK -F= -v k="${key}" '{ if ( $1 == k ) print $2 }'|wc -l`
    if [ ${count} -ge 2 ];then
        log_echo "error" "${func_name}" "The format of \"${CONFIG}\" is ${WRONG}!"
        return 1
    fi
    if [ ${count} -eq 1 ];then
        value=`cat ${file_name}|$AWK -F= -v k="${key}" '{ if ( $1 == k ) print substr($0,(length($1)+2),length($0)) }'`
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Read the value of \"${key}\" from file \"${CONFIG}\" Failed!"
            return 1
        else
            if [ "X${value}" = "X" ];then
                log_echo "log" "${func_name}" "The value of the specified key \"${key}\" is empty!"
                #Begin 2007-05-24 Modify the return value
                RETURN[0]=${value}
                #End 2007-05-24 Modify the return value
                if [ "X${allow_empty}" = "XiDeploy_False" ];then 
                    return 1
                else
                    return 0
                fi
            else
                #Begin 2007-05-24 Modify the return value
                RETURN[0]=${value}
                #End 2007-05-24 Modify the return value
                return 0
            fi
        fi
    else
        log_echo "error" "${func_name}" "Can't find the value of the specified key \"${key}\"!"
        return 1
    fi
    
#    #key是私有的配置项
#    user=`id |$AWK -F( '{print $2}'|$AWK -F) '{print $1}'`
#    #检查是否存在该用户的配置项
#    count=`cat ${file_name}|$AWK -F. -v u=${user} '{ if ( $1 == u ) print $0 }'|wc -l`
#    if [ ${count} -eq 0 ];then
#        log_echo "log" "${func_name}" "Can't not find the configuration for user \"${user}\" in \"${CONFIG}\"!"
#        return 1
#    fi
#    #将计数器置0
#    count=0
#    user_key="${user}.${key}"
#    #检查是否存在user_key
#    count=`cat ${file_name}|$AWK -F= -v k=${user_key} '{ if ( $1 == k ) print $2 }'|wc -l`
#    if [ ${count} -ne 1 ];then
#        log_echo "log" "${func_name}" "The format of \"${CONFIG}\" is ${WRONG}!"
#        return 1
#    fi
#    value=`cat ${file_name}|$AWK -F= -v k=${user_key} '{ if ( $1 == k ) print $2 }'`
#    if [ $? -ne 0 ];then
#        return 1
#    else
#        if [ "X${value}" != "X" ];then
#            RETURN[0]=`echo ${value}`
#            return 0
#        else
#            log_echo "log" "${func_name}" "Read the value of \"${user_key}\" from file \"${CONFIG}\" failed!"
#            RETURN[0]=""
#            return 1
#        fi
#    fi
}


#########################################################################################
#mes_filter
#过滤关键字，在关键字的前面添加一个全角的空格
#########################################################################################
function mes_filter
{
    #set -x
    typeset func_name="mes_filter"
    typeset mes=$@
    typeset mes2=""
    typeset key_words=${FILTER_WORDS}
    for w in ${key_words}
    do
#        if [ `echo ${mes} |$SED -n '/[ ]\{1,\}'${w}'[ ]\{1,\}/'p|wc -l` -ge 1 ];then
#            mes=`echo ${mes} | $SED 's/[ ]\{1,\}'${w}'[ ]\{1,\}/　'${w}' /g'`
#            break
#        fi
#        mes2=`echo ${mes} | $SED 's/[ ]\{1,\}'${w}'[ ]\{1,\}/　'${w}' /g'`
        mes2=`echo ${mes} | $SED 's/[ ]\{1,\}'${w}'/　'${w}'/g'`
        if [ "X${mes}" != "X${mes2}" ];then
            break
        fi
    done
    echo ${mes2}
}

#日志打印，级别日志中的关键字不着色
function log_echo_no_color_up
{
    typeset func_name="log_echo_no_color_up"
    IDEPLOY_LOG_PREFIX="{:}{::}"
    IDEPLOY_LOG_SUFFIX="{::}{:}"
    IDEPLOY_LOG_LINE_COLOR=""
    log_core $@
    
}

function log_echo
{
    typeset func_name="log_echo"
    IDEPLOY_LOG_PREFIX=""
    IDEPLOY_LOG_SUFFIX=""
    IDEPLOY_LOG_LINE_COLOR=""
    log_core $@

}

#打印带有日期时间的行着色日志
#调用格式 log_echo_with_line_color "brown" "debug" "funcname" "asdasdf error warn failed"
#其中关键字不会被着色
function log_echo_with_line_color
{
    typeset func_name="log_echo_with_line_color"
    IDEPLOY_LOG_PREFIX="{:}{::}"
    IDEPLOY_LOG_SUFFIX="{::}{:}"
    IDEPLOY_LOG_LINE_COLOR=$1
    if [ $# -ne 0 ];then
        shift
    fi
    log_core $@
    
}

#########################################################################################
#   Name:           report_cluster_state
#   Description:    记录双机状态，在iDeploy任务执行页面上根据双机状态信息显示图标和信息
#	input
#  		1. state            双机状态，取值为offline/online/fault/unknown/stopping/starting/stop_failed/start_failed之一#  		
#       2. msg              双机状态变化说明信息
#   Return:  
#		0                   记录成功
#       1                   参数错误
#########################################################################################
function report_cluster_state
{
    if [ $# -lt 1 ];then
        log_echo "error" "${func_name}" "Parameter error.Usage: report_cluster_state cluster_state detail."
        return 1
    fi
    
    typeset func_name="report_cluster_state"
    typeset state=$1 
    typeset separator="{::}{:}"
    shift 1
    typeset detail=$@
    typeset cur_time=""
       
    #去掉参数前后的空格
    state=`echo ${state}`   
    detail=`echo ${detail}`
    
    typeset prompt_state=`echo ${CORRECT_CLUSTER_STATE} | sed "s/ /,/g"`
    validate_cluster_state "${state}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "cluster state must between ${prompt_state}."
        return 1
    fi
    
    #校验双机状态描述长度是否为255
    check_string_length 235 "${detail}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "cluster state detail can contain up to 235 characters."
        return 1
    fi
    
    #获取当前时间
    cur_time=`date "+%Y-%m-%d %H:%M:%S"`
    #封装输出信息
    echo "iDeploy:ClusterState:${state}${separator}${cur_time} ${detail}"
    
    return 0
}

#校验双机状态是否是offline/online/fault/unknown/stopping/starting/stop_failed/start_failed之一
function validate_cluster_state
{
    typeset state=$1
    typeset tmp_state=""
        
    if [ $# -ne 1 ];then
        return 1
    fi    
    
    #判断状态是否是offline/online/fault/unknown/stopping/starting/stop_failed/start_failed之一
    for tmp_state in ${CORRECT_CLUSTER_STATE}
    do
        if [ "X${state}" = "X${tmp_state}" ];then
            return 0
        fi
    done
    
    return 1
}

#校验字符串长度是否在限定的长度内
function check_string_length
{
    typeset limit_length=$1
    shift
    typeset check_str=$@
        
    if [ $# -lt 1 ];then   
        return 1
    fi
    
    #获取字符串长度，并判断是否在要求范围内
    typeset str_length=${#check_str}
    if [ ${str_length} -gt ${limit_length} ];then
        return 1
    fi
    
    return 0
}

#########################################################################################
#   Name:           modify_ip_obtain_policy
#   Description:    修改网卡的IP获取策略
#	input
#  		1. 网卡配置文件路径           需要修改IP获取策略的网卡配置文件路径（绝对路径）
#  		2. ip获取策略                 修改后的IP获取策略
#   Return:  
#		SUCC                                        修改成功
#       ERR_MOD_IP_OBTAIN_POLICY_PARA_ERR           参数不正确
#       ERR_MOD_IP_OBTAIN_POLICY_GET_CURR           获取网卡当前的IP获取策略失败
#       ERR_MOD_IP_OBTAIN_POLICY_MOD_CONFIG_FILE    修改网卡配置文件中的IP获取策略失败
#########################################################################################
function modify_hostip_obtain_policy
{
	typeset func_name="modify_hostip_obtain_policy"	
    typeset policy=$2
    typeset eth_config_file=$1
    typeset curr_policy=""
    typeset -i exist_ip_obtain_policy=0
    	    
    #校验是否有两个参数
    if [ $# -ne 2 ];then
        log_echo "error" "${func_name}" "The parameter number error,required 2 parameter."
        return ${ERR_MOD_IP_OBTAIN_POLICY_PARA_ERR}
    fi
       
    #读取网卡当前的IP获取策略
    exist_ip_obtain_policy=` cat ${eth_config_file} |$GREP "^[ ]*BOOTPROTO" |wc -l`
    if [ ${exist_ip_obtain_policy} -ge 1 ];then
        read_value "${eth_config_file}" "BOOTPROTO"
        if [ $? -ne 0 ] ;then
            log_echo "error" "${func_name}" "Read current ip obtain policy unsuccessful."
            return ${ERR_MOD_IP_OBTAIN_POLICY_GET_CURR}
        fi
        curr_policy="${RETURN[0]}"
    
        #去掉前后的单引号
        trim_quotation_mark "${curr_policy}"
        curr_policy="${RETURN[0]}"
    fi
    
    #网卡当前的IP获取策略与修改后的IP获取策略一致，没有必要修改，直接返回
    if [ "X${curr_policy}" = "X${policy}" ];then
        log_echo "info" "${func_name}" "Current ip obtain policy is ${curr_policy},needn't modify."
        return ${SUCC}
    fi
    
    #修改网卡配置文件中网卡Ip的获取策略
    log_echo "info" "${func_name}" "Modify ip obtain policy in eth card config file ${eth_config_file}."
    if [ ${exist_ip_obtain_policy} -ge 1 ];then
        update_inc_file "${eth_config_file}" "BOOTPROTO" "${policy}"
        if [ $? - ne 0 ];then
            log_echo "error" "${func_name}" "Modify ${alias_name}'s ip obtain policy unsuccessful."
            return ${ERR_MOD_IP_OBTAIN_POLICY_MOD_CONFIG_FILE}
        else
            log_echo "info" "${func_name}" "Modify ${alias_name}'s ip obtain policy successfully."
            return ${SUCC}
        fi
    else
        echo "BOOTPROTO='${policy}'" >> "${eth_config_file}"
        return ${SUCC}
    fi    
    
}

#########################################################################################
#   Name:           modify_eth_card_ip
#   Description:    修改网卡的IP地址
#	input
#  		1. 网卡别名               需要修改IP的网卡名称
#  		2. 新网卡IP               网卡的新IP
#  		3. 新的子网掩码           网卡新的子网掩码  
#       4. 修改IP的设备类型       该参数可选，可以为atae或pcserver
#   Return:  
#		SUCC                          修改成功
#       ERR_MOD_IP_NOT_LINUX          不是linux操作系统
#       ERR_MOD_IP_NOT_ROOT           不是root用户
#       ERR_MOD_IP_PARA_ERROR         参数不正确
#       ERR_MOD_IP_GET_ETH_NAME       获取网卡名称失败
#       ERR_MOD_IP_GET_ETH_CFG_FILE   获取网卡配置文件失败
#       ERR_MOD_IP_GET_CURR_IP        使用ifconfig获取网卡当前IP失败
#       ERR_MOD_IP_GET_CFG_CURR_IP    从网卡配置文件获取当前IP失败
#       ERR_MOD_IP_MOD_HOSTS_IP       修改/etc/hosts中的IP失败
#       ERR_MOD_IP_MOD_CFG_IP         修改网卡配置文件中的IP失败
#       ERR_MOD_IP_MOD_CFG_NETMASK    修改子网掩码失败
#       ERR_MOD_IP_OBTAIN_POLICY      修改网卡的IP获取策略失败
#       ERR_MOD_IP_IP_IS_USED         新的IP已经被其他网卡使用  
#       ERR_MOD_IP_GET_OLD_BOND       获取网卡对应的绑定名称失败
#########################################################################################
function modify_eth_card_ip
{
	typeset func_name="modify_eth_card_ip"
	typeset alias_name=$1
    typeset new_ip=$2
    typeset netmask=$3
    typeset dev_type=$4
    typeset eth_name=""
    typeset eth_config_file=""
    typeset hosts_file="/etc/hosts"
    typeset old_ip=""
    typeset hostname=""
    typeset config_file_eth_ip=""
    typeset -i exist_ip_in_config_file=0
    
    if [ "X${OS_TYPE}" != "Xlinux" ];then
        log_echo "error" "${func_name}" "${func_name} current can't support ${OS_TYPE}."
        return ${ERR_MOD_IP_NOT_LINUX}
    fi
    
    #校验是否是root用户
    isRoot
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Modify eth card ip must use user root."
        return ${ERR_MOD_IP_NOT_ROOT}
    fi
    
    #校验是否传入了2个或3个参数
    if [ $# -lt 2 ];then
        log_echo "error" "${func_name}" "The parameter number error,required 2 or 3 parameter."
        return ${ERR_MOD_IP_PARA_ERROR}
    fi
          
    #根据网卡别名获取网卡名称
    log_echo "info" "${func_name}" "Get eth card name by alias ${alias_name}."
    get_eth_name_by_alias "${alias_name}" "${dev_type}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth card name unsuccessful."
        return ${ERR_MOD_IP_GET_ETH_NAME}
    fi    
    eth_name="${RETURN[0]}"
    
    #根据网卡名称获取网卡配置文件
    log_echo "info" "${func_name}" "Get eth card config file by eth card name ${eth_name}."
    get_config_file_by_eth_name "${eth_name}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth card config file unsuccessful."
        return ${ERR_MOD_IP_GET_ETH_CFG_FILE}
    fi 
    eth_config_file="${RETURN[0]}"
    
    #获取网卡以前的绑定名称
    get_old_bond_name "${eth_name}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth card ${eth_name} bond name unsuccessful."
        return ${ERR_MOD_IP_GET_OLD_BOND}
    fi
    typeset eth_old_bond_name="${RETURN[0]}"
    typeset eth_old_bond_file="/etc/sysconfig/network/ifcfg-${eth_old_bond_name}"
    
    #修改网卡的IP获取策略
    log_echo "info" "${func_name}" "Modify eth card ${eth_name} ip obtain policy."
    modify_hostip_obtain_policy "${eth_config_file}" "${IP_OBTAIN_POLICY}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Modify eth card ip obtain policy unsuccessful."
        return ${ERR_MOD_IP_OBTAIN_POLICY}
    fi
    
    #根据网卡名称获取网卡当前的IP
    log_echo "info" "${func_name}" "Get eth card current ip by eth card name ${eth_name}."
    get_ip_by_eth_name "${eth_name}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth ip unsuccessful."
        return ${ERR_MOD_IP_GET_CURR_IP}
    fi 
    old_ip="${RETURN[0]}"
    
    #读取网卡配置文件中的IP值
    exist_ip_in_config_file=` cat ${eth_config_file} |$GREP "^[ ]*IPADDR" |wc -l`
    
    if [ ${exist_ip_in_config_file} -ge 1 ];then
        log_echo "info" "${func_name}" "Read eth card ip from file ${eth_config_file}."
        read_value "${eth_config_file}" "IPADDR"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Read eth card current ip form ${eth_config_file} unsuccessful."
            return ${ERR_MOD_IP_GET_CFG_CURR_IP}
        fi
        config_file_eth_ip="${RETURN[0]}"
        
        #去掉前后的单引号
        trim_quotation_mark "${config_file_eth_ip}"
        config_file_eth_ip="${RETURN[0]}"
    fi
    
    #判断网卡配置文件中的IP地址与使用ifconfig命令得到的IP地址是否相等
    if [ "X${old_ip}" != "X${config_file_eth_ip}" ];then
        log_echo "warn" "${func_name}" "The eth card ${eth_name}'s ip in file ${eth_config_file} not equal with obtain by command ifconfig."
        old_ip="${config_file_eth_ip}"
        #return 1
    fi
    
    #从etc/hosts中查找该网卡的IP，如果etc/hosts文件中存在该网卡的IP，且当前的IP与新的IP相同，没有必要修改直接返回
    typeset -i num=0
    if [ ! -z "${old_ip}" ];then
       num=` cat ${hosts_file} | grep "^[ 	]*${old_ip}[ 	]*" |wc -l`
    fi
    if [ ${num} -eq 1 -a "X${old_ip}" = "X${new_ip}" ];then
        log_echo "info" "${func_name}" "The eth card ${eth_name}'s ip current is ${old_ip},needn't modify."
        #修改子网掩码
        modify_eth_card_netmask "${eth_config_file}" "${netmask}"
        return $?
    fi
    
    #判断新的IP有没有被其他网卡或绑定使用
    typeset used_ip_file=""    
    is_ip_used "${new_ip}"
    if [ $? -ne 0 ];then
        used_ip_file="${RETURN[0]}"
        #如果使用该IP的网卡配置文件不是当前网卡的配置或当前网卡上次绑定的配置文件，说明该IP被其他网卡或绑定使用了
        if [ "X${used_ip_file}" != "X${eth_config_file}" -a "X${used_ip_file}" != "X${eth_old_bond_file}" ];then
            log_echo "error" "${func_name}" "The new ip:${new_ip} is used by other eth card." 
            return ${ERR_MOD_IP_IP_IS_USED}  
        fi         
    fi
    
    typeset hostname=`hostname`
    typeset curr_hostname=""
    typeset curr_hostalias=""
    typeset -i new_ip_num=0
    
    #修改/etc/hosts中的IP，如果/etc/hosts中以前没有写入该IP，则直接写入，否则替换
    log_echo "info" "${func_name}" "Modify eth card ip in file ${hosts_file}."
    #修改前备份/etc/hosts文件
    cp "${hosts_file}" "${hosts_file}.bak"
    if [ ${num} -lt 1 ];then
        #判断/etc/hosts中是否已经写过新的IP，如果已经写过则不写
        new_ip_num=` cat "${hosts_file}" | $GREP "^[ 	]*${new_ip}[ 	]*${hostname}$" |wc -l`
        if [ ${new_ip_num} -lt 1 ];then
            echo "${new_ip}   ${hostname}" >> "${hosts_file}"
        fi
    else
        curr_hostname=` cat "${hosts_file}" | $AWK -v key="${old_ip}" '{ if ($1 == key) print $2}'`
        curr_hostalias=` cat "${hosts_file}" | $AWK -v key="${old_ip}" '{ if ($1 == key) print $3}'`
        if [ -z "${curr_hostname}" ];then
            curr_hostname="${hostname}"
        fi
        
        #修改etc/hosts中的IP
        if [ -z "${curr_hostalias}" ];then
            file_replace_line_by_exp "${hosts_file}" "^[ 	]*${old_ip}[ 	]*" "${new_ip}   ${curr_hostname}"
        else
            file_replace_line_by_exp "${hosts_file}" "^[ 	]*${old_ip}[ 	]*" "${new_ip}   ${curr_hostname}   ${curr_hostalias}"
        fi
                
	    if [ $? -ne 0 ];then
	        log_echo "error" "${func_name}" "Modify new ip in ${hosts_file} unsuccessful."
	        cp "${hosts_file}.bak" "${hosts_file}"
		    return ${ERR_MOD_IP_MOD_HOSTS_IP}
	    fi
    fi
       		
	#修改网卡配置文件中网卡Ip
	log_echo "info" "${func_name}" "Modify eth card ip in eth config file ${eth_config_file}."
	if [ ${exist_ip_in_config_file} -ge 1 ];then
        update_inc_file "${eth_config_file}" "IPADDR" "${new_ip}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Modify new ip in ${eth_config_file} unsuccessful."
            cp "${hosts_file}.bak" "${hosts_file}"
            return ${ERR_MOD_IP_MOD_CFG_IP}    
        fi
    else
        echo "IPADDR='${new_ip}'" >> "${eth_config_file}"
    fi
       
    
    #如果网卡以前的绑定配置文件存在，删除以前的绑定文件
    if [ -f "${eth_old_bond_file}" ];then
        rm -f "${eth_old_bond_file}"
    fi
       
    #修改子网掩码
    modify_eth_card_netmask "${eth_config_file}" "${netmask}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Modify netmask in ${eth_config_file} unsuccessful."
        cp "${hosts_file}.bak" "${hosts_file}"
        return ${ERR_MOD_IP_MOD_CFG_NETMASK} 
    fi
				
    rm -rf "${hosts_file}.bak"
	log_echo "info" "${func_name}" "Modify ${alias_name}'s ip successfully."
	return ${SUCC}
}

#########################################################################################
#   Name:           modify_eth_card_netmask
#   Description:    修改网卡配置文件中的子网掩码
#	input
#  		1. 网卡配置文件           网卡对应的配置文件
#  		2. 子网掩码               新的子网掩码
#   Return:  
#		SUCC                        修改子网掩码成功
#       ERR_MOD_NETMASK_GET_CURR    获取当前的子网掩码失败
#       ERR_MOD_NETMASK_FAIL        修改网卡配置文件中子网掩码失败
#########################################################################################
function modify_eth_card_netmask
{
	typeset func_name="modify_eth_card_netmask"
	typeset eth_config_file=$1
	typeset netmask=$2
	typeset old_netmask=""
	typeset -i exist_netmask=0
	
	#如果传入的子网掩码为空，不修改直接返回
	if [ -z "${netmask}" ];then
	    log_echo "info" "${func_name}" "Needn't modify eth card netmask."
	    return ${SUCC}
	fi
	
	exist_netmask=` cat ${eth_config_file} |$GREP "^[ ]*NETMASK" |wc -l`
	
	if [ ${exist_netmask} -ge 1 ];then
	    #读取当前网卡配置文件中的子网掩码
	    read_value "${eth_config_file}" "NETMASK"
	    if [ $? -ne 0 ];then
	        log_echo "error" "${func_name}" "Read netmask in ${eth_config_file} unsuccessful."
            return ${ERR_MOD_NETMASK_GET_CURR} 
	    fi
	    old_netmask="${RETURN[0]}"
	
	    #去掉前后的单引号
        trim_quotation_mark "${old_netmask}"
        old_netmask="${RETURN[0]}"
    fi
	
	#判断当前的子网掩码和新的子网掩码是否相同，如果相同则不用修改
	if [ "X${old_netmask}" = "X${netmask}" ];then
	    log_echo "info" "${func_name}" "The current netmask is ${old_netmask},needn't modify eth card netmask."
	    return ${SUCC}
	fi
	
	#修改网卡配置文件中的子网掩码
	log_echo "info" "${func_name}" "Modify eth card netmask in eth config file ${eth_config_file}."
	if [ ${exist_netmask} -ge 1 ];then
	    update_inc_file "${eth_config_file}" "NETMASK" "${netmask}"  
	    if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Modify netmask in ${eth_config_file} unsuccessful."
            return ${ERR_MOD_NETMASK_FAIL}    
        fi
    else
        echo "NETMASK='${netmask}'" >> "${eth_config_file}"
    fi
    
    log_echo "info" "${func_name}" "Modify eth card netmask successfully."
    return ${SUCC}
}
#########################################################################################
#   Name:           get_bond_old_ip
#   Description:    获取网卡绑定IP
#	input
#  		1. 绑定名称              绑定后IP
#########################################################################################
function get_bond_old_ip
{
    typeset bond_name=$1
    typeset bond_file="/etc/sysconfig/network/ifcfg-${bond_name}"   
    typeset old_bond_ip=""
        
    #参数个数校验
    if [ $# -ne 1 ];then
        log_echo "warn" "${func_name}" "Please input bond name."
        return 1
    fi
    
    #判断网卡绑定文件是否存在，如果不存在直接返回1，需要修改
    if [ ! -f ${bond_file} ];then
       return 1
    fi
    
    #获取旧的绑定IP
    read_value "${bond_file}" "IPADDR"
    if [ $? -ne 0 ] ;then
        log_echo "warn" "${func_name}" "Read bond ${bond_name} current ip unsuccessful."
        return 1
    fi
    old_bond_ip="${RETURN[0]}"    
    #去掉前后的单引号
    trim_quotation_mark "${old_bond_ip}"
    return 0 
}

#########################################################################################
#   Name:           modify_eth_card_bond
#   Description:    修改网卡的绑定关系
#	input
#  		1. 绑定IP                 绑定后IP
#  		2. 绑定名称               绑定关系名称
#  		3. 网卡1别名              绑定网卡1的名称
#  		4. 网卡2别名              绑定网卡2的名称
#  		5. 子网掩码               子网掩码
#       6. 是否重启网卡           取值为true和false，true表示重启网卡，false表示不重启网卡。没有该参数时默认为true
#       7. 修改网卡绑定关系的设备类型   该参数可选，取值为atae或pcserver
#   Return:  
#		SUCC                           修改网卡绑定关系成功
#       ERR_ETH_BOND_NOT_LINUX         不是Linux操作系统
#       ERR_ETH_BOND_NOT_ROOT          不是root用户
#       ERR_ETH_BOND_PARA_ERROR        参数不正确
#       ERR_ETH_BOND_GET_ETH_NAME      获取网卡名称失败 
#       ERR_ETH_BOND_GET_ETH_CFG_FILE  获取网卡配置文件失败
#       ERR_ETH_BOND_GET_OLD_BOND      获取网卡老的绑定名称失败
#       ERR_ETH_BOND_RESTART_NETWORK   网卡绑定，重启网卡失败 
#       ERR_ETH_BOND_FILE_NOT_EXIST    网卡绑定文件没有生成
#       ERR_ETH_BOND_FAIL              网卡绑定失败
#       ERR_ETH_BOND_IP_IS_USED        绑定的IP被其他网卡使用 
#########################################################################################
function modify_eth_card_bond
{
	typeset func_name="modify_eth_card_bond"
	typeset bond_ip=$1
    typeset bond_name=$2
    typeset eth1_alias_name=$3
    typeset eth2_alias_name=$4
    typeset netmask=$5
    typeset is_restart=$6
    typeset dev_type=$7 
    typeset eth1_name=""
    typeset eth2_name=""
    typeset bond_file="/etc/sysconfig/network/ifcfg-${bond_name}"  
    typeset used_ip_file=""
    typeset backup_dir="${IDEPLOY_PKG_PATH}/modifyip_backup"
    typeset hosts_file="/etc/hosts"
    
    if [ "X${OS_TYPE}" != "Xlinux" ];then
        log_echo "error" "${func_name}" "${func_name} current can't support ${OS_TYPE}."
        return ${ERR_ETH_BOND_NOT_LINUX}
    fi
    
    #校验是否是root用户
    isRoot
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Bond eth card must use user root."
        return ${ERR_ETH_BOND_NOT_ROOT}
    fi
    
    #校验参数个数
    if [ $# -lt 5 ];then
        log_echo "error" "${func_name}" "The parameter number error,required 5 parameter."
        return ${ERR_ETH_BOND_PARA_ERROR}
    fi
         
    #根据网卡1别名获取网卡名称
    log_echo "info" "${func_name}" "Get eth card name by alias ${eth1_alias_name}."
    get_eth_name_by_alias "${eth1_alias_name}" "${dev_type}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth name unsuccessful."
        return ${ERR_ETH_BOND_GET_ETH_NAME}
    fi    
    eth1_name="${RETURN[0]}"
    
    #根据网卡2别名获取网卡名称
    log_echo "info" "${func_name}" "Get eth card name by alias ${eth2_alias_name}."
    get_eth_name_by_alias "${eth2_alias_name}" "${dev_type}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth name unsuccessful."
        return ${ERR_ETH_BOND_GET_ETH_NAME}
    fi    
    eth2_name="${RETURN[0]}"
    #判断是否需要修改网卡绑定，如果绑定的IP、名称、网卡1、网卡2、子网掩码相同的绑定已经存在，则不用重新绑定，直接返回。
    is_need_modify_eth_bond "${bond_ip}" "${bond_name}" "${eth1_name}" "${eth2_name}" "${netmask}"
    if [ $? -eq 0 ];then
        log_echo "info" "${func_name}" "Network card bond ${bond_name} already exist, need't bond."
        return ${SUCC}
    fi
    #根据网卡名称获取网卡配置文件
    get_config_file_by_eth_name "${eth1_name}" "false"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth config file unsuccessful."
        return ${ERR_ETH_BOND_GET_ETH_CFG_FILE}
    fi 
    typeset eth1_config_file="${RETURN[0]}"
     #根据网卡名称获取网卡配置文件
    get_config_file_by_eth_name "${eth2_name}" "false"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth config file unsuccessful."
        return ${ERR_ETH_BOND_GET_ETH_CFG_FILE}
    fi 
    typeset eth2_config_file="${RETURN[0]}"
             
    #判断新的绑定IP是否被其他网卡使用 
    is_ip_used "${bond_ip}"
    if [ $? -ne 0 ];then
        used_ip_file="${RETURN[0]}"
        if [ "X${used_ip_file}" != "X${bond_file}" -a "X${used_ip_file}" != "X${eth1_config_file}" -a "X${used_ip_file}" != "X${eth2_config_file}" ];then
            log_echo "error" "${func_name}" "The bond ip:${bond_ip} is used by other." 
            return ${ERR_ETH_BOND_IP_IS_USED} 
        fi             
    fi
 
    #set -x
    #修改/etc/hosts中的IP，如果/etc/hosts中以前没有写入该IP，则直接写入，否则替换
    log_echo "info" "${func_name}" "Modify bond ip in file ${hosts_file}."
    typeset old_bond_ip="";
    typeset hostname=`hostname`
    typeset curr_hostname=""
    typeset curr_hostalias=""
    typeset -i new_ip_num=0
    typeset -i old_ip_num=0
    
    get_bond_old_ip "${bond_name}"
    if [ $? -eq 0 ];then
        old_bond_ip="${RETURN[0]}"
    fi
    
    cp "${hosts_file}" "${hosts_file}.bak"
    
    if [ -z "${old_bond_ip}" ];then
        new_ip_num=` cat "${hosts_file}" | $GREP "^[ 	]*${bond_ip}[ 	]*.*" |wc -l`
        if [ ${new_ip_num} -lt 1 ];then
            echo "${bond_ip}   ${hostname}" >> "${hosts_file}"           
        fi
    else
        old_ip_num=` cat "${hosts_file}" | $GREP "^[ 	]*${old_bond_ip}[ 	]*.*" |wc -l`
        if [ ${old_ip_num} -lt 1 ];then
            new_ip_num=` cat "${hosts_file}" | $GREP "^[ 	]*${bond_ip}[ 	]*.*" |wc -l`
            if [ ${new_ip_num} -lt 1 ];then
                echo "${bond_ip}   ${hostname}" >> "${hosts_file}"
            fi
        else
            cat "${hosts_file}.bak" | $SED "s/${old_bond_ip}/${bond_ip}/g" > "${hosts_file}"
            if [ $? -ne 0 ];then
                log_echo "error" "${func_name}" "Modify new ip in ${hosts_file} unsuccessful."
	        cp "${hosts_file}.bak" "${hosts_file}"
		return ${ERR_ETH_BOND_FAIL}
            fi
        fi
    fi
        
    #将网卡绑定信息写入到绑定配置文件中         
    echo "BOOTPROTO='static'" > ${bond_file}
    echo "IPADDR=${bond_ip}" >> ${bond_file}
    echo "NETMASK=${netmask}" >> ${bond_file}
    echo "STARTMODE='onboot'" >> ${bond_file}
    echo "BONDING_MASTER='yes'" >> ${bond_file}
    echo "BONDING_MODULE_OPTS='mode=1 miimon=200 use_carrier=1'" >> ${bond_file}
    echo "BONDING_SLAVE0=${eth1_name}" >> ${bond_file}
    echo "BONDING_SLAVE1=${eth2_name}" >> ${bond_file}
        
    #判断存放备份文件的目录是否存在，如果不存在则创建    
    if [ ! -d "${backup_dir}" ];then
        mkdir -p "${backup_dir}"
    fi
    #删除绑定的网卡1的配置文件
    if [ -f "${eth1_config_file}" ];then
        cp "${eth1_config_file}" "${backup_dir}"
        rm -f "${eth1_config_file}"
    fi
    
    #有可能存在ifcfg-网卡名称的网卡配置文件，如果存在需要删除该文件，否则网卡绑定会失败
    eth1_config_file="/etc/sysconfig/network/ifcfg-${eth1_name}"
    if [ -f "${eth1_config_file}" ];then
        cp "${eth1_config_file}" "${backup_dir}"
        rm -f "${eth1_config_file}"
    fi
              
    #删除绑定的网卡2的配置文件
    if [ -f "${eth2_config_file}" ];then
        cp "${eth2_config_file}" "${backup_dir}"
        rm -f "${eth2_config_file}"
    fi
    #有可能存在ifcfg-网卡名称的网卡配置文件，如果存在需要删除该文件，否则网卡绑定会失败
    eth2_config_file="/etc/sysconfig/network/ifcfg-${eth2_name}"
    if [ -f "${eth2_config_file}" ];then
        cp "${eth2_config_file}" "${backup_dir}"
        rm -f "${eth2_config_file}"
    fi
      
    #获取绑定网卡1以前的绑定名称
    get_old_bond_name "${eth1_name}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth card ${eth1_name} bond name unsuccessful."
        return ${ERR_ETH_BOND_GET_OLD_BOND}
    fi
    typeset eth1_old_bond_name="${RETURN[0]}"
    typeset eth1_old_bond_file="/etc/sysconfig/network/ifcfg-${eth1_old_bond_name}"
    
    #如果绑定网卡1以前的绑定名称不为空且与当前的绑定名称不一样，删除以前的绑定文件
    if [ ! -z "${eth1_old_bond_name}" -a "X${eth1_old_bond_name}" != "X${bond_name}" ];then       
        if [ -f "${eth1_old_bond_file}" ];then
            rm -f "${eth1_old_bond_file}"
        fi
    fi
    #获取绑定网卡2以前的绑定名称
    get_old_bond_name "${eth2_name}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get eth card ${eth2_name} bond name unsuccessful."
        return ${ERR_ETH_BOND_GET_OLD_BOND}
    fi
    typeset eth2_old_bond_name="${RETURN[0]}"
    typeset eth2_old_bond_file="/etc/sysconfig/network/ifcfg-${eth2_old_bond_name}"
    
    #如果绑定网卡2以前的绑定名称不为空且与当前的绑定名称不一样，删除以前的绑定文件
    if [ ! -z "${eth2_old_bond_name}" -a "X${eth2_old_bond_name}" != "X${bond_name}" ];then       
        if [ -f "${eth2_old_bond_file}" ];then
            rm -f "${eth2_old_bond_file}"
        fi
    fi
    
    #如果不需要重启网卡，直接返回
    if [ "X${is_restart}" = "Xfalse" ];then
        return ${SUCC}
    fi
    
    #启动双网卡绑定
    restart_eth_card ${func_name}
#    mkdir -p ${IDEPLOY_PKG_PATH}/modifyip_backup
#    rcnetwork restart >${IDEPLOY_PKG_PATH}/modifyip_backup/restart.info 2>&1
#    if [ $? -ne 0 ];then
#        log_echo "file" "${func_name}" "start net bond failed."
#        #return ${ERR_ETH_BOND_RESTART_NETWORK}
#    fi
    
    typeset check_bond_file="/proc/net/bonding/${bond_name}"
    typeset -i i=0
    #sleep一段时间，等待绑定文件生成
    while [ ${i} -lt 10 ]
    do
        if [ -f "${check_bond_file}" ];then
            break;
        fi
        
        sleep 3
        ((i+=1))
    done
    if [ ! -f "${check_bond_file}" ];then
        log_echo "error" "${func_name}" "Build net bond unsuccessful."
        return ${ERR_ETH_BOND_FILE_NOT_EXIST}
    fi
    #等待文件中写入内容
    typeset active_num=0
    typeset status_num=0
    i=0
    while [ ${i} -lt 10 ]
    do
    	active_num=`cat ${check_bond_file} |grep "Currently Active Slave: " |wc -l`
    	status_num=`cat ${check_bond_file} |grep "MII Status: up" |wc -l`
        if [ ${active_num} -ne 0 -a ${status_num} -ne 0 ];then
            break;
        fi
        log_echo "info" "${func_name}" "wating for make the bond file: ${check_bond_file}"
        sleep 3
        ((i+=1))
    done
    #typeset active_num=`cat ${check_bond_file} |grep "Currently Active Slave: ${eth1_name}" |wc -l`
    #typeset status_num=`cat ${check_bond_file} |grep "MII Status: up" |wc -l`
    typeset active_eth=""
    if [ "${active_num}" -eq 1 -a "${status_num}" -eq 3 ];then
        active_eth=`cat ${check_bond_file} |grep "Currently Active Slave: " | $AWK -F: '{print $2}'`
        active_eth=`echo ${active_eth}`
        
        if [ "X${active_eth}" != "X${eth1_name}" ];then
            log_echo "warn" "${func_name}" "Currently Active Slave is ${active_eth}, not ${eth1_name}."
        fi
        
        log_echo "info" "${func_name}" "Build net bond successfully."
        return ${SUCC}
    else
       log_echo "warn" "${func_name}" "Build net bond unsuccessful.Currently Active Slave incorrect or MII Status is not up,please view the file:${check_bond_file}"
        return ${SUCC}
    fi
}

#########################################################################################
#   Name:           get_old_bond_name
#   Description:    获取网卡1当前的绑定名称，如果没有返回空
#	input
#  		1. 绑定的网卡1名称       
#   Return:  
#		
#       
#########################################################################################
function get_old_bond_name
{
	typeset func_name="get_old_bond_name"
	typeset eth_card_name=$1
	typeset mac_address=""
	typeset -i exist_inet_addr=0
	typeset bond_name=""
	
	#校验参数个数
    if [ $# -ne 1 ];then
        log_echo "error" "${func_name}" "The parameter number error,required 1 parameter."
        return 1
    fi
    
    #获取网卡的mac地址
    mac_address=`ifconfig -a |$AWK -v key="${eth_card_name}" '{ if ($1 == key) print $5}'`
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Obtain ${1} mac address unsuccessful."
        return 1
    fi
    
    #获取网卡mac地址对应的网卡名称和绑定名称列表
    typeset temp_eth_name_list=`ifconfig -a | awk -v key="${mac_address}" '{ if ($5==key) print $1}'`
	if [ $? -ne 0 ];then
	    log_echo "error" "${func_name}" "Get mac address ${mac_address}'s eth name unsuccessful."
        return 1
	fi
	
	#判断mac地址对应的网卡名称和绑定名称列表，找到绑定名称
	for temp_eth_name in ${temp_eth_name_list}
    do
        if [ "X${temp_eth_name}" = "X${eth_card_name}" ];then
            continue
        fi
        
        exist_inet_addr=`ifconfig ${temp_eth_name} |grep "inet addr:" |wc -l`
        
        if [ ${exist_inet_addr} -eq 1 ];then
            bond_name="${temp_eth_name}"
            break
        fi
    done

	RETURN[0]="${bond_name}"
    return 0
}

#########################################################################################
#   Name:           restart_eth_card
#   Description:    重启网卡
#	input
#  		无
#   Return:  
#		0 重启成功
#       1 重启失败 
#   重启失败的信息在log中记录，不在页面打印
#########################################################################################
function restart_eth_card
{
	typeset func_name="restart_eth_card"
	
	if [ "X$1" != "X" ];then
	    func_name=$1
	fi
	#创建重启信息的文件
    mkdir -p ${IDEPLOY_PKG_PATH}/modifyip_backup
    typeset restart_detail_file="${IDEPLOY_PKG_PATH}/modifyip_backup/restart.info"
    if [ -f ${restart_detail_file} ];then
        echo `date` >> ${restart_detail_file}
    else
        echo `date` > ${restart_detail_file}
    fi
    
    rcnetwork restart >> ${restart_detail_file} 2>&1
	if [ $? -ne 0 ];then
	    log_echo "warn" "${func_name}" "There has some exception when restart network,please check the file \"${restart_detail_file}\" for detailed information"
        return 1
	fi
	
    return 0
}

#########################################################################################
#   Name:           get_eth_name_by_alias
#   Description:    根据网卡别名获取网卡名称
#	input
#  		1. 网卡别名       网卡的别名
#       2. 设备类型       该参数可选，表示当前修改IP的设备类型
#   Return:  
#		SUCC 获取成功
#       ERR_GET_ETH_NAME_NOT_LINUX       不是Linux操作系统
#       ERR_GET_ETH_NAME_PARA_ERROR      参数不正确
#       ERR_ETH_ALIAS_SCRIPT_NOT_EXIST   获取网卡别名和网卡对应关系的脚本eth_alias.sh不存在
#       ERR_ETH_NAME_NOT_UNIQUE          与网卡别名匹配的网卡名称不唯一
#       ERR_ETH_NAME_NOT_EXIST           网卡别名对应的网卡名称不存在
#########################################################################################
function get_eth_name_by_alias
{
	typeset alias_script_name="/var/adm/autoinstall/scripts/eth_alias.sh"
	typeset -i alias_name_num=0
	typeset alias=$1
	typeset dev_type=$2
	
    if [ "X${OS_TYPE}" != "Xlinux" ];then
        log_echo "error" "get_eth_name_by_alias" "get_eth_name_by_alias current can't support ${OS_TYPE}."
        return ${ERR_GET_ETH_NAME_NOT_LINUX}
    fi
    
    if [ $# -lt 1 ];then
        log_echo "error" "get_eth_name_by_alias" "The parameter number error,require 1 parameter."
        return ${ERR_GET_ETH_NAME_PARA_ERROR}
    fi
    
    if [ "X${dev_type}" = "Xpcserver" ];then
        RETURN[0]="${alias}"
        return ${SUCC}
    fi   
      
    if [ ! -f "${alias_script_name}" ];then
        log_echo "error" "get_eth_name_by_alias" "The script ${alias_script_name} inexistent or not a file."
        return ${ERR_ETH_ALIAS_SCRIPT_NOT_EXIST}
    fi
        
    alias_name_num=`${alias_script_name} | $GREP "${alias}" | wc -l`
    if [ ${alias_name_num} -ne 1 ];then
        log_echo "error" "get_eth_name_by_alias" "The eth alias name ${alias} not unique."
        return ${ERR_ETH_NAME_NOT_UNIQUE}
    fi
    
    typeset eth_name=`${alias_script_name} | $GREP "${alias}" | $AWK '{ print $1 }'`
    if [ -z "${eth_name}" ];then
        log_echo "error" "get_eth_name_by_alias" "The eth name is empty."
        return ${ERR_ETH_NAME_NOT_EXIST}
    fi
    
    RETURN[0]="${eth_name}"
    return ${SUCC}
}

#########################################################################################
#   Name:           get_config_file_by_eth_name
#   Description:    根据网卡名称获取mac地址
#	input
#  		1. 网卡名称       网卡的名称
#  		2. 获取文件为空是否提示错误       true 提示； false 不提示
#   Return:  
#		0 获取成功
#       1 获取失败
#########################################################################################
function get_config_file_by_eth_name
{
	typeset func_name="get_config_file_by_eth_name"
	typeset is_empty_prompt=$2
	typeset temp_ifconfig_file=""
	
	#2011-05-24  begin 增加变量 tmp_nc_alais_name 用来保存网卡别名<比如eth3>
	typeset tmp_nc_alais_name=$1
	#2011-05-24  end 增加变量 tmp_nc_alais_name 用来保存网卡别名<比如eth3>
	
    if [ "X${OS_TYPE}" != "Xlinux" ];then
        log_echo "error" "${func_name}" "${func_name} current can't support ${OS_TYPE}."
        return 1
    fi
    
    if [ $# -lt 1 ];then
        log_echo "error" "${func_name}" "The parameter number error,require 1 parameter."
        return 1
    fi
        
    if [ -z "${is_empty_prompt}" ];then
        is_empty_prompt="true"
    fi    
    
    typeset mac_address=`ifconfig -a |$AWK -v key="$1" '{ if ($1 == key) print tolower($5)}'`
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Obtain ${1} mac address unsuccessful."
        return 1
    fi
    
    typeset ifconfig_file=`ls /etc/sysconfig/network |$GREP -i "^ifcfg-eth-id-${mac_address}$"`
    
    #2011-05-24  begin 增加网卡的ip配置文件不使用mac地址而是使用网卡别名的方式(suse11只支持这种方式)
	if [ -z "${ifconfig_file}" ];then
	  #DTS2014012008569，根据网卡别名匹配不精确问题
	  ifconfig_file=`ls /etc/sysconfig/network |$GREP -i "^ifcfg-${tmp_nc_alais_name}$"`
	fi
	#2011-05-24  end 增加网卡的ip配置文件不使用mac地址而是使用网卡别名的方式(suse11只支持这种方式)
	
    #如果配置文件不存在，生成一个默认的
    if [ -z "${ifconfig_file}" -a "X${is_empty_prompt}" = "Xtrue" ];then
        log_echo "info" "${func_name}" "The eth config file inexistent,create a new."
        ifconfig_file="ifcfg-eth-id-${mac_address}"
        
        #2011-05-24  begin 判断如果是suse11，则新增的网卡配置文件必须是以网卡别名命名<SUSE11 只支持这种方式>
        if [ "X${LINUX_TYPE}" = "XSUSE11" ];then
           ifconfig_file="ifcfg-${tmp_nc_alais_name}"
        fi
        #2011-05-24  begin 判断如果是suse11，则新增的网卡配置文件必须是以网卡别名命名<SUSE11 只支持这种方式>
        
        temp_ifconfig_file="/etc/sysconfig/network/${ifconfig_file}"
        echo "BOOTPROTO='static'" > "${temp_ifconfig_file}"
        echo "MTU=''" >> "${temp_ifconfig_file}"
        echo "REMOTE_IPADDR=''" >> "${temp_ifconfig_file}"
        echo "STARTMODE='onboot'" >> "${temp_ifconfig_file}"
        echo "IPADDR=''" >> "${temp_ifconfig_file}"
        echo "NETMASK='255.255.255.0'" >> "${temp_ifconfig_file}"
        echo "NETWORK=''" >> "${temp_ifconfig_file}"
        echo "BROADCAST=''" >> "${temp_ifconfig_file}"      
    fi
    
    RETURN[0]="/etc/sysconfig/network/${ifconfig_file}"
    return 0
}

#########################################################################################
#   Name:           update_inc_file
#   Description:    向键格式的文件的某个键更新某个键
#	input
#  		1. 文件名       
#  		2. 键       
#  		3. 值       
#   Return:  
#		0 更新成功
#       1 更新失败
#########################################################################################
function update_inc_file
{
	typeset func_name="update_inc_file"
    
    typeset file_name="$1"
	typeset key_name="$2"	
 	typeset key_value="$3"
	typeset line_buf=""
	
	typeset -i loc_line_index=0
	typeset -i ret_num=0
		
	if [ $# -ne 3 ];then
		log_echo "error" "${func_name}" "The parameter number error,require 3 parameter."
        return 1
	fi

	file_is_exist "$file_name"
	if [ $? -ne 0 ];then		
		log_echo "error" "${func_name}" "The update file inexistent."
        return 1	
	fi	
	
	$GREP "^[ 	]*${key_name}[ 	]*=" "${file_name}" >${IDEPLOY_NULL} 2>&1		
	if [ $? -ne 0 ];then
		log_echo "error" "${func_name}" "The file: ${file_name} inexistent key: ${key_name} ."
        return 1
	fi
	
	file_replace_line_by_exp "$file_name" "^[ 	]*${key_name}[ 	]*=" "${key_name}='${key_value}'"
	if [ $? -ne 0 ];then
	    log_echo "error" "${func_name}" "Update file ${file_name}'s key: ${key_name} unsuccessful."
		return 1
	fi
	
	return 0	
}

#########################################################################################
#   Name:           get_ip_by_eth_name
#   Description:    根据网卡名称获取IP地址
#	input
#  		1. 网卡名称      
#   Return:  
#		0 获取成功
#       1 获取失败
#########################################################################################
function get_ip_by_eth_name
{
	typeset func_name="get_ip_by_eth_name"
    
    typeset eth_name="$1"
	
	if [ $# -ne 1 ];then
		log_echo "error" "${func_name}" "The parameter number error,require 1 parameter."
        return 1
	fi			
	
	typeset ip=`ifconfig "${eth_name}" |$GREP "inet addr" |$AWK '{print $2}'|$AWK -F: '{print $2}'`
	if [ $? -ne 0 ];then
	    log_echo "error" "${func_name}" "Obtain ${eth_name} ip unsuccessful."
        return 1
	fi
    RETURN[0]="${ip}"
	
	return 0	
}

#########################################################################################
#   Name:           isRoot
#   Description:    判断当前执行脚本的用户是否是root用户
#	input
#  		
#   Return:  
#		0 是root用户
#       1 不是root用户
#########################################################################################
function isRoot
{
	#获取当前用户名
    typeset currUser=`whoami`
    typeset func_name="isRoot"
    
    log_echo "info" "${func_name}" "current user is ${currUser}."
    
    #判断当前用户名是否是root
    if [ "X${currUser}" = "Xroot" ];then
        return 0
    else
        return 1
    fi    
}

#########################################################################################
#   Name:           is_ip_used
#   Description:    判断ip是否已经被该机器上的某个网卡使用
#	input
#  		ip  需要判断的ip
#   Return:  
#		0 该IP未被使用
#       1 该IP已被某个网卡使用，如果IP被使用，RETURN[0]中保存使用该IP的配置文件
#########################################################################################
function is_ip_used
{	
	typeset network_config_path="/etc/sysconfig/network/"
    typeset eth_card_config_file_list=`ls -al  ${network_config_path} | $AWK '{print $NF}' | $GREP -v ".bak$" | $GREP "^ifcfg-"`
    typeset eth_card_config_file=""
    typeset ip=$1
    typeset exist_ip="" 
    
    RETURN[0]=""
    
    if [ -z "${ip}" ];then
        return 0
    fi
    
    for eth_card_config_file in ${eth_card_config_file_list}
    do
        exist_ip=`cat ${network_config_path}${eth_card_config_file} | $AWK -F= '{if ($1=="IPADDR") print $2}'`
        trim_quotation_mark "${exist_ip}"
        exist_ip="${RETURN[0]}"
                
        if [ "X${ip}" = "X${exist_ip}" ];then
            RETURN[0]="${network_config_path}${eth_card_config_file}"
            return 1           
        fi
    done
    
    return 0
}

#########################################################################################
#   Name:           trim_quotation_mark
#   Description:    去掉字符串前后的单引号
#	input
#  		需要处理的字符串
#   Return:  
#		0 处理成功
#       1 处理失败
#########################################################################################
function trim_quotation_mark
{
	typeset trimStr=$1
    
    trimStr=`echo ${trimStr} | $AWK -F\' '{if ( $1=="" ) {print $2} else {print $1}}'`  
    
    RETURN[0]="${trimStr}"
    return 0
}

#########################################################################################
#   Name:           modify_default_route
#   Description:    修改默认路由
#	input
#  		1. 默认路由       
#   Return:  
#		SUCC                                  修改默认路由成功
#       ERR_MOD_DEFAULT_ROUTE_NOT_LINUX       不是Linux操作系统
#       ERR_MOD_DEFAULT_ROUTE_NOT_ROOT        不是root用户
#       ERR_MOD_DEFAULT_ROUTE_PARA_ERR        参数不正确，要求输入一个参数   
#       ERR_MOD_DEFAULT_ROUTE_CFG_FILE_FAIL   修改路由配置文件中默认路由失败
#########################################################################################
function modify_default_route
{
	typeset route_cfg_file="/etc/sysconfig/network/routes"
	typeset func_name="modify_default_route"
	typeset default_route=$1
	
	#校验是否是linux系统
	if [ "X${OS_TYPE}" != "Xlinux" ];then
        log_echo "error" "${func_name}" "${func_name} current can't support ${OS_TYPE}."
        return ${ERR_MOD_DEFAULT_ROUTE_NOT_LINUX}
    fi
    
    #校验是否是root用户
    isRoot
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Modify defaluat route must use user root."
        return ${ERR_MOD_DEFAULT_ROUTE_NOT_ROOT}
    fi
    
    if [ $# -ne 1 ];then
        log_echo "error" "${func_name}" "Please input default route ip."
        return ${ERR_MOD_DEFAULT_ROUTE_PARA_ERR}
    fi
    
    #判断路由配置文件是否存在，如果不存在创建
    if [ ! -f ${route_cfg_file} ];then
        log_echo "info" "${func_name}" "The route config file ${route_cfg_file} inexistent,ceate new."
        touch ${route_cfg_file}
    fi
    
    #修改路由配置文件前先备份
    cp ${route_cfg_file} ${route_cfg_file}.bak
    
    #修改路由配置文件中的默认路由信息
    if [ `cat ${route_cfg_file} |$GREP -c "^default[ 	]"` -gt 0 ];then
        $SED "s/^default[ 	].*$/default ${default_route} - -/" ${route_cfg_file} > ${route_cfg_file}.tmp
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Modify default route to ${default_route} in file ${route_cfg_file} unsuccessful."
            return ${ERR_MOD_DEFAULT_ROUTE_CFG_FILE_FAIL}
        fi
        mv ${route_cfg_file}.tmp ${route_cfg_file}
    else
        echo "default ${default_route} - -" >> ${route_cfg_file}
    fi
    
    log_echo "info" "${func_name}" "Modify default route to ${default_route} successfully."
    return ${SUCC}
}
#########################################################################################
#   Name:           modify_time_zone
#   Description:    修改SUSE的时区信息
#	input
#  		1. 时区信息       
#   Return:  
#		SUCC                                  修改时区成功
#       ERR_MOD_TIME_ZONE_NOT_LINUX       不是Linux操作系统
#       ERR_MOD_TIME_ZONE_NOT_ROOT        不是root用户
#       ERR_MOD_TIME_ZONE_PARA_ERR        参数不正确，要求输入一个参数   
#       ERR_MOD_TIME_ZONE_FILE_FAIL       修改的时区信息文件在目录 /usr/share/zoneinfo/ 中不存在
#########################################################################################
function modify_time_zone
{
	typeset time_zone_dir="/usr/share/zoneinfo/"
	typeset func_name="modify_time_zone"
	typeset time_zone_file=$1
	
	#校验是否是linux系统
	if [ "X${OS_TYPE}" != "Xlinux" ];then
        log_echo "error" "${func_name}" "${func_name} current can't support ${OS_TYPE}."
        return ${ERR_MOD_TIME_ZONE_NOT_LINUX}
    fi
    
    #校验是否是root用户
    isRoot
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Modify time zone must use root user."
        return ${ERR_MOD_TIME_ZONE_NOT_ROOT}
    fi
    
    if [ $# -ne 1 ];then
        log_echo "error" "${func_name}" "Please input time zone info."
        return ${ERR_MOD_TIME_ZONE_PARA_ERR}
    fi
    
    #判断时区文件是否存在，如果不存在，报错，不进行修改
    if [ ! -f "${time_zone_dir}${time_zone_file}" ];then
        log_echo "error" "${func_name}" "The time zone file ${time_zone_dir}${time_zone_file} inexistent,please select a SUSE10 support time zone info."
        return ${ERR_MOD_TIME_ZONE_FILE_FAIL}
    fi
    
	log_echo "info" "${func_name}" "TimeZone will change to $time_zone_file."
	
	#备份clock文件；
    mv /etc/sysconfig/clock /etc/sysconfig/clock.bak
    while read LINE
    do 
		ParamCheck=`echo $LINE|grep -v "#"|awk -F= '{print $1}'`
		if [ "-$ParamCheck" = "-TIMEZONE" -o "-$ParamCheck" = "-DEFAULT_TIMEZONE" -o "-$ParamCheck" = "-ZONE" ];then
			echo "$ParamCheck=\"${time_zone_file}\"" >> /etc/sysconfig/clock
		else
			echo $LINE >> /etc/sysconfig/clock
		fi
	done</etc/sysconfig/clock.bak
	log_echo "info" "${func_name}" "modify /etc/sysconfig/clock file successfully."       
	mv /etc/localtime /etc/localtime.bak
	cp /usr/share/zoneinfo/$time_zone_file /etc/localtime
	log_echo "info" "${func_name}" "the /etc/localtime file replaced by this file /usr/share/zoneinfo/${time_zone_file} successfull."
    log_echo "info" "${func_name}" "Modify time zone to ${time_zone_file} successfully."
    return ${SUCC}
}
#########################################################################################
#   Name:           modify_host_name
#   Description:    修改机器名
#	input
#  		1. 机器名       
#   Return:  
#		SUCC                              修改机器名成功
#       ERR_MOD_HOST_NAME_NOT_LINUX       不是Linux操作系统
#       ERR_MOD_HOST_NAME_NOT_ROOT        不是root用户
#       ERR_MOD_HOST_NAME_PARA_ERR        参数不正确，要求输入一个参数   
#       ERR_MOD_HOST_NAME_HOSTTNAME_ERR   /etc/HOSTNAME  文件不存在
#       ERR_MOD_HOST_NAME_HOSTS_ERR       /etc/hosts  文件不存在
#       ERR_MOD_HOST_NAME_HOSTTNAME_MODERR   修改/etc/HOSTNAME  文件失败
#       ERR_MOD_HOST_NAME_HOSTS_MODERR       修改/etc/hosts  文件失败
#########################################################################################
function modify_host_name
{
	typeset hostname="/etc/HOSTNAME"
	typeset hosts="/etc/hosts"
	typeset func_name="modify_host_name"
	typeset new_host_name=$1
	typeset old_host_name=`hostname`
	#校验是否是linux系统
	if [ "X${OS_TYPE}" != "Xlinux" ];then
        log_echo "error" "${func_name}" "${func_name} current can't support ${OS_TYPE}."
        return ${ERR_MOD_HOST_NAME_NOT_LINUX}
    fi
    
    #校验是否是root用户
    isRoot
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Modify host name must use root user."
        return ${ERR_MOD_HOST_NAME_NOT_ROOT}
    fi
    
    if [ $# -ne 1 ];then
        log_echo "error" "${func_name}" "Please input host name. $#"
        return ${ERR_MOD_HOST_NAME_PARA_ERR}
    fi
    
    if [ "X${LINUX_TYPE}" = "Xredhat" ];then
        modify_redhat_host_name "${new_host_name}"
        return $?
    fi
    
    #判断/etc/HOSTNAME文件是否存在，如果不存在，报错，不进行修改
    if [ ! -f "${hostname}" ];then
        log_echo "error" "${func_name}" "The file ${hostname} inexistent."
        return ${ERR_MOD_HOST_NAME_HOSTTNAME_ERR}
    fi
    #判断/etc/hosts文件是否存在，如果不存在，报错，不进行修改
    if [ ! -f "${hosts}" ];then
        log_echo "error" "${func_name}" "The file ${hosts} inexistent."
        return ${ERR_MOD_HOST_NAME_HOSTS_ERR}
    fi
	
	#备份hostName文件；
    mv ${hostname} /etc/HOSTNAME.bak
    mv ${hosts} /etc/hosts.bak
    log_echo "info" "${func_name}" "backup the file /etc/HOSTNAME to /etc/HOSTNAME.bak and  /etc/hosts to /etc/hosts.bak successfully."
   
	#修改主机名，把旧的主机名修改成新的主机名
	sed "s/${old_host_name}/${new_host_name}/" /etc/HOSTNAME.bak > /etc/HOSTNAME
	if [ $? -ne 0 ];then
		log_echo "error" "${func_name}" "Modify the file /etc/HOSTNAME failed."
		cp /etc/HOSTNAME.bak /etc/HOSTNAME
		return ${ERR_MOD_HOST_NAME_HOSTTNAME_MODERR}
	fi
	sed "s/${old_host_name}/${new_host_name}/" /etc/hosts.bak > /etc/hosts
	if [ $? -ne 0 ];then
		log_echo "error" "${func_name}" "Modify the file /etc/hosts failed."
		cp /etc/hosts.bak /etc/hosts
		return ${ERR_MOD_HOST_NAME_HOSTS_MODERR}
	fi
    log_echo "info" "${func_name}" "Modify host name from ${old_host_name}  to ${new_host_name} successfully."
    return ${SUCC}
}
#########################################################################################
#   Name:           modify_redhat_host_name
#   Description:    modify the redhat os host name
#	input
#  		1. hostname       
#   Return:  
#		SUCC                              修改机器名成功
#       ERR_MOD_HOST_NAME_PARA_ERR        参数不正确，要求输入一个参数   
#       ERR_MOD_HOST_NAME_NETWORK_NOT_EXIST   /etc/sysconfig/network  文件不存在
#       ERR_MOD_HOST_NAME_HOSTS_ERR       /etc/hosts  文件不存在
#       ERR_MOD_HOST_NAME_MOD_NETWORK_FAILED   修改//etc/sysconfig/network  文件失败
#       ERR_MOD_HOST_NAME_HOSTS_MODERR       修改/etc/hosts  文件失败
#########################################################################################
function modify_redhat_host_name
{
    typeset network_file="/etc/sysconfig/network"
    typeset hosts="/etc/hosts"
    typeset func_name="modify_redhat_host_name"
    typeset new_host_name=$1
    typeset old_host_name=`hostname`
	
    
    if [ $# -ne 1 ];then
        log_echo "error" "${func_name}" "Please input host name. $#"
        return ${ERR_MOD_HOST_NAME_PARA_ERR}
    fi
    
    #判断/etc/sysconfig/network文件是否存在，如果不存在，报错，不进行修改
    if [ ! -f "${network_file}" ];then
        log_echo "error" "${func_name}" "The file ${network_file} inexistent."
        return ${ERR_MOD_HOST_NAME_NETWORK_NOT_EXIST}
    fi
    #判断/etc/hosts文件是否存在，如果不存在，报错，不进行修改
    if [ ! -f "${hosts}" ];then
        log_echo "error" "${func_name}" "The file ${hosts} inexistent."
        return ${ERR_MOD_HOST_NAME_HOSTS_ERR}
    fi
	
    #备份hostName文件；
    cp ${network_file} ${network_file}.bak
    cp ${hosts} /etc/hosts.bak
    log_echo "info" "${func_name}" "backup the file ${network_file} to ${network_file}.bak and  /etc/hosts to /etc/hosts.bak successfully."
   
    # modify hostname in /etc/sysconfig/network 
    hostname_num=`cat "${network_file}" | ${GREP} -ic "^hostname"`
    if [ ${hostname_num} -eq 0 ];then
        echo "HOSTNAME=${new_host_name}" >> ${network_file}
    else
        sed "s/HOSTNAME.*=.*/HOSTNAME=${new_host_name}/" ${network_file}.bak > ${network_file}
    fi
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Modify the file /etc/sysconfig/network failed."
	cp ${network_file}.bak ${network_file}
	return ${ERR_MOD_HOST_NAME_MOD_NETWORK_FAILED}
    fi

    # modify hostname in /etc/hosts
    sed "s/${old_host_name}/${new_host_name}/" /etc/hosts.bak > /etc/hosts
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Modify the file /etc/hosts failed."
	cp /etc/hosts.bak /etc/hosts
	return ${ERR_MOD_HOST_NAME_HOSTS_MODERR}
    fi
    
    hostname "${new_host_name}"
    if [ $? -ne 0 ];then
       log_echo "error" "${func_name}" "Modify the hostname failed."
       return ${ERR_MOD_HOST_NAME_FAILED}
    fi
    
    log_echo "info" "${func_name}" "Modify host name from ${old_host_name}  to ${new_host_name} successfully."
    return ${SUCC}
}

#########################################################################################
#   Name:           modify_vcs_cfg_file
#   Description:    1、修改/etc/llthosts文件的主机名信息 
#					2、修改/etc/llttab 文件的主机名信息
#                   3、修改 /etc/VRTSvcs/conf/config/main.cf 文件中的主机名信息
#	input
#  		1. 新机器名 2. 老机器名 3.配置文件
#   Return:  
#		SUCC                              修改成功
#       ERR_MOD_VCS_LLTHOST_FILE_ERR      修改/etc/llthosts  文件失败
#       ERR_MOD_VCS_LLTTAB_FILE_ERR       修改/etc/llttab 文件失败
#       ERR_MOD_VCS_MAIN_FILE_ERR         修改/etc/VRTSvcs/conf/config/main.cf 文件失败
#       ERR_MOD_VCS_NOT_EXISTS            VCS不存在
#########################################################################################
function modify_vcs_cfg_file
{
	typeset func_name="modify_vcs_cfg_file"
	typeset llthosts="/etc/llthosts"
	typeset llttab="/etc/llttab"
	typeset main="/etc/VRTSvcs/conf/config/main.cf"
	typeset old_host_name=$2
	typeset new_host_name=$1
	typeset modify_ip_config_file=$3
	if [ ! -f "${llthosts}" ];then
		log_echo "error" "${func_name}" "The file ${llthosts} inexistent."
		return ${ERR_MOD_VCS_NOT_EXISTS}
	fi
	if [ ! -f "${llttab}" ];then
		log_echo "error" "${func_name}" "The file ${llttab} inexistent."
		return ${ERR_MOD_VCS_NOT_EXISTS}
	fi
	if [ ! -f "${main}" ];then
		log_echo "error" "${func_name}" "The file ${main} inexistent."
		return ${ERR_MOD_VCS_NOT_EXISTS}
	fi
	
    #读取配置文件中对端主机的当前主机名称
	VCSHOSTNAME=`cat ${llthosts}|$AWK '{print $NF}'`
    for nodename in $VCSHOSTNAME 
    do 
        if [ "X${nodename}" != "X${old_host_name}" ];then 
           node2_current_name="${nodename}"
           break
        fi
    done

    #读取配置文件中对端主机的新主机名称
    read_value "${modify_ip_config_file}" "node2_new_name"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "read the node2_new_name value from ${modify_ip_config_file} unsuccessful,so don't need to modify the VCS config file."
        return ${ERR_MOD_VCS_NOT_EXISTS}
    fi
    node2_new_name="${RETURN[0]}"

#1、修改llthosts    
	mv ${llthosts} ${llthosts}.bak
	#备份文件
	log_echo "info" "${func_name}" "backup the file ${llthosts} to ${llthosts}.bak successfully"
	#修改文件中本机的主机名字段
	sed "s/${old_host_name}/${new_host_name}/" ${llthosts}.bak > ${llthosts}.modify
	llthostResult1=$?
	#修改文件中另一个主机的机器名字段
	sed "s/${node2_current_name}/${node2_new_name}/" ${llthosts}.modify > ${llthosts}
	rm -rf ${llthosts}.modify
	llthostResult2=$?
	if [ $llthostResult1 -ne 0 -a $llthostResult2 -ne 0 ];then
	    log_echo "error" "${func_name}" "Modify the file ${llthosts} failed."
	    cp ${llthosts}.bak  ${llthosts}
		return ${ERR_MOD_VCS_LLTHOST_FILE_ERR}
	fi
	log_echo "info" "${func_name}" "Modify the file ${llthosts} successfully"

#2、修改llttab	
	mv ${llttab} ${llttab}.bak
	#备份文件
	log_echo "info" "${func_name}" "backup the file ${llttab} to ${llttab}.bak successfully"
	#修改文件中本机的主机名字段
	sed "s/${old_host_name}/${new_host_name}/" ${llttab}.bak > ${llttab}
	if [ $? -ne 0 ];then
	    log_echo "error" "${func_name}" "Modify the file ${llttab} failed."
	    cp ${llttab}.bak  ${llttab}
	    cp ${llthosts}.bak  ${llthosts}
		return ${ERR_MOD_VCS_LLTTAB_FILE_ERR}
	fi
	log_echo "info" "${func_name}" "Modify the file ${llttab} successfully"

#3、修改main	
	mv ${main} ${main}.bak
	#备份文件
	log_echo "info" "${func_name}" "backup the file ${main} to ${main}.bak successfully"
	#修改文件中本机的主机名字段
	sed "s/${old_host_name}/${new_host_name}/" ${main}.bak > ${main}.modify
	llthostResult1=$?
	#修改文件中另一个主机的机器名字段
	sed "s/${node2_current_name}/${node2_new_name}/" ${main}.modify > ${main}
	rm -rf ${main}.modify
	llthostResult2=$?
	if [ $llthostResult1 -ne 0 -a $llthostResult2 -ne 0 ];then
	    log_echo "error" "${func_name}" "Modify the file ${main} failed."
	    cp ${main}.bak  ${main}
	    cp ${llttab}.bak  ${llttab}
	    cp ${llthosts}.bak  ${llthosts}
		return ${ERR_MOD_VCS_MAIN_FILE_ERR}
	fi
	
	log_echo "info" "${func_name}" "Modify the file ${main} successfully"
	log_echo "info" "${func_name}" "Modify the vcs config file successfully"
	return ${SUCC}	
}
#########################################################################################
#   Name:           modify_oracle_cfg_file
#   Description:    修改oracle HOME 目录下network/admin/listener.ora,tnsnames.ora 两个配置文件的主机名
#	input
#  		1. 机器名       
#   Return:  
#		SUCC                              修改成功
#       ERR_MOD_ORACLE_LISTENER_FILE_ERR  ${ORACLE_HOME}/network/admin/listener.ora  文件不存在
#       ERR_MOD_ORACLE_TNSNSMES_FILE_ERR       ${ORACLE_HOME}/network/admin/tnsnames.ora 文件不存在
#       ERR_MOD_ORACLE_NOT_EXISTS         oracle不存在
#       ERR_MOD_ORACLE_MODIFY_LISTENER_ERROR       修改 ${ORACLE_HOME}/network/admin/listener.ora   文件失败
#       ERR_MOD_ORACLE_MODIFY_TNSNSMES_ERROR       修改 ${ORACLE_HOME}/network/admin/tnsnames.ora   文件失败
#########################################################################################
function modify_oracle_cfg_file
{
	typeset func_name="modify_oracle_cfg_file"
	#如果是双机，则不进行修改
	if [ -f "/etc/llthosts" ];then
		log_echo "info" "${func_name}" "This host have been installed vcs,so don't need to modify the oracle config file."
		return ${ERR_MOD_ORACLE_VCS}
	fi
	typeset old_host_name=$2
	typeset new_host_name=$1
	oracle_name="${modify_host_ip_oracle_name:=oracle}"
	typeset oracle_home=`su - ${oracle_name} -c 'echo ModifyIP:${ORACLE_HOME}:end' |awk -F: '{print $2}' | awk -F: '{print $1}'`
	typeset listener="${oracle_home}/network/admin/listener.ora"
	typeset tnsnames="${oracle_home}/network/admin/tnsnames.ora" 
	#以${ORACLE_HOME}环境变量标识是否安装了oracle,如果安装了，则进行修改
	if [ -d "${oracle_home}/network/admin/" ];then
		if [ ! -f "${listener}" ];then
			log_echo "error" "${func_name}" "The file ${listener}inexistent."
			return ${ERR_MOD_ORACLE_LISTENER_FILE_ERR}
		fi
		#存在则修改tnsnames
		if [ -f "${tnsnames}" ];then
		    #备份文件
	        mv ${tnsnames} ${tnsnames}.bak
	        log_echo "info" "${func_name}" "backup the file ${tnsnames} to ${tnsnames}.bak successfully"
	        
	        #修改文件
	        sed "s/${old_host_name}/${new_host_name}/" ${tnsnames}.bak > ${tnsnames}
	        if [ $? -ne 0 ];then
                log_echo "error" "${func_name}" "Modify the file ${tnsnames} failed."
                cp ${tnsnames}.bak ${tnsnames}
                
   			    return ${ERR_MOD_ORACLE_MODIFY_TNSNSMES_ERROR}
   		    fi
	        log_echo "info" "${func_name}" "Modify the file ${tnsnames}  successfully"
		else
			log_echo "debug" "${func_name}" "The file ${tnsnames} inexistent."
		fi
		
		mv ${listener} ${listener}.bak
		#备份文件
		log_echo "info" "${func_name}" "backup the file ${listener} to ${listener}.bak successfully"
		
		#修改文件
	    sed "s/${old_host_name}/${new_host_name}/" ${listener}.bak > ${listener}
	    if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Modify the file ${listener} failed."
            cp ${listener}.bak ${listener}
            
            if [ -f "${tnsnames}" ];then
                cp ${tnsnames}.bak ${tnsnames}
            fi
   			return ${ERR_MOD_ORACLE_MODIFY_LISTENER_ERROR}
   		fi
	    log_echo "info" "${func_name}" "Modify the file ${listener}  successfully"
	else
		#没有安装oracle,不需要修改，返回成功；
		log_echo "info" "${func_name}" "oracle DB not install,didn't need to modify."
		return ${ERR_MOD_ORACLE_NOT_EXISTS};
	fi	
    log_echo "info" "${func_name}" "Modify oracle cfg file successfully."
    return ${SUCC}
}
#########################################################################################
#   Name:           is_need_modify_eth_bond
#   Description:    判断是否需要修改绑定
#	input
#  		1. 绑定IP  
#       2. 绑定名称
#       3. 绑定网卡1
#       4. 绑定网卡2
#       5. 绑定子网掩码    
#   Return:  
#		0       绑定与已经存在的同名网卡绑定信息完全一样，不需要重新绑定
#       1       绑定与已经存在的网卡绑定不完全一致，需要重新绑定
#########################################################################################
function is_need_modify_eth_bond
{
    typeset bond_ip=$1
    typeset bond_name=$2
    typeset eth0_name=$3
    typeset eth1_name=$4
    typeset netmask=$5
    typeset func_name="is_need_modify_eth_bond"
    typeset bond_file="/etc/sysconfig/network/ifcfg-${bond_name}"   
    typeset old_bond_ip=""
    typeset old_eth0_name=""
    typeset old_eth1_name=""
    typeset old_netmask=""
    
    #参数个数校验
    if [ $# -ne 5 ];then
        log_echo "warn" "${func_name}" "Please input default bond ip,bond name,eth0 card name,eth1 card name."
        return 1
    fi
    
    #判断网卡绑定文件是否存在，如果不存在直接返回1，需要修改
    if [ ! -f ${bond_file} ];then
       return 1
    fi
    
    #获取旧的绑定IP
    read_value "${bond_file}" "IPADDR"
    if [ $? -ne 0 ] ;then
        log_echo "warn" "${func_name}" "Read bond ${bond_name} current ip unsuccessful."
        return 1
    fi
    old_bond_ip="${RETURN[0]}"    
    #去掉前后的单引号
    trim_quotation_mark "${old_bond_ip}"
    old_bond_ip="${RETURN[0]}"
    
    #判断旧的绑定IP与当前绑定的IP是否相同，如果不同直接返回，需要修改绑定
    if [ "X${old_bond_ip}" != "X${bond_ip}" ];then
        return 1
    fi
    
    #获取绑定的第一块网卡名称
    read_value "${bond_file}" "BONDING_SLAVE0"
    if [ $? -ne 0 ] ;then
        log_echo "warn" "${func_name}" "Read bond ${bond_name}'s BONDING_SLAVE0 unsuccessful."
        return 1
    fi
    old_eth0_name="${RETURN[0]}"    
    #去掉前后的单引号
    trim_quotation_mark "${old_eth0_name}"
    old_eth0_name="${RETURN[0]}"
    
    #判断绑定的第一块网卡是否相同，如果不同直接返回需要修改绑定
    if [ "X${old_eth0_name}" != "X${eth0_name}" ];then
        return 1
    fi
    
    #获取绑定的第二块网卡名称
    read_value "${bond_file}" "BONDING_SLAVE1"
    if [ $? -ne 0 ] ;then
        log_echo "warn" "${func_name}" "Read bond ${bond_name}'s BONDING_SLAVE1 unsuccessful."
        return 1
    fi
    old_eth1_name="${RETURN[0]}"    
    #去掉前后的单引号
    trim_quotation_mark "${old_eth1_name}"
    old_eth1_name="${RETURN[0]}"
    
    #判断绑定的第二块网卡是否相同，如果不同直接返回需要修改绑定
    if [ "X${old_eth1_name}" != "X${eth1_name}" ];then
        return 1
    fi
    
    #获取绑定的子网掩码
    read_value "${bond_file}" "NETMASK"
    if [ $? -ne 0 ] ;then
        log_echo "warn" "${func_name}" "Read bond ${bond_name}'s NETMASK unsuccessful."
        return 1
    fi
    old_netmask="${RETURN[0]}"    
    #去掉前后的单引号
    trim_quotation_mark "${old_netmask}"
    old_netmask="${RETURN[0]}"
    
    #判断绑定的子网掩码是否相同，如果不同直接返回需要修改绑定
    if [ "X${old_netmask}" != "X${netmask}" ];then
        return 1
    fi
    
    #如果绑定的名称、IP、网卡1、网卡2、子网掩码都相同，则不需要重新绑定
    return 0
}

#########################################################################################
#   Name:           modify_network_manager
#   Description:    修改/etc/sysconfig/network/config文件中NETWORKMANAGER值为no
#	input
#  		无
#   Return:  
#		无
#########################################################################################
function modify_network_manager
{
	typeset network_config_file="/etc/sysconfig/network/config"
	typeset network_manager_key="NETWORKMANAGER"
	typeset func_name="modify_network_manager"
	typeset network_manager_value="no"
	
	if [ $# -ge 1 ];then
	    network_manager_value=$1
	fi
		
    update_inc_file "${network_config_file}" "${network_manager_key}" "${network_manager_value}"	
    if [ $? -ne 0 ];then
        log_echo "warn" "${func_name}" "Modify ${network_config_file} ${network_manager_key} vaule to ${network_manager_value} unsuccessful." 
    else
        log_echo "info" "${func_name}" "Modify ${network_config_file} ${network_manager_key} vaule to ${network_manager_value} successful."         
    fi
    
    return 0
}

#log_echo 日志输出函数,通过$1调用不同的实现
#End,返回的字符串用于结束脚本的运行
#Error,返回的字符串用于结束脚本的运行,并且标记为失败
#Echo,返回的字符串用于显示脚本执行的细节
#Rate,返回的数字字符串用于显示脚本执行的进度信息
#Log,返回的字符串作为脚本的日志信息输出
function log_core
{
    #set -x
    typeset func_name="log_core"
    typeset mode="$1"
    typeset module_name="$2"
	
    if [ $# -ge 2 ];then
        shift 2
    fi
    typeset msg="$@"
    case ${mode} in
    RATE|rate|Rate)
        message_rate ${module_name} ${msg}
    ;;
    ECHO|echo|Echo)
        message_echo ${module_name} ${msg}
    ;;
    #END|end|End)
    #    message_end ${mes}
    #;;
    ERR|err|Err|ERROR|error|Error)
        message_err ${module_name} ${msg}
    ;;
    INFO|info|Info|Log|LOG|log)
        message_info ${module_name} ${msg}
    ;;
    WARN|warn|Warn)
        message_warn ${module_name} ${msg}
    ;;
    DEBUG|Debug|debug)
        message_debug ${module_name} ${msg}
    ;;
    FILE|File|file)
        message_file ${module_name} ${msg}
    ;;
    MODIFYIPEND|modifyipend|ModifyIpEnd)
        message_modify_ip_end ${module_name} ${msg}
    ;;
	MIGRATE_SERVICE|migrate_service|Migrate_service|Migrate_Service)
        message_migrate_service ${module_name} ${msg}
    ;;
    color|Color|COLOR)
        message_color ${module_name} ${msg}
    ;;
    *)
        echo "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    ;;
    esac
    if [ $? -ne 0 ];then
        return 1
    fi
    return 0
}

#C08,该接口可以打印指定颜色的行日志，供html显示，但日志没有自动添加日期时间信息
#如果需要打印带有日期时间信息的日志，使用 log_echo_with_line_color 接口
#调用方式：
#1、关键字会被着色 log_echo "color"  "brown"  "asdasdf error warn failed"
#2、关键字不会被着色 log_echo_no_color_up "color"  "brown"  "asdasdf error warn failed"
function message_color
{
    IDEPLOY_LOG_LINE_COLOR=$1
    if [ $# -ne 0 ];then
        shift
    fi
    typeset msg=${IDEPLOY_LOG_PREFIX}`color_up_message $@`${IDEPLOY_LOG_SUFFIX}
    echo ${msg}
}

function message_file
{
    typeset func_name="message_file"
    typeset cur_dt="0000-00-00 00:00:00"
    typeset get_dt="date '+%y-%m-%d %H:%M:%S'"
    if [ "X${DATE_PATTERN}" != "X" ];then
        get_dt="date '${DATE_PATTERN} %H:%M:%S'" 
    fi
    typeset tag="iDeploy:File:"
    typeset modul="$1"
    if [ $# -ne 0 ];then
        shift
    fi
    typeset mes="$@"
    cur_dt=`eval ${get_dt}`
    echo "${tag}[FILE] [${cur_dt} ${modul}] ${mes} [/FILE]"
    #echo

    return 0
}

#当IDEPLOY_LOG_LINE_COLOR不为空时，进行着色
#当前该方法用于级别日志的着色
function color_up_message
{
    #set -x
    typeset msg=$@
    typeset colored_msg=""
    if [ "X${IDEPLOY_LOG_LINE_COLOR}" != "X" ];then
        #echo "[ideploy_lt]font color='green'[ideploy_gt]tang yan is a stupid boy error[ideploy_lt]/font[ideploy_gt]"
        colored_msg=${IDEPLOY_LINE_COLOR_LT}'font color='${IDEPLOY_LOG_LINE_COLOR}${IDEPLOY_LINE_COLOR_GT}${msg}${IDEPLOY_LINE_COLOR_LT}'/font'${IDEPLOY_LINE_COLOR_GT}
    else
        colored_msg=${msg}
    fi
    
    echo ${colored_msg}
}

function message_debug
{
    #set -x
    typeset func_name="message_debug"
    typeset cur_dt="0000-00-00 00:00:00"
    typeset get_dt="date '+%y-%m-%d %H:%M:%S'"
	if [ "X${DATE_PATTERN}" != "X" ];then
        get_dt="date '${DATE_PATTERN} %H:%M:%S'" 
    fi
    typeset modul="$1"
    if [ $# -ne 0 ];then
        shift
    fi
    typeset mes="$@"
    cur_dt=`eval ${get_dt}`
    #echo "[TIME]  ${cur_dt}"
    #echo "[FUNC]  ${modul}"
    echo "[DEBUG][${cur_dt} ${modul}] ${IDEPLOY_LOG_PREFIX}`color_up_message ${mes}`${IDEPLOY_LOG_SUFFIX} [/DEBUG]"
    #echo
    return 0
}

function message_info
{
    #set -x
    #[INFO][2007-11-15 15:00:00 initiate] Deploy the package START,please wait...[/INFO]
    typeset func_name="message_info"
    typeset cur_dt="0000-00-00 00:00:00"
    typeset get_dt="date '+%y-%m-%d %H:%M:%S'"
	if [ "X${DATE_PATTERN}" != "X" ];then
        get_dt="date '${DATE_PATTERN} %H:%M:%S'" 
    fi
    typeset modul="$1"
    if [ $# -ne 0 ];then
        shift
    fi
    typeset mes="$@"
    cur_dt=`eval ${get_dt}`
    #echo "[TIME] ${cur_dt}"
    #echo "[FUNC] ${modul}"
    echo "[INFO] [${cur_dt} ${modul}] ${IDEPLOY_LOG_PREFIX}`color_up_message ${mes}`${IDEPLOY_LOG_SUFFIX} [/INFO]"
    #echo
    return 0
}

function message_err
{
    #set -x
    typeset func_name="message_err"
    typeset cur_dt="0000-00-00 00:00:00"
    typeset get_dt="date '+%y-%m-%d %H:%M:%S'"
	if [ "X${DATE_PATTERN}" != "X" ];then
        get_dt="date '${DATE_PATTERN} %H:%M:%S'" 
    fi
    typeset modul="$1"
    if [ $# -ne 0 ];then
        shift
    fi
    typeset mes="$@"
    cur_dt=`eval ${get_dt}`
    #echo "[TIME]  ${cur_dt}"
    #echo "[FUNC]  ${modul}"
    echo "[ERROR][${cur_dt} ${modul}] ${IDEPLOY_LOG_PREFIX}`color_up_message ${mes}`${IDEPLOY_LOG_SUFFIX} [/ERROR]"
    #echo
    return 0
}

function message_warn
{
    #set -x
    typeset func_name="message_warn"
    typeset cur_dt="0000-00-00 00:00:00"
    typeset get_dt="date '+%y-%m-%d %H:%M:%S'"
    if [ "X${DATE_PATTERN}" != "X" ];then
        get_dt="date '${DATE_PATTERN} %H:%M:%S'" 
    fi
    typeset modul="$1"
    if [ $# -ne 0 ];then
        shift
    fi
    typeset mes="$@"
    cur_dt=`eval ${get_dt}`
    #echo "[TIME] ${cur_dt}"
    #echo "[FUNC] ${modul}"
    echo "iDeploy:Warning:[WARN] [${cur_dt} ${modul}] ${IDEPLOY_LOG_PREFIX}`color_up_message ${mes}`${IDEPLOY_LOG_SUFFIX} [/WARN]"
    #echo 
    return 0
}

#########################################################################################
#message_rate
#上报进度
#参数1,在指定duration内最终需要达到的最大进度值
#参数2,达到指定最大进度的持续时间,单位秒,缺省为0,即立即刷新
#########################################################################################
function message_rate
{
    #set -x
    typeset func_name="message_rate"
    if [ $# -eq 1 ];then
        typeset rate="$1"
        typeset duration="0"
    elif [ $# -eq 2 ];then
        typeset rate="$1"
        typeset duration="$2"
    else
        return 1
    fi
    #对信息进行封装
    echo
    echo "iDeploy:Rate:${rate}:${duration}"
    return 0
}

function message_echo
{
    #set -x
    typeset func_name="message_echo"
    typeset cur_echo="$@"
    #对信息进行封装
    echo "iDeploy:Echo:${cur_echo}"
    return 0
}

function message_end
{
    #set -x
    typeset func_name="message_end"
    typeset end="$@"
    #对信息进行封装
    echo "iDeploy:End:${end}"
    return 0
}

function message_modify_ip_end
{
   typeset modify_ip_end="$@"
   
   #对信息进行封装
   echo "iDeploy:ModifyIpEnd:${modify_ip_end}"
   
   return 0
}

function message_migrate_service
{
    #set -x
    typeset func_name="message_migrate_service"
	if [ $# -eq 4 ];then
       typeset key_msg="$1"
	   typeset succ_msg="$2"
	   typeset fail_msg="$3"
	   typeset unfinished_msg="$4"
    else
        return 1
    fi
    
    #对信息进行封装
    echo "iDeploy:migrate_service:${key_msg}:${succ_msg}:${fail_msg}:${unfinished_msg}"
    return 0
}

##########################################################
#名称:make_dir
#功能:创建目录
#参数:1.dir_name(带相对路径或者绝对路径)
##########################################################
function make_dir
{
    #set -x
    typeset func_name="make_dir"
    if [ $# -ne 1 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}!"
        return 1
    fi
    typeset dir_name=$1
    if [ ! -d ${dir_name} ];then
        #创建目录
        mkdir -p ${dir_name}
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Make directory \"${dir_name}\" ${FAILD}!"
            return 1
        fi
    fi
    return 0
}

#####################################################
#名称:transfer_file_via_manually
#功能:从本地的软件包仓库目录上获取指定的文件
#参数:1.depository路径
#     2.destination路径
#     3.文件列表，文件含有相对路径
#####################################################
function transfer_file_via_manually
{
    #set -x
    if [ $# -lt 2 ];then
        log_echo "error" "$0" "${PARAMETER_UNMATCHED}!"
        return 1
    fi
    
    typeset src_depository=$1
    typeset dest_path=$2
    shift 2
    typeset packages=$@
            
    typeset src_package=""
    typeset dest_package=""
    typeset dest_dir=""
    typeset file_name=""
    #echo "=$@================================================="
    typeset org_ifs=$IFS
    IFS=,
    for package in ${packages}
    do
        src_package="${src_depository}/${package}"
        dest_package="${dest_path}/${package}"
        dest_dir=`dirname ${dest_package}`
        
        #创建目录
        mkdir -p ${dest_dir}
        
        #源文件是否存在
        if [ -f ${src_package} ];then
            log_echo "info" "$0" "Start copy package from \"${src_package}\" to \"${dest_package}\", please wait..."
            cp ${src_package} ${dest_package}
            if [ $? -ne 0 ];then
                log_echo "error" "$0" "Copy file from \"${src_package}\" to \"${dest_package}\" failed!"
                return 1
            fi
        else
            log_echo "error" "$0" "The source file \"${src_package}\" is inexistence!"
            return 1
        fi
    done
    IFS=${org_ifs}
    #echo "--------------------------------------------------"
}
##########################################################
#名称:transfer_file_via_ftp
#功能:从ftp_server上获取指定的文件
#参数:1.ftp_server_ip
#     2.ftp_user
#     3.ftp_passwd
#     4.ftp_mode[传输模式]
#     5.local_path[本地路径]
#     6.server_path[server端路径]
#     7.trans_port[ftp端口]
#     8.trans_type[传输类型,取值为get和put](如果该参数的值不是put，则使用默认的get)
#     9.file_names[文件名称](需要获取的文件名称,多值使用,分隔)
##########################################################
function transfer_file_via_ftp
{
    #set -x
    typeset func_name="transfer_file_via_ftp"
    if [ $# -lt 4 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}!"
        return 1
    fi
    typeset ftp_server_ip=$1
    typeset ftp_user=$2
    typeset ftp_passwd=$3
    typeset ftp_mode=$4    
    typeset local_path=$5
    typeset server_path=$6
    typeset trans_port=$7
    typeset trans_type=$8
    typeset file_size_compare=$9
    shift 9
    typeset file_names=$@
    
    if [ "X${file_names}" = "X" ];then
        log_echo "warn" "${func_name}" "No files need to transport!"
        return 0
    fi
    #校验server的ip
#Begin:为避免现网安全加固后的主机无法使用ping命令而错误返回ip无效，兹将以下校验代码注释.2008-1-2     
#    validate_ip ${ftp_server_ip}
#    if [ $? -ne 0 ];then
#        log_echo "log" "${func_name}" "The specified server ip is invalidation!"
#        return 1
#    fi
#End
    
#Begin:处理文件名称中含有空格，以及避免hp平台上awk无法处理3000以上字符串的问题.2008-1-2    
#    typeset file_numbers=`echo ${file_names}|$AWK -F, '{print NF}'`
#    typeset get_files=""
#    file_names=`echo ${file_names}|$SED 's/,/","/g'`
#    file_names=`echo '"'${file_names}'"'`
#    get_files=`echo "${file_names}"|$AWK -F, '{split($0,f,",");for(i=1;i<=NF;i++) print "get",f[i]}'`
#New Process:    
    typeset org_ifs=$IFS
    typeset -i file_numbers=0
    typeset get_files=""
    #file_names=`echo ${file_names}|$SED 's/,/","/g'`
    #file_names=`echo '"'${file_names}'"'`
    
    while [ -f ${IDEPLOY_TEMP} ]
    do
        date_num=`date '+%H%M%S'`
        IDEPLOY_TEMP="./.ideploy_temp_${date_num}"
        sleep 1
    done
    touch "${IDEPLOY_TEMP}"

    #==>>开始处理包名列表
    IFS=,
    #数组下标
    typeset file_index=0
    
    #文件目录
    typeset file_relative_path=""
    #文件名称
    typeset file_name=""
    typeset old_path=`pwd`
    cd ${local_path}
    
    #记录当前路径
    typeset cur_path=`pwd`
    
    if [ "X${trans_type}" != "Xput" -a "X${trans_type}" != "Xget" ];then
        trans_type="get"
    fi
    
    #判断server端的路径是否是绝对路径
    typeset absolute_path="true"
    if [ "X`echo ${server_path}|$AWK '{print substr($0,0,1)}'`" = "X/" ];then
        absolute_path="true"
    else
        absolute_path="false"
    fi
    
    #如果是相对路径，则只切换一次，认为所有的业务包都在该路径下
    if [ "X${absolute_path}" = "Xfalse" ];then
        echo "cd "'"'"${server_path}"'"' >> ${IDEPLOY_TEMP}
    fi
    
    for f in ${file_names}
    do
        file_name=`echo ${f}|$AWK -F/ '{print $NF}'`
        file_relative_path=`echo ${f}|$AWK -F/ '{print substr($0,0,(length($0)-length($NF)))}'`
        
        #创建目录
        if [ "X${file_relative_path}" != "X" ];then
            mkdir -p ${file_relative_path}
        fi
        
        if [ "X${absolute_path}" = "Xtrue" ];then
            #如果server_path必须是绝对路径，则每次都切换
            echo "cd "'"'"${server_path}/${file_relative_path}"'"' >> ${IDEPLOY_TEMP}
        fi
        echo "dir" '"'"${file_name}"'"'>> ${IDEPLOY_TEMP}
        echo "lcd" >> ${IDEPLOY_TEMP}
        echo "lcd "'"'"${cur_path}/${file_relative_path}"'"' >> ${IDEPLOY_TEMP}
        echo "${trans_type}" '"'"${file_name}"'"' >> ${IDEPLOY_TEMP}
        ((file_numbers+=1))
    done
    
    IFS=${org_ifs}
    #==>>处理包名结束
    
#    获取临时文件内容，并清空文件
    get_files=`cat ${IDEPLOY_TEMP}`
#    echo "==========================="
#    调试代码使用
#    cat "${IDEPLOY_TEMP}"
#    echo "==========================="
    rm ${IDEPLOY_TEMP}
  
#End
    
    #创建temp文件，保存ftp执行过程中产生的信息
    while [ -f ${IDEPLOY_TEMP} ]
    do
        date_num=`date '+%H%M%S'`
        IDEPLOY_TEMP="./.ideploy_temp_${date_num}"
        sleep 1
    done
    touch "${IDEPLOY_TEMP}"
    
    typeset OS=`uname`
    #在Linux平台关闭IPv4    
    #如果是ftp是使用kerberos认证的，ftp连接需要增加-u选项，不要增加epsv4指令
    if [ `which ftp | grep -ci "/kerberos/"` -gt 0  ];then
        ftp -inuv >${IDEPLOY_TEMP} 2>&1 <<CMD
        open ${ftp_server_ip} ${trans_port}
        user ${ftp_user} "${ftp_passwd}"
        ${ftp_mode}        
        ${get_files}
        bye
CMD
    #suse机器需要增加epsv4指令
    elif  [ "X${OS}" = "XLinux" -a `cat /proc/version 2>/dev/null | grep -ci "SUSE"` -gt 0 ];then
        ftp -inv >${IDEPLOY_TEMP} 2>&1 <<CMD
        open ${ftp_server_ip} ${trans_port}
        user ${ftp_user} "${ftp_passwd}"
        epsv4
        ${ftp_mode}      
        ${get_files}
        bye
CMD
    else
        ftp -inv >${IDEPLOY_TEMP} 2>&1 <<CMD
        open ${ftp_server_ip} ${trans_port}
        user ${ftp_user} "${ftp_passwd}"
        ${ftp_mode}       
        ${get_files}
        bye
CMD
    fi
        
    cat ${IDEPLOY_TEMP}
    #0.检查是否无连接
    typeset err_timeout1=`cat ${IDEPLOY_TEMP}|$AWK -F: '{ if ( $1 == "ftp" && $2 == " connect" ) print $3 }'|$GREP "timed out"|wc -l`
    typeset err_timeout2=`cat ${IDEPLOY_TEMP}|$AWK -F: '{ if ( $1 == "ftp" && $2 == " connect" ) print $3 }'|$GREP "timeout"|wc -l`
    if [ ${err_timeout1} -ge 1 -o ${err_timeout2} -ge 1 ];then
        log_echo "err" "${func_name}" "Connect time out,file(s) transport ${FAILED}!"
        rm ${IDEPLOY_TEMP}
        return 1
    fi
    
    typeset err_notconnected=`cat ${IDEPLOY_TEMP}|$AWK '{ if ( $1 == "Not" && $2 == "connected." ) print $0 }'|wc -l`
    if [ ${err_notconnected} -ge 1 ];then
        log_echo "err" "${func_name}" "Not connected,file(s) transport ${FAILED}!"
        rm ${IDEPLOY_TEMP}
        return 1
    fi
    
    typeset no_space=`cat ${IDEPLOY_TEMP}|$GREP -i "no space left"|wc -l`
    if [ ${no_space} -ge 1 ];then
        log_echo "error" "${func_name}" "No space left,file(s) transport ${FAILED}!"
        rm ${IDEPLOY_TEMP}
        return 1
    fi
    
    #1.检查ftp传输过程中的错误码500,553,530,550,500,501
    typeset err_code=`cat ${IDEPLOY_TEMP}|$AWK '{ if ( $2 != "bytes" || $3 != "received" && $3 != "sent" || $4 != "in" ) print $1}'`
    typeset err=""
    typeset ret="0"
    for err in ${err_code}
    do
        case ${err} in
        553|530|550|555|500|501)
            ret="1"
        ;;
#Begin 2007-06-13 
#        )
#            log_echo "log" "${func_name}" "There has syntax error with error code \"${err}\"!"
#        ;;
#End 2007-06-13 
        *)
        ;;
        esac
        if [ "X${ret}" = "X1" ];then
            log_echo "err" "${func_name}" "Get files via ftp ${FAILED} with error code \"${err}\"!"
            if [ "X${err}" = "X550" ];then
                log_echo "warn" "${func_name}" "Suggestion,please make sure that all the packages which need to tranfer is on the ftp server path \"${server_path}\".Otherwise,please check whether there has enough space left on the host path \"`pwd`/${local_path}\"!"
            fi
            rm ${IDEPLOY_TEMP}
            return 1
        fi
    done
        
        
    #3.检查关键字
    typeset err_key=`cat ${IDEPLOY_TEMP}`
    for err in ${err_key}
    do
        case ${err} in
        ?Invalid|invalid|denied|Unable)
        ret="1"
        ;;
        *)
        ;;
        esac
        if [ "X${ret}" = "X1" ];then
            log_echo "error" "${func_name}" "Get files via ftp ${FAILED} with error key word \"${err}\"!"
            rm ${IDEPLOY_TEMP}
            return 1
        fi
    done
    #比较服务器端和客户端的文件大小
    #获取服务器端的文件大小
    typeset line_num_list=`cat ${IDEPLOY_TEMP} |$GREP -n -E "150 File status okay|150 Accepted data connection|150 Connecting to port|150 Opening data connection|150 Opening ASCII mode data connection" | $AWK -F: '{print $1+1}'`
    typeset remote_file_size_index=0
    typeset remote_size=""
    
    if [ "X${line_num_list}" != "X" ];then      
      for line_num in ${line_num_list}
      do
        typeset current_file_size=`cat ${IDEPLOY_TEMP} | sed -n "${line_num}p" | $AWK '{if ( NF > 6 ) print $5}'`
        if [ "X${current_file_size}" = "X" ];then
           continue
        fi
        remote_size[${remote_file_size_index}]="${current_file_size}"
        ((remote_file_size_index+=1))
      done
    fi
    #本地文件大小
    org_ifs=$IFS
    IFS=","
    typeset local_size=""
    typeset local_file_size_index=0
    for name in ${file_names}
    do
     typeset current_file_size=""
     if [ -f "${name}" ];then
       current_file_size=`ls -l "${name}" |$AWK '{print $5}'`          
     else
       current_file_size="0"
     fi
    local_size[${local_file_size_index}]="${current_file_size}"
    ((local_file_size_index+=1))
    done
    IFS=${org_ifs}
    
    #逐个比较文件的大小
    if [ "X${local_file_size_index}" = "X${file_numbers}" -a "X${file_numbers}" = "X${remote_file_size_index}" ];then    
       typeset i=0
       typeset is_take_error_log="false"
       typeset is_matche_size_error="false"
       if [ "X${file_size_compare}" = "Xerror" ] ;then
           is_take_error_log="true"    
       fi 
       while [[ $i -lt ${local_file_size_index} ]]
       do
          typeset compare_remote=${remote_size[i]}
          typeset compare_local=${local_size[i]}
          typeset file_name=`echo ${file_names}|$AWK -F, '{print $1}'`
          file_names=`echo ${file_names}|$AWK -F, '{print substr($0,length($1)+2,length($0))}'`
          if [ "X${compare_remote}" = "X${compare_local}" ];then
                log_echo "info" "${func_name}" "The size of file \"${file_name}\" on local is \"${compare_local}\"!"
          else
                #大小不一致，说明传输发生错误
                if [ "X${is_take_error_log}" = "Xtrue" ];then
                   is_matche_size_error="true"
                   log_echo "error" "${func_name}" "Get the size of file \"${file_name}\" on server is \"${compare_remote}\", and on local is \"${compare_local}\"!Please check it manually!"
                else                
                   log_echo "warn" "${func_name}" "Get the size of file \"${file_name}\" on server is \"${compare_remote}\", and on local is \"${compare_local}\"!Please check it manually!"
                fi   
          fi
          ((i+=1))
       done
       if [ "X${is_matche_size_error}" = "Xtrue" ];then
           log_echo "error" "${func_name}" "The sizes of file on server and on current host are unequal. The error logs above are detail information.Please check it manually."
           rm ${IDEPLOY_TEMP}
           return 1
       fi  
    else
       log_echo "debug" "${func_name}" "File size number on local is \"${local_file_size_index}\",on remote is \"${remote_file_size_index}\".Please check it manually."
    fi 
    rm ${IDEPLOY_TEMP}    
    cd ${old_path}
    return 0
}

function uncompress_pkg
{
    #set -x
    typeset func_name="uncompress_pkg"
    if [ $# -ne 1 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    typeset z_tar=$1
    typeset path=""
    typeset name=""
    #若参数含有路径,将路径和tar包拆分
    if [ `echo "${z_tar}" |$GREP -c "/" ` -gt 0 ];then
        path=`dirname ${z_tar}`
        name=`basename ${z_tar}`
    else
        path="./"
        name=${z_tar}
    fi   
    #检查是否是Z文件
    if [ `file ${z_tar} | $GREP compressed |wc -l ` -gt 0 ];then
        cd ${path}
        uncompress ${name}
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Uncompress the package \"${name}\" ${FAILED}!"
            return 1
        fi
    fi
    return 0 
    
}

function untar_pkg
{
    #set -x
    typeset func_name="untar_pkg"
    if [ $# -ne 1 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    typeset tar_pkg=$1
    typeset path=""
    typeset name=""
    
    #记录当前路径，在tar任务完成后返回
    typeset origin_path=`pwd`
    
    #若参数含有路径,将路径和tar包拆分
    if [ `echo "${tar_pkg}" |$GREP -c "/" ` -gt 0 ];then
        path=`dirname ${tar_pkg}`
        name=`basename ${tar_pkg}`
    else
        path="./"
        name=${tar_pkg}
    fi
    
    #检查是否是tar文件
    if [ `file ${tar_pkg} | $GREP tar |wc -l ` -gt 0 ];then
        cd ${path}
        tar xvf ${name} > ${IDEPLOY_NULL} 2>&1
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Untar the package \"${name}\" ${FAILED}!"
            cat ${IDEPLOY_NULL}
            cd ${origin_path}
            return 1
        fi
    fi
    cd ${origin_path}
    return 0
}
##########################################################
#名称:validate_ip
#功能:检验ip的有效性
#参数:1.host_ip
##########################################################
function validate_ip
{
    #set -x
    typeset func_name="validate_ip"
    if [ $# -lt 1 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    typeset host_ip=$1
    typeset timeout="60"
    if [ "X$2" != "X" ];then
         timeout=$2
    fi
    #HP-UX/SunOS/Linux/AIX
    typeset os=`uname`
    typeset cmd=""
    #对给定的ip进行校验
       
    if [ "X${PING}" = "X" ];then
        log_echo "log" "${func_name}" "Can't find the \"ping\" command in the directory ${find_path_dir}!\nValidation the ftp server ip cancelled!"
        return 0
    fi
        
    case ${os} in
    HP-UX)
        cmd="${PING} ${host_ip} -n 3"
    ;;
    SunOS)
        cmd="${PING} ${host_ip}"
    ;;
    AIX)
        cmd="${PING} -c 3 ${host_ip}"
    ;;
    Linux)
        cmd="${PING} -c 3 -w ${timeout} ${host_ip}"
    ;;
    *)
        log_echo "error" "${func_name}" "Unknowable operating system \"${os}\",validate the ip ${FAILED}!"
        return 1
    ;;
    esac
    ${cmd} >${IDEPLOY_NULL}
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "The specified ip \"${host_ip}\" is invalidation!"
        return 1
    fi
    return 0
}

#######################################################################
#name:get_pkg_info()
#func:方法登录ftp服务器的软件包存放目录，遍历软件包信息
#args:1 host_ip   　ftp服务器ip
#args:2 host_port   ftp服务器端口　
#args:3 host_user   ftp用户名
#args:4 host_pwd    ftp用户密码
#args:5 store_path  软件包存放路径
#######################################################################
function get_pkg_info
{
ftp -inv <<EOF
open $1 $2
user $3 "$4"
cd $5
dir
bye
EOF
}


#sftp传输实现包过滤
function pkg_filter_sftp
{
    typeset func_name="pkg_filter_sftp"
    typeset host_ip=$1
    typeset host_port=$2
    typeset host_user=$3
    typeset host_pwd=$4
    typeset pkg_path=$5
    typeset local_path=$6
    typeset old_ifs=$IFS
    shift 6
    typeset pkg_names=$@

    typeset local_size=0
    typeset remote_size=0	
    typeset temp_file=".ideploy_pkg_info_sftp_$$.log"
    typeset temp_file2="${temp_file}2"
    typeset info_list=""
    typeset -i list_num=0
    typeset -i i=1
    typeset -i field_cur=0
    typeset -i field_min=10000
    
    
    #Begin:
    #业务包带路径后，不支持重发包过滤功能
    if [ "X`echo ${pkg_names}|$AWK -F/ '{print $2}'`" != "X" ];then
        log_echo "debug" "${func_name}" "The product pkg names \"${pkg_names}\" contains relative path,return without filter!"
        RETURN[0]=$@
        return 0
    fi
    #End:
    
    #登陆sftp服务器，获取所有文件列表信息
    
    printf "ls -l \"${pkg_path}\"" |sftp -o "UserKnownHostsFile /dev/null" -o "StrictHostKeyChecking no" -o "Port ${host_port}" ${host_user}@${host_ip} 2>&1 1>${temp_file} 
    
    #临时文件不存在
    if [ ! -r ${temp_file} ];then
        log_echo "warn" "${func_name}" "Get ${temp_file} failed!"
        RETURN[0]=${pkg_names}
        return 0
    fi
    
    #将临时文件中的软件包信息和本地的软件包信息进行比较
    RETURN[0]="" 
    IFS=,
    for name in ${pkg_names}
    do
        if [ -f "${local_path}/${name}" ];then
            local_size=`cat "${local_path}/${name}" | wc -c`
        else
            local_size=0
        fi
        #过滤临时文件中列表信息
        cat ${temp_file} | $AWK -F" ${name}" '$NF == "" {print $0}' > ${temp_file2}
        list_num=`cat ${temp_file2}|wc -l`
        #判断获取的记录行数
        if [ ${list_num} -lt 1 ];then
            #小于1说明没有匹配的文件
            log_echo "err" "${func_name}" "Can't find file \"${name}\" on ftp server!"
            rm ${temp_file}  >${IDEPLOY_NULL} 2>&1
            rm ${temp_file2} >${IDEPLOY_NULL} 2>&1
            return 1
        fi
        if [ ${list_num} -gt 1 ];then
            while [ $i -le ${list_num} ]
            do
                field_cur=`cat ${temp_file2}|$SED -n ${i}p|$AWK '{print NF}'`
                if [ ${field_cur} -lt ${field_min} ];then
                    info_list=`cat ${temp_file2}|$SED -n ${i}p`
                    field_min=${field_cur}
                fi
                ((i+=1))
            done
            #list_num、field_cur、field_min初始化为零
            list_num=0
            field_cur=0
            field_min=10000
            i=1
        else
            info_list=`cat ${temp_file2}`
        fi

        is_integer `echo ${info_list}|$AWK '{print $2}'` >${IDEPLOY_NULL} 2>&1
        if [ $? -ne 0 ];then
            #第二个域不是数字，说明是MS-DOS样式，打印第三个域
            remote_size=`echo ${info_list}|$AWK '{ print $3}'`
        else
            remote_size=`echo ${info_list}|$AWK '{ print $5}'`
            is_integer ${remote_size} >${IDEPLOY_NULL} 2>&1
            if [ $? -ne 0 ];then
                remote_size=`echo ${info_list}|$AWK '{print $4}'`
                is_integer ${remote_size} >${IDEPLOY_NULL} 2>&1
                if [ $? -ne 0 ];then
                    remote_size=`echo ${info_list}|$AWK '{print $3}'`
                fi
            fi
        fi

        is_integer ${remote_size} >${IDEPLOY_NULL} 2>&1
        if [ $? -ne 0 ];then
            log_echo "warn" "${func_name}" "Can't get size of file \"${name}\" on sftp server!"
            remote_size=0
        fi
        
        local_size=`echo "${local_size}" |tr -d ' '`
        #处理软件包大小一致,或者获取文件大小失败,继续下一个文件
        if [ ${local_size} -eq ${remote_size} ];then
            log_echo "debug" "${func_name}" "File \"${name}[${local_size}/${remote_size} byte(s)]\" is OK!"
            continue
        fi
           
        log_echo "info" "${func_name}" "Need to transfer file \"${name}[${local_size}/${remote_size} byte(s)]\" to \"`pwd`/${local_path}\"!"
        

        #将文件添加到列表
        if [ "X${RETURN[0]}" = "X" ];then
            RETURN[0]="${name}"
        else
            RETURN[0]=${RETURN[0]}",${name}"
        fi    	
    done
    IFS=${old_ifs}
    #删除temp文件
    rm ${temp_file}  >${IDEPLOY_NULL} 2>&1
    rm ${temp_file2} >${IDEPLOY_NULL} 2>&1
    return 0 
}
#######################################################################
#name:pkg_filter
#func:方法过滤掉已经存在的软件包
#args:1 host_ip   　 ftp服务器ip
#args:2 host_port    ftp服务器端口　
#args:3 host_user    ftp用户名
#args:4 host_pwd     ftp用户密码
#args:5 pkg_path     软件包ftp服务器存放路径
#args:6 store_path   软件包本地存放路径
#args:7 pkg_list     要过滤的软件包列表
#######################################################################
function pkg_filter_ftp
{  
    #set -x
    typeset func_name="pkg_filter"    

    typeset local_size=0
    typeset remote_size=0	
    typeset temp_file=".ideploy_pkg_info_$$.log"
    typeset temp_file2="${temp_file}2"
    typeset info_list=""
    typeset -i list_num=0
    typeset -i i=1
    typeset -i field_cur=0
    typeset -i field_min=10000
    

    
    typeset host_ip=$1
    typeset host_port=$2
    typeset host_user=$3
    typeset host_pwd=$4
    typeset pkg_path=$5
    typeset local_path=$6
    typeset org_ifs=$IFS
    shift 6
    typeset pkg_names=$@
    
    #Begin:
    #业务包带路径后，不支持重发包过滤功能
    if [ "X`echo ${pkg_names}|$AWK -F/ '{print $2}'`" != "X" ];then
        log_echo "debug" "${func_name}" "The product pkg names \"${pkg_names}\" contains relative path,return without filter!"
        RETURN[0]=$@
        return 0
    fi
    #End:
    
    get_pkg_info ${host_ip} ${host_port} ${host_user} "${host_pwd}" "${pkg_path}" > ${temp_file}
    
    #临时文件不存在
    if [ ! -r ${temp_file} ];then
        log_echo "warn" "${func_name}" "Get ${temp_file} failed!"
        RETURN[0]=${pkg_names}
        return 0
    fi
    #将临时文件中的软件包信息和本地的软件包信息进行比较
    TOTAL_FILE_SIZE=0
    RETURN[0]="" 
    IFS=,
    for name in ${pkg_names}
    do
        if [ -f "${local_path}/${name}" ];then
            local_size=`cat "${local_path}/${name}" | wc -c`
        else
            local_size=0
        fi
        #过滤临时文件中列表信息
        cat ${temp_file} | $AWK -F" ${name}" '$NF == "" {print $0}' > ${temp_file2}
        list_num=`cat ${temp_file2}|wc -l`
        #判断获取的记录行数
        if [ ${list_num} -lt 1 ];then
            #小于1说明没有匹配的文件
            log_echo "err" "${func_name}" "Can't find file \"${name}\" on ftp server!"
            rm ${temp_file}  >${IDEPLOY_NULL} 2>&1
            rm ${temp_file2} >${IDEPLOY_NULL} 2>&1
            return 1
        fi
        if [ ${list_num} -gt 1 ];then
            while [ $i -le ${list_num} ]
            do
                field_cur=`cat ${temp_file2}|$SED -n ${i}p|$AWK '{print NF}'`
                if [ ${field_cur} -lt ${field_min} ];then
                    info_list=`cat ${temp_file2}|$SED -n ${i}p`
                    field_min=${field_cur}
                fi
                ((i+=1))
            done
            #list_num、field_cur、field_min初始化为零
            list_num=0
            field_cur=0
            field_min=10000
            i=1
        else
            info_list=`cat ${temp_file2}`
        fi
        #获取文件大小
#            echo "============================"
#            echo ${info_list}|$AWK '{print $5}'
#            echo ${info_list}|$AWK '{print $4}'
#            echo ${info_list}|$AWK '{print $3}'
#            echo "============================"
        is_integer `echo ${info_list}|$AWK '{print $2}'` >${IDEPLOY_NULL} 2>&1
        if [ $? -ne 0 ];then
            #第二个域不是数字，说明是MS-DOS样式，打印第三个域
            remote_size=`echo ${info_list}|$AWK '{ print $3}'`
        else
            remote_size=`echo ${info_list}|$AWK '{ print $5}'`
            is_integer ${remote_size} >${IDEPLOY_NULL} 2>&1
            if [ $? -ne 0 ];then
                remote_size=`echo ${info_list}|$AWK '{print $4}'`
                is_integer ${remote_size} >${IDEPLOY_NULL} 2>&1
                if [ $? -ne 0 ];then
                    remote_size=`echo ${info_list}|$AWK '{print $3}'`
                fi
            fi
        fi

        is_integer ${remote_size} >${IDEPLOY_NULL} 2>&1
        if [ $? -ne 0 ];then
            log_echo "warn" "${func_name}" "Can't get size of file \"${name}\" on ftp server!"
            remote_size=0
        fi
        
        #处理软件包大小一致,或者获取文件大小失败,继续下一个文件
        #aix机器去掉空格
        local_size=`echo "${local_size}" |tr -d ' '`
        if [ ${local_size} -eq ${remote_size} ];then
            log_echo "log" "${func_name}" "File \"${name}[${local_size}/${remote_size} byte(s)]\" is OK!"
            continue
        fi
        log_echo "info" "${func_name}" "Need to transfer file \"${name}[${local_size}/${remote_size} byte(s)]\" to \"`pwd`/${local_path}\"!"
        
        #计算需要传输的包的总大小
        ((TOTAL_FILE_SIZE+=remote_size))

        #将文件添加到列表
        if [ "X${RETURN[0]}" = "X" ];then
            RETURN[0]="${name}"
        else
            RETURN[0]=${RETURN[0]}",${name}"
        fi    	
    done
    IFS=${org_ifs}
    #删除temp文件
    rm ${temp_file}  >${IDEPLOY_NULL} 2>&1
    rm ${temp_file2} >${IDEPLOY_NULL} 2>&1
    return 0   		
}

function ideploy_del
{
    #set -x 
    typeset func_name="ideploy_del"
#    typeset dir=$1
    typeset ftpserver=$1
#    typeset user=`id|$AWK -F\( '{print $2 }'|$AWK -F\) '{print $1}'`
#    typeset home=`cat /etc/passwd|$AWK -F: -v name=${user} '{ if ( $1 == name ) print $6 }'`
    #rm -r ${home}/tmp >${IDEPLOY_NULL} 2>&1
    #将家目录下的三个公共库文件复制到script目录下，然后删除用户家目录下的文件
    #--------------修改copy策略，只是将ideploy.inc文件copy到script目录下---------------------------------------------
    #cp ${CUR_PATH}/ideploy_wrap.sh ${CUR_PATH}/ideploy.inc ${CUR_PATH}/comm_lib ${CUR_PATH}/${dir} >${IDEPLOY_NULL} 2>&1
#    if [ -d ${CUR_PATH}/${dir} ] ;then
#        cp ${CUR_PATH}/ideploy.inc ${CUR_PATH}/${dir} >${IDEPLOY_NULL} 2>&1
#    fi
    #----------------------------------------------------------------------------------------------------------------
    rm ${CUR_PATH}/ideploy_wrap.sh ${CUR_PATH}/ideploy.inc ${CUR_PATH}/comm_lib ${CUR_PATH}/${CONFIG} ${CUR_PATH}/${ftpserver} >${IDEPLOY_NULL} 2>&1
   
    return 0
}

function set_constants
{
    #set -x
    typeset func_name="set_constants"
    typeset datePattern="+%y-%m-%d"
    typeset datePattern_key="ftp_server_date_pattern"
    if [ $# -ne 3 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    CUR_PATH=$1
    PKG_PATH=${CUR_PATH}/$2
    CONFIG=$3
    CONFIG=`echo ${CONFIG}|$AWK -F\. '{ if ( $NF == "ftpserver" || $NF == "FTPSERVER" ) print substr($0,0,(length($0)-length($NF))) }'`
    CONFIG="${CONFIG}properties"

#    SCRIPT_DIR=${PKG_PATH}/script
    CONFIG_DIR=${PKG_PATH}/conf
#    CONFIG=`ls ${CUR_PATH}|$GREP -i ${CONFIG}$`
#    if [ "X${CONFIG}" = "X" ];then
#        log_echo "log" "${func_name}" "Can't find the \"${CONFIG}\"!"
#        return 1
#    fi

#-------------------delete exist constants--------------------------
#    "${SED}" '/^CUR_PATH/d'  "${CUR_PATH}"/ideploy.inc > "${CUR_PATH}"/ideploy.inc.bak    
#    "${SED}" '/^PKG_PATH/d'  "${CUR_PATH}"/ideploy.inc.bak > "${CUR_PATH}"/ideploy.inc
#    "${SED}" '/^CONFIG_DIR/d'  "${CUR_PATH}"/ideploy.inc > "${CUR_PATH}"/ideploy.inc.bak
#    "${SED}" '/^CONFIG/d'  "${CUR_PATH}"/ideploy.inc.bak > "${CUR_PATH}"/ideploy.inc
#    "${SED}" '/^IDEPLOY_CUR_PATH/d'  "${CUR_PATH}"/ideploy.inc > "${CUR_PATH}"/ideploy.inc.bak
#    "${SED}" '/^IDEPLOY_PKG_PATH/d'  "${CUR_PATH}"/ideploy.inc.bak > "${CUR_PATH}"/ideploy.inc
#    "${SED}" '/^IDEPLOY_CONFIG_DIR/d'  "${CUR_PATH}"/ideploy.inc > "${CUR_PATH}"/ideploy.inc.bak
#    "${SED}" '/^IDEPLOY_CONFIG/d'  "${CUR_PATH}"/ideploy.inc.bak > "${CUR_PATH}"/ideploy.inc
#    rm -f "${CUR_PATH}"/ideploy.inc.bak
#-------------------for compatible forward--------------------------
    echo "CUR_PATH=${CUR_PATH}" >> ${CUR_PATH}/ideploy.inc
    echo "PKG_PATH=${PKG_PATH}" >> ${CUR_PATH}/ideploy.inc
#    echo "SCRIPT_DIR=${SCRIPT_DIR}" >> ${CUR_PATH}/ideploy.inc
    echo "CONFIG_DIR=${CONFIG_DIR}" >> ${CUR_PATH}/ideploy.inc
#    echo "CONFIG=${CONFIG}" >> ${CUR_PATH}/ideploy.inc
    echo "CONFIG=config.properties" >> ${CUR_PATH}/ideploy.inc
#-------------------constants---------------------------------------
    #the IDEPLOY_CUR_PATH usually point at the home path of user    
    echo "IDEPLOY_CUR_PATH=${CUR_PATH}" >> ${CUR_PATH}/ideploy.inc
    #usually point at the package directory under task id
    echo "IDEPLOY_PKG_PATH=${PKG_PATH}" >> ${CUR_PATH}/ideploy.inc
    #point at the conf directory
    echo "IDEPLOY_CONFIG_DIR=${CONFIG_DIR}" >> ${CUR_PATH}/ideploy.inc
    #point at the config file which always has properties as suffix 
#    echo "IDEPLOY_CONFIG=${CONFIG}" >> ${CUR_PATH}/ideploy.inc
    echo "IDEPLOY_CONFIG=config.properties" >> ${CUR_PATH}/ideploy.inc
	
	typeset ideploy_task_dir=`echo ${CUR_PATH} | ${AWK} -F / '{ print $NF}'`
	echo "IDEPLOY_TASK_DIR=${ideploy_task_dir}" >> ${CUR_PATH}/ideploy.inc
    
    typeset ftpserver_file="${CUR_PATH}/$3"
    if [ ! -f  "${ftpserver_file}" ];then
        log_echo "debug" "${func_name}" "The sftp server file ${ftpserver_file} isn't exist or a file,needn't to set the config constants key."
        return 0
    fi
    
    convert "${ftpserver_file}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Convert the file ${ftpserver_file} to unix format ${FAILED}!"
        return 1
    fi
    typeset date_pattern_key_count=`cat "${ftpserver_file}" | grep -c "${datePattern_key}"`
    if [ ${date_pattern_key_count} -gt 0 ];then
        read_value "${ftpserver_file}" "${datePattern_key}"
        if [ $? -ne 0 ] ;then
            log_echo "warn" "${func_name}" "Read bond ${ftpserver_file}'s ${datePattern_key} unsuccessful."
            return 1
        fi
       datePattern="${RETURN[0]}"
    fi
    #echo "-----------------------DATE_PATTERN-----${datePattern}------"
    echo "DATE_PATTERN=${datePattern}" >> ${CUR_PATH}/ideploy.inc
    DATE_PATTERN="${datePattern}"
    #echo "===========${DATE_PATTERN}==============="
            
    read_value "${ftpserver_file}" "${CONFIG_TRANSPORT_AES_ENCRYPT_KEY_CONSTANTS}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read value of \"${CONFIG_TRANSPORT_AES_ENCRYPT_KEY_CONSTANTS}\" from \"${ftpserver_file}\" ${FAILED}!"
        return 1
    fi    
    typeset config_transport_aes_encrypt_key="${RETURN[0]}"
       
    echo "CONFIG_TRANSPORT_AES_ENCRYPT_KEY=${config_transport_aes_encrypt_key}" >> ${CUR_PATH}/ideploy.inc
    
    return 0
}

###################################################################################################
#name:set_check_constants
#func:任务创建-检测项页面,下发检测脚本后的常量设置(注意与分发二次开发包时的处理不一致)
#arg1:ideploy.inc文件路径(缺省的时候通过pwd获取)
#arg2:相对当前路径的包路径("..")
#arg3:配置文件名称(ip_user.properties)
###################################################################################################
function set_check_constants
{
    #set -x
    typeset func_name="set_check_constants"
    if [ $# -eq 2 ];then
        CUR_PATH=`pwd`
        PKG_PATH=${CUR_PATH}/$1
        CONFIG=$2
    elif [ $# -eq 3 ];then
        CUR_PATH=$1
        PKG_PATH=${CUR_PATH}/$2
        CONFIG=$3
    else
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    
#检查项常量设置,直接传入properties文件名称,不需要再处理CONFIG    
#    CONFIG=`echo ${CONFIG}|$AWK -F\. '{ if ( $NF == "ftpserver" || $NF == "FTPSERVER" ) print substr($0,0,(length($0)-length($NF))) }'`
#    CONFIG="${CONFIG}properties"
#检查项常量设置,直接传入properties文件名称,不需要再处理CONFIG 
    CONFIG_DIR=${PKG_PATH}/conf
    
#Begin:添加将ip_user.properties文件复制成config.properties文件
    #1.将conf目录下的properties文件move到当前目录
    mv "${CONFIG_DIR}/${CONFIG}" "${PKG_PATH}/${CONFIG}"
    #2.删除conf目录下的所有文件
    rm ${CONFIG_DIR}/*.properties >${IDEPLOY_NULL} 2>&1
    #3.将properties文件move回去
    mv "${PKG_PATH}/${CONFIG}" "${CONFIG_DIR}/${CONFIG}"
    #4.将ip_user.properties文件拷贝为config.properties文件
    cp "${CONFIG_DIR}/${CONFIG}" "${CONFIG_DIR}/config.properties"
    #5.将properties文件进行格式转换
    convert_files "${CONFIG_DIR}"
#End:添加将ip_user.properties文件复制成config.properties文件

#-------------------for compatible forward--------------------------
    echo "CUR_PATH=${CUR_PATH}" >> ${CUR_PATH}/ideploy.inc
    echo "PKG_PATH=${PKG_PATH}" >> ${CUR_PATH}/ideploy.inc
    echo "CONFIG_DIR=${CONFIG_DIR}" >> ${CUR_PATH}/ideploy.inc
    echo "CONFIG=config.properties" >> ${CUR_PATH}/ideploy.inc
#-------------------constants---------------------------------------
    echo "IDEPLOY_CUR_PATH=${CUR_PATH}" >> ${CUR_PATH}/ideploy.inc
    echo "IDEPLOY_PKG_PATH=${PKG_PATH}" >> ${CUR_PATH}/ideploy.inc
    echo "IDEPLOY_CONFIG_DIR=${CONFIG_DIR}" >> ${CUR_PATH}/ideploy.inc
    echo "IDEPLOY_CONFIG=config.properties" >> ${CUR_PATH}/ideploy.inc
	
	typeset ideploy_task_dir=`echo ${CUR_PATH} | ${AWK} -F / '{ print $NF}'`
	echo "IDEPLOY_TASK_DIR=${ideploy_task_dir}" >> ${CUR_PATH}/ideploy.inc
    return 0
}

###################################################################################################
#name:decrypt_ftp_pwd
#func:对ftpserver文件中的ftp密码进行解密
#arg1:ftp密码的密文
###################################################################################################
function decrypt_ftp_pwd
{
    typeset cipher=$1
	  RETURN[0]=""
	  config_value_decrypt "${cipher}" 
	  if [ $? -ne 0 ];then
          return 1
        fi
	  RETURN[0]="${ResultMsg}"
	  return 0
}

function get_script_pkg
{
    typeset func_name="get_script_pkg"
    if [ $# -lt 2 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    typeset paras="$@"
    #有三种传输，ftp，sftp，local；默认使用ftp
    #在框架启用手工发包后，传输方式会设置为local，即从目标主机本地的某个目录发包
    typeset trans_protocal="ftp"
    if [ "X$3" != "X" ];then
        if [ "X$3" = "Xftp" -o "X$3" = "Xsftp" -o "X$3" = "Xlocal" ];then
            trans_protocal="$3"
        else
            log_echo "error" "${func_name}" "The trans protocol parameter[$3] must be one of {ftp|sftp|local}!"
            return 1
        fi
    else
        paras="${paras} ${trans_protocal}"
    fi
    
    #1.前置处理
    typeset cur_path=`pwd`
    
    set_constants ${cur_path} $1 $2
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Set constants ${FAILED}!"
        return 1
    fi
    
    #2.发包
    get_script ${paras}
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Transport script pkg by ${trans_protocal} failed!"
        return 1
    fi
    
    #3.删除文件
    ideploy_del $2
}

function get_apps_pkg
{
    typeset func_name="get_apps_pkg"
    if [ $# -lt 2 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    
    typeset paras="$@"
    #有三种传输，ftp，sftp，local；默认使用ftp
    #在框架启用手工发包后，传输方式会设置为local，即从目标主机本地的某个目录发包
    typeset trans_protocal="ftp"
    if [ "X$3" != "X" ];then
        if [ "X$3" = "Xftp" -o "X$3" = "Xsftp" -o "X$3" = "Xlocal" ];then
            trans_protocal="$3"
        else
            log_echo "error" "${func_name}" "The trans protocol parameter[$3] must be one of {ftp|sftp|local}!"
            return 1
        fi
    else
        paras="${paras} ${trans_protocal}"
    fi
    
    #1.前置处理
    typeset cur_path=`pwd`
    set_constants ${cur_path} $1 $2
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Set constants ${FAILED}!"
        return 1
    fi
    
    #2.发包
    get_apps ${paras}
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Transport apps pkg by ${trans_protocal} failed!"
        return 1
    fi
    
    #3.删除文件
    ideploy_del $2
}

####################################################################
#$1, 发包路径
#$2, properties文件
#$3, ftp/sftp
#$4, 是否需要解压业务包
####################################################################
function get_all_pkg
{
    typeset func_name="get_all_pkg"
    if [ $# -lt 2 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    
    typeset paras="$@"
    #有三种传输，ftp，sftp，local；默认使用ftp
    #在框架启用手工发包后，传输方式会设置为local，即从目标主机本地的某个目录发包
    typeset trans_protocal="ftp"
    if [ "X$3" != "X" ];then
        if [ "X$3" = "Xftp" -o "X$3" = "Xsftp" -o "X$3" = "Xlocal" ];then
            trans_protocal="$3"
        else
            log_echo "error" "${func_name}" "The trans protocol parameter[$3] must be one of {ftp|sftp|local}!"
            return 1
        fi
    else
        paras="${paras} ${trans_protocal}"
    fi
    
    #1.前置处理
    typeset cur_path=`pwd`
    
    set_constants ${cur_path} $1 $2
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Set constants ${FAILED}!"
        return 1
    fi
    
    #2.发包
    get_script ${paras}
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Transport script pkg by ${trans_protocal} failed!"
        return 1
    fi
    
    get_apps ${paras}
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Transport apps pkg by ${trans_protocal} failed!"
        return 1
    fi
    
    #3.删除文件
    ideploy_del $2
}

###################################################################################################
#name:get_apps
#func:函数获取业务软件包.该方法是initiate方法拆开的后半部分，即获取业务软件包。
#arg1:保存的路径
#arg2:ftp配置文件名称
#arg3:ftp/sftp
#arg4:是否解压业务包
###################################################################################################
function get_apps
{
    #set -x
    typeset func_name="get_apps"
    if [ $# -lt 3 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi

    typeset cur_path=`pwd`
    typeset ideploy_dir=$1
    typeset config_file=$2
    typeset trans_protocol=$3
    typeset file_size_compare=$4
    typeset uncompress_cmd=$5
    
    #1.在开始前对ip_user.ftpserver和ip_user.properties文件是否存在进行检查，然后读取FTP相关信息
    if [ ! -f ${config_file} -o `cat ${config_file}|wc -c` -lt 1 ];then
        log_echo "error" "${func_name}" "The file \"${config_file}\" is inexistence or invaliable!"
        return 1
    fi
  
    convert "${config_file}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Convert the file ${config_file} to unix format ${FAILED}!"
        return 1
    fi
    
    #a。读取发包需要的参数
    read_value "${CUR_PATH}/${config_file}" "${PKG_FTP}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read value of \"${PKG_FTP}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
        return 1
    fi
    #设置相关信息
    ftp_info="${RETURN[0]}"
    ftp_info=`eval echo ${ftp_info}` 
    host_ip=`echo ${ftp_info}|$AWK -F, '{print $1}'`
    user=`printf "%s" ${ftp_info}|$AWK -F, '{print $2}'`
    mode=`echo ${ftp_info}|$AWK -F, '{print $3}'`
    local_path=`echo ${ftp_info}|$AWK -F, '{print $4}'`
    server_path=`echo ${ftp_info}|$AWK -F, '{print $5}'`
    trans_port=`echo ${ftp_info}|$AWK -F, '{print $6}'`
    passwd=`printf "%s" "${ftp_info}"|$AWK -F, '{print substr($0,length($1)+length($2)+length($3)+length($4)+length($5)+length($6)+7)}'`
    #对ftp密码进行解密
    decrypt_ftp_pwd "${passwd}"
    passwd="${RETURN[0]}"
    
    #2.再次检查config_file是否存在，然后从中读取包列表信息
    if [ ! -f "${CUR_PATH}/${config_file}" ];then
        log_echo "error" "${func_name}" "${CUR_PATH}/${config_file} is inexistence,transfers interrupted!"
        return 1
    fi
    
    #b。读取需要发哪些包
    . "${CUR_PATH}/${config_file}"
    file_name='${'$PKG_FTP_FILE'}'
    file_name=`eval echo ${file_name}`

    # @ 20081128 将原始的文件列表分隔为两个文件列表，前者以bin模式传输，后者以asc模式传输
    typeset splitMark=",${IDEPLOY_ASCII},"
    typeset bin_file_name=`echo ${file_name} |$AWK -F${splitMark} '{print $1}'`
    typeset asc_file_name=`echo ${file_name} |$AWK -F${splitMark} '{print $2}'`
    if [ "X${asc_file_name}" != "X" ];then
        file_name="${bin_file_name},${asc_file_name}"
    else
        file_name="${bin_file_name}"
    fi
    
    #c。读取业务包类型,插件任务时，该类型取值可能为ftp_task、ftp_pkg，前者实际分发的是脚本包
    read_value "${CUR_PATH}/${config_file}" "${PRODUCT_PKG_TYPE}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read value of \"${PRODUCT_PKG_TYPE}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
        return 1
    fi
    typeset product_pkg_type="${RETURN[0]}"
    
    #3.发包
    log_echo "log" "${func_name}" "Deploy the software package ${START},please wait..."
    
    if [ "X${trans_protocol}" = "Xlocal" -a "X${product_pkg_type}" = "Xftp_task" ];then
        #d。读取备用的发包模式
        read_value "${CUR_PATH}/${config_file}" "${TRANSFER_MODE_WHEN_LOCAL_UNSUPPORTED}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Read value of \"${TRANSFER_MODE_WHEN_LOCAL_UNSUPPORTED}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
            return 1
        fi
        trans_protocol="${RETURN[0]}"
        log_echo "debug" "$0" "Change trans_protocol to ${trans_protocol}."
    fi
    
    #ftp_task的包不支持local模式的分发
    if [ "X${trans_protocol}" = "Xlocal" ];then
        #e。读取手工发包需要用到的包仓库路径
        read_value "${CUR_PATH}/${config_file}" "${PKG_LOCAL}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Read value of \"${PKG_LOCAL}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
            return 1
        fi
        typeset pkg_tmp_depository="${RETURN[0]}"
        
        #发包
        transfer_file_via_manually "${pkg_tmp_depository}" "${local_path}" "${bin_file_name}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Get local file \"${bin_file_name}\" by bin mode ${FAILED}!"
            return 1
        fi
        
        transfer_file_via_manually "${pkg_tmp_depository}" "${local_path}" "${asc_file_name}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Get local file \"${asc_file_name}\" by ascii mode ${FAILED}!"
            return 1
        fi
    else
        #若bin_file_name不为空，则使用bin模式进行发包
    	if [ "X${bin_file_name}" != "X" ];then
            #过滤已经存在的bin软件包
            pkg_filter_${trans_protocol} "${host_ip}" "${trans_port}" "${user}" "${passwd}" "${server_path}" "${local_path}" "${bin_file_name}"
            if [ $? -ne 0 ];then
                log_echo "error" "${func_name}" "Get \"${bin_file_name}\" ${FAILED} when check the package list!"
                return 1
            fi
    		bin_file_name="${RETURN[0]}"
    		
    		if [ "X${bin_file_name}" != "X" ];then
        		#以bin模式发包
                log_echo "info" "${func_name}" "Get files \"${bin_file_name}\" by bin mode..."
                transfer_file_via_${trans_protocol} "${host_ip}" "${user}" "${passwd}" "bin" "${local_path}" "${server_path}" "${trans_port}" "get" "${file_size_compare}" "${bin_file_name}"
                if [ $? -ne 0 ];then
                    log_echo "error" "${func_name}" "Get file \"${bin_file_name}\" ${FAILED}!"
                    return 1
                fi
            fi
        fi
        
        #若asc_file_name不为空，则使用asc模式进行发包
        if [ "X${asc_file_name}" != "X" ];then
            #过滤已经存在的asc软件包
            pkg_filter_${trans_protocol} "${host_ip}" "${trans_port}" "${user}" "${passwd}" "${server_path}" "${local_path}" "${asc_file_name}" 
            if [ $? -ne 0 ];then
                log_echo "error" "${func_name}" "Get \"${asc_file_name}\" ${FAILED} when check the package list!"
                return 1
            fi
    		asc_file_name="${RETURN[0]}"
    		
    		if [ "X${asc_file_name}" != "X" ];then
            	#以asc模式发包
            	log_echo "info" "${func_name}" "Get files \"${asc_file_name}\" by ascii mode..."
                transfer_file_via_${trans_protocol} "${host_ip}" "${user}" "${passwd}" "ascii" "${local_path}" "${server_path}" "${trans_port}" "get" "${file_size_compare}" "${asc_file_name}" 
                if [ $? -ne 0 ];then
                    log_echo "error" "${func_name}" "Get files \"${asc_file_name}\" ${FAILED}!"
                    return 1
                fi
            fi
        fi
    fi

    if [ "X${bin_file_name}" = "X" -a "X${asc_file_name}" = "X" ];then
        log_echo "info" "${func_name}" "No package need to transport!"
    fi
    
    #检查是否需要发的包均以发送,并判断是否需要解压
    typeset old_ifs=$IFS
    IFS=,
    for f in ${file_name}
    do
        if [ "X${f}" != "X" -a ! -f "${local_path}/${f}" ];then
            log_echo "error" "${func_name}" "Can't find the package \"${f}\".Transfer packages failed!"
            return 1
        else
            #如果需要解压缩业务包
            #2010-11-23 该功能只提供给OneSDP解决方案
            if [ "X${uncompress_cmd}" = "Xuncompress" -a "X`echo ${f} | awk -F/ '{print $1}'`" = "Xcomponent" ];then
                uncompress_pkg "${local_path}/${f}" "Y"
            else
                log_echo "debug" "${func_name}" "Need not uncompress : ${local_path}/${f} ."
            fi
        fi
    done
    IFS=${old_ifs}
    
    #对需要解压的场景后续处理
    if [ "X${uncompress_cmd}" = "Xuncompress" ];then
        typeset date_num=`date '+%H%M%S%s'`
        typeset ideploy_temp="${cur_path}/.ideploy_temp_${date_num}"
        
        #1/替换各module下的ideploy.inc
        refresh_ideploy_inc ${ideploy_temp} ${cur_path}
        if [ $? -ne 0 ];then
            return 1
        fi
        
        #2/替换ideploy_env.properties中ideploy_properties_path的值
        update_ideploy_properties_path ${ideploy_temp} ${cur_path}
        if [ $? -ne 0 ];then
            return 1
        fi
        
        #3/添加可执行权限
        chmod -R +x ${cur_path} 2>${IDEPLOY_NULL}
        
        #4/删除临时文件
        rm ${ideploy_temp}
    fi
    log_echo "log" "${func_name}" "Deploy the software package ${SUCCESSFUL}!"
}

#更新ideploy_env.properties文件中，ideploy_properties_path的键值
function update_ideploy_properties_path
{
    typeset func_name="update_ideploy_properties_path"
    typeset ideploy_temp=$1
    typeset cur_path=$2
    typeset ideploy_env_properties="ideploy_env.properties"
    typeset properties_path_key="ideploy_properties_path"
    typeset config_properties_value="${CONFIG_DIR}/config.properties"
    echo > ${ideploy_temp}
    
    log_echo "info" "${func_name}" "Start update value of \"${properties_path_key}=${config_properties_value}\"..."
    
    #获取当前目录下所有ideploy_env.properties文件列表
    du -a ${cur_path} |$AWK '{print $2}'| grep "${ideploy_env_properties}$" > ${ideploy_temp}
    while read line
    do
        if [ ! -f ${line} ];then
            log_echo "debug" "${func_name}" "The \"${line}\" is inexistence or not a file, continue next..."
            continue
        fi
        
        #添加写权限
        chmod +w ${line}
        
        #将无关的行写入到bak文件
        cat ${line} | $AWK -F= -v key=${properties_path_key} '{ if (index($1,key) <= 0) print $0 }' > ${line}.bak
        
        #写入新值
        echo "${properties_path_key}=${config_properties_value}" >> ${line}.bak
        
        #删除老文件，重命名新文件
        rm ${line}
        mv ${line}.bak ${line}
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Update value of \"${properties_path_key}\" in \"${line}\" failed."
            return 1
        else
            log_echo "info" "${func_name}" "Update value of \"${properties_path_key}\" in \"${line}\" finish."
        fi
    done < ${ideploy_temp}
    log_echo "info" "${func_name}" "Update value of \"${properties_path_key}\" finish"
    return 0
}

#更新ideploy.inc文件，目的是使子目录下的所有ideploy.inc文件含有全局变量
function refresh_ideploy_inc
{
    typeset func_name="copy_ideploy_inc"
    typeset ideploy_temp=$1
    typeset cur_path=$2
    typeset ideploy_inc="${cur_path}/ideploy.inc"
    
    log_echo "info" "${func_name}" "Start refresh all ideploy.inc from \"${ideploy_inc}\"..."
    echo > ${ideploy_temp}
    
    #获取目录下所有的ideploy.inc文件列表
    du -a ${cur_path} |$AWK '{print $2}'| grep "ideploy.inc$" |grep -v "${ideploy_inc}" > ${ideploy_temp}
    while read line
    do
        #给ideploy.inc文件添加写权限,避免无法覆盖
        chmod +w ${line}
        #进行覆盖
        cp ${ideploy_inc} ${line}
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Refresh \"${line}\" failed."
            return 1
        else
            log_echo "info" "${func_name}" "Refresh \"${line}\" finish."
        fi
    done < ${ideploy_temp}
    log_echo "info" "${func_name}" "Refresh all ideploy.inc finish."
    return 0
}

function del_other_host_cfgfile
{
    typeset func_name="del_other_host_cfgfile"
    #find the config properties file name start with ip and username   
    typeset start_with_ip_file_list=`ls -l "${CONFIG_DIR}" |${AWK} '{print $NF}' |${GREP} -i "^[1-9][0-9]\{1,2\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}_.*\.properties"`
    
    if [ -z "${CONFIG}" ];then
        log_echo "error" "${func_name}" "The config file name is empty!"
        return 1
    fi
    
    #get current host ip and user name
    typeset curr_host_ip=`echo "${CONFIG}" | ${AWK} -F_ '{print $1}'`
    typeset curr_username=`echo "${CONFIG}" | ${AWK} -F_ '{print substr($0,length($1)+2,length($0)-length($1)-12)}'`
    typeset match_file_name=""
    
    #delete the config properties which isn't current host
    for config_file_name in ${start_with_ip_file_list}
    do
        match_file_name=`echo "${config_file_name}" | ${GREP} -i "^${curr_host_ip}_${curr_username}.*\.properties"`
        if [ -z "${match_file_name}" ];then
            rm -rf "${CONFIG_DIR}/${config_file_name}"
        fi
    done
    
    #delete the ftpserver file
    rm ${CONFIG_DIR}/*.ftpserver >${IDEPLOY_NULL} 2>&1
    
    return 0
}

###################################################################################################
#name:get_script
#func:函数获取二次开发脚本包.该方法是initiate方法拆开的前半部分，即获取二次开发包。
#arg1:保存的路径
#arg2:ftp配置文件名称
###################################################################################################
function get_script
{
	#set -x
    typeset func_name="get_script"
    if [ $# -lt 3 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi

    typeset cur_path=`pwd`
    typeset ideploy_dir=$1
    typeset config_file=$2
    typeset trans_protocol=$3
    
    convert "${config_file}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Convert the file ${config_file} to unix format ${FAILED}!"
        return 1
    fi

    #get_script不支持手工发，若传下的参数为local，则需要修正，2011-6-22
    if [ "X${trans_protocol}" = "Xlocal" ];then
        #e。读取备用的发包模式
        read_value "${CUR_PATH}/${config_file}" "${TRANSFER_MODE_WHEN_LOCAL_UNSUPPORTED}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Read value of \"${TRANSFER_MODE_WHEN_LOCAL_UNSUPPORTED}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
            return 1
        fi
        trans_protocol="${RETURN[0]}"
        log_echo "debug" "$0" "Change trans_protocol to ${trans_protocol}."
    fi
    
#Begin: @ 2008-09-28 在开始前对ip_user.ftpserver和ip_user.properties文件是否存在进行检查
    if [ ! -f ${config_file} -o `cat ${config_file}|wc -c` -lt 1 ];then
        log_echo "error" "${func_name}" "The file \"${config_file}\" is inexistence or invaliable!Transfer script package failed!"
        return 1
    fi
    if [ ! -f ${CONFIG} -o `cat ${CONFIG}|wc -c` -lt 1 ];then
        log_echo "error" "${func_name}" "The file \"${CONFIG}\" is inexistence or invaliable!Transfer script package failed!"
        return 1
    fi
#End: @ 2008-09-28 在开始前对ip_user.ftpserver和ip_user.properties文件是否存在进行检查
    
#1.创建目录.
    make_dir "${ideploy_dir}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Create directory \"${ideploy_dir}\" ${FAILED}!"
        return 1
    fi
    
#    typeset ping_path=""
#    typeset ans=`which ping|$AWK -F\/ '/^\// { print $NF}'`
#    if [ "X${ans}" != "Xping" ];then
#        log_echo "log" "${func_name}" "Try to find the \"ping\" command,please wait..."
#        for ping_path in ${find_path_dir}
#        do
#            PING=`find ${ping_path} -name ping 2>${IDEPLOY_NULL}|$AWK '/^\// { print $0 }'` 
#            if [ "X${PING}" != "X" ];then
#                break
#            fi
#        done
#    else
#        PING="ping"    
#    fi
   
#2.从ftp_server上获取二次开发包,并解压
    typeset ftp_info=""
    typeset host_ip=""
    typeset user=""
    typeset passwd=""
    typeset file_name=""
    typeset mode=""
    typeset local_path=""
    typeset server_path=""
    typeset trans_port=""
    
    #获取ftp信息
    read_value "${CUR_PATH}/${config_file}" "${IDEPLOY_FTP}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read value of \"${IDEPLOY_FTP}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
        return 1
    fi
    ftp_info="${RETURN[0]}"
    ftp_info=`eval echo ${ftp_info}` 
    host_ip=`echo ${ftp_info}|$AWK -F, '{print $1}'`
    user=`printf "%s" ${ftp_info}|$AWK -F, '{print $2}'`
    mode=`echo ${ftp_info}|$AWK -F, '{print $3}'`
    local_path=${ideploy_dir}
    server_path=`echo ${ftp_info}|$AWK -F, '{print $5}'`
    trans_port=`echo ${ftp_info}|$AWK -F, '{print $6}'`
    passwd=`printf "%s" "${ftp_info}"|$AWK -F, '{print $7}'`
    #对ftp密码进行解密   
    decrypt_ftp_pwd "${passwd}"
    passwd="${RETURN[0]}"
    
    #typeset cur_path=`pwd`
    #local_path="${cur_path}/${local_path}"
    #获取文件
    read_value "${CUR_PATH}/${config_file}" "${IDEPLOY_FTP_FILE}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read value of \"${IDEPLOY_FTP_FILE}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
        return 1
    fi
    file_name="${RETURN[0]}"
    
    log_echo "log" "${func_name}" "Deploy the ideploy.tar ${START},please wait..."
    
    transfer_file_via_${trans_protocol} "${host_ip}" "${user}" "${passwd}" "${mode}" "${local_path}" "${server_path}" "${trans_port}" "get" "warn" "${file_name}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Get file \"${file_name}\" ${FAILED}!"
        return 1
    fi
    
    #log_echo "log" "${func_name}" "Deploy the ideploy.tar ${SUCCESSFUL}!"
    
    #解压二次开发包
    untar_pkg "${local_path}/${file_name}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Untar the file \"`pwd`/${local_path}/${file_name}\" ${FAILED}!"
        return 1
    fi
    
    #设置目录权限
#begin： @ 2007-8-9/10:08 : 避免某些主机上由于通配符的问题造成权限修改失败
    #chmod -R +x ${local_path}/script/*
#begin:  @ 2012-7-6 : 重定向错误关键字，避免发包失败
    chmod -R +x ${CUR_PATH}/${ideploy_dir}/script >${IDEPLOY_NULL} 2>&1
#end  :  @ 2012-7-6
#end  :  @ 2007-8-9/10:08     
    if [ $? -ne 0 ];then
        log_echo "warn" "${func_name}" "Change mode for script(s) with ${WARN}!"
    fi
    
    typeset ideploy_tmp_dir="${CUR_PATH}/${ideploy_dir}/script/tmp"
    
    #如果ideploy临时目录不存在则创建
    if [ ! -d "${ideploy_tmp_dir}" ];then
        mkdir -p "${ideploy_tmp_dir}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Make directory ${ideploy_tmp_dir} ${FAILED}!"
            return 1
        fi
        
        #增加777权限
        chmod 777 "${ideploy_tmp_dir}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Change mode for directory ${ideploy_tmp_dir} ${FAILED}!"
            return 1
        else
            log_echo "debug" "${func_name}" "Change mode for directory ${ideploy_tmp_dir} ${SUCCESSFUL}!"
        fi
    fi
    
#set -x    
    #将properties文件拷贝至conf目录下
#    if [ -f ${CUR_PATH}/${CONFIG} -a -d ${CONFIG_DIR} ];then
#        rm ${CONFIG_DIR}/*.properties
#        cp "${CUR_PATH}/${CONFIG}" "${CONFIG_DIR}/${CONFIG}"
#        if [ $? -ne 0 ];then
#            log_echo "log" "${func_name}" "Copy the \"${CONFIG}\" ${FAILED}!"
#            return 1
#        fi
#    fi
#B36修改properties处理流程如下：
    if [ ! -f ${CONFIG_DIR}/${CONFIG} ];then 
        log_echo "error" "${func_name}" "The properties file \"${CONFIG_DIR}/${CONFIG}\" can not found!"
        return 1
    else
        del_other_host_cfgfile
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Delete the other host config file from "${CONFIG_DIR}" fail."
            return 1
        fi
        
        #1.将ip_user.properties文件拷贝为config.properties文件
        cp "${CONFIG_DIR}/${CONFIG}" "${CONFIG_DIR}/config.properties"
        #2.将properties文件进行格式转换
        convert_files "${CONFIG_DIR}"
    fi
    
#获取dispatch包
    #判断ftpserver文件中是否含有DISPATCH_FTP和DISPATCH_FTP_FILE键
    typeset has_dispatch="N"
    if [ ! -f ${CUR_PATH}/${config_file} ];then
        log_echo "warn" "${func_name}" "${CUR_PATH}/${config_file} is inexistence,tranfers interrupted!"
    else
        typeset count1=`cat ${CUR_PATH}/${config_file}|$AWK -F= -v key="${DISPATCH_FTP}" '{ if ( $1 == key ) print $0 }' |wc -l`
        if [ $? -eq 0 -a ${count1} -eq 1 ];then
            typeset count2=`cat ${CUR_PATH}/${config_file}|$AWK -F= -v key="${DISPATCH_FTP_FILE}" '{ if ( $1 == key ) print $0 }' |wc -l`
            if [ $? -eq 0 -a ${count2} -eq 1 ];then
                has_dispatch="Y"
            fi
        fi
    fi
    
    #判断ftpserver文件中是否含有dispatch键,若没有则不进行操作
    if [ "X${has_dispatch}" = "XY" ];then
        #读取dispatch_ftp信息
        read_value "${CUR_PATH}/${config_file}" "${DISPATCH_FTP}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Read value of \"${DISPATCH_FTP}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
            return 1
        fi
        ftp_info="${RETURN[0]}"
        host_ip=`echo ${ftp_info}|$AWK -F, '{print $1}'`
        user=`printf "%s" ${ftp_info}|$AWK -F, '{print $2}'`
        #passwd=`printf "%s" ${ftp_info}|$AWK -F, '{print $3}'`
        mode=`echo ${ftp_info}|$AWK -F, '{print $3}'`
        local_path=`echo ${ftp_info}|$AWK -F, '{print $4}'`
        server_path=`echo ${ftp_info}|$AWK -F, '{print $5}'`
        trans_port=`echo ${ftp_info}|$AWK -F, '{print $6}'`
        passwd=`printf "%s" "${ftp_info}"|$AWK -F, '{print substr($0,length($1)+length($2)+length($3)+length($4)+length($5)+length($6)+7)}'`
        #对ftp密码进行解密
        decrypt_ftp_pwd "${passwd}"
        passwd="${RETURN[0]}"
               
        #获取dispatch包
        read_value "${CUR_PATH}/${config_file}" "${DISPATCH_FTP_FILE}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Read value of \"${DISPATCH_FTP_FILE}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
            return 1
        fi
        file_name="${RETURN[0]}"
        
        log_echo "log" "${func_name}" "Deploy the dispatch package ${START},please wait..."
        
        transfer_file_via_${trans_protocol} "${host_ip}" "${user}" "${passwd}" "${mode}" "${local_path}" "${server_path}" "${trans_port}" "get" "warn" "${file_name}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Get file \"${file_name}\" ${FAILED}!"
            return 1
        fi 
        
        log_echo "log" "${func_name}" "Deploy the dispatch package ${SUCCESSFUL}!"
        
        #将dispatch包解压至cfgdispatch目录
        typeset dis_dir="cfgdispatch"
        make_dir "${ideploy_dir}/${dis_dir}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Create directory \"${ideploy_dir}/${dis_dir}\" ${FAILED}!"
            return 1
        fi
        
        mv "${CUR_PATH}/${ideploy_dir}/${file_name}" "${CUR_PATH}/${ideploy_dir}/${dis_dir}/${file_name}"
        untar_pkg "${CUR_PATH}/${ideploy_dir}/${dis_dir}/${file_name}"
        if [ $? -ne 0 ];then
            #log_echo "log" "${func_name}" "Untar the file \"${file_name}\" ${FAILED}!"
            log_echo "error" "${func_name}" "Untar the file \"${CUR_PATH}/${ideploy_dir}/${dis_dir}/${file_name}\" ${FAILED}!"
            return 1
        fi
        
        rm "${CUR_PATH}/${ideploy_dir}/${dis_dir}/${file_name}"
		#Begin 2007-06-13       
        #文件格式转换
        convert_files "${CUR_PATH}/${ideploy_dir}/${dis_dir}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Convert format for \"${CUR_PATH}/${ideploy_dir}/${dis_dir}\" ${FAILED}!"
            return 1
        fi
        log_echo "log" "${func_name}" "Convert format for \"${CUR_PATH}/${ideploy_dir}/${dis_dir}\" ${SUCCESSFUL}!"
		#End 2007-06-13          
    fi
    
    #将添加过全局变量的ideploy.inc文件拷贝到script目录下
    if [ ! -f "${CUR_PATH}/ideploy.inc" ];then
        log_echo "error" "${func_name}" "The \"${CUR_PATH}/ideploy.inc\" is inexistence,please try again!"
        return 1
    fi
    
    if [ -d "${ideploy_dir}/script" ] ;then
        #cp ${CUR_PATH}/ideploy.inc ${ideploy_dir}/script >${IDEPLOY_NULL} 2>&1
        cp ${CUR_PATH}/ideploy.inc ${ideploy_dir}/script
    fi
    
#Begin: @ 2008-09-28 在结束后对script、conf、cfgdispatch目录进行检查

    if [ ! -d "conf" ];then
        log_echo "error" "${func_name}" "The directory \"conf\" is inexistence!Transfer script package failed!"
        return 1
    fi
    
    if [ ! -d "script" ];then
        log_echo "error" "${func_name}" "The directory \"script\" is inexistence!Transfer script package failed!"
        return 1
    fi
    
    if [ "X${has_dispatch}" = "XY" -a ! -d "cfgdispatch" ];then
        log_echo "error" "${func_name}" "The directory \"cfgdispatch\" is inexistence!Transfer script package failed!"
        return 1
    fi
    
    log_echo "log" "${func_name}" "Deploy the ideploy.tar ${SUCCESSFUL}!"
    #End: @ 2008-09-28 在结束后对script、conf、cfgdispatch目录进行检查
    
    #将task目录增加到垃圾文件ideploy_file_history中,便于独立工具的删除垃圾文件
    add_file_record `pwd`
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "add  taskdir to ideploy_file_history ${FAILED}!"
        return 1
    fi
}

function change_dir
{
    typeset cd_path=$2
    #路径切换信息干扰太大，仅在定位问题才放开打印
    #log_echo "debug" $1 "Change Directory to \"${cd_path}\"."
    cd ${cd_path}
}

#解压缩*.tar.gz或者*.zip包
#参数1，需要解压的文件；参数2，是否需要递归解压（Y/N）
function uncompress_pkg
{
    #set -x
    typeset func_name="uncompress_pkg"
    typeset cur_path=`pwd`
    
    #带路径的原始包名
    typeset pkg_path_name=$1
    
    #是否递归解压
    typeset recursion=$2
    
    #层次
    typeset -i recursion_level=$3
    if [ "X${recursion_level}" = "X" ];then
        recursion_level=0
        func_name="${func_name}.0"
    else
        func_name="${func_name}.${recursion_level}"
    fi
    
    #拆分路径
    typeset expand_dirname=`dirname ${pkg_path_name}`
    
    #拆分文件名称
    typeset expand_filename=`basename ${pkg_path_name}`
    
    #保存识别为*.tar.gz或者*.zip之后的文件名称
    typeset gz_pkgname=""
    typeset tar_pkgname=""
    typeset zip_pkgname=""
    
    #记录解压出来的信息
    typeset date_num=`date '+%H%M%S%s'`
    typeset ideploy_temp="${cur_path}/.ideploy_temp_${date_num}"
    
    #判断是否是文件，不是文件则直接退出
    if [ ! -f "${cur_path}/${pkg_path_name}" ];then
        log_echo "debug" "${func_name}" "Need not expand directory \"${cur_path}/${pkg_path_name}\"."
        return 0
    fi
    
    #判断包的结尾
    gz_pkgname=`echo ${expand_filename} | $AWK -F\. '{ if ( $NF == "gz" && $(NF-1) == "tar" ) print $0}'`
    zip_pkgname=`echo ${expand_filename} | $AWK -F\. '{ if ( $NF == "zip" ) print $0}'`
    
    #既不是*.tar.gz也不是*.zip则退出
    if [ "X${gz_pkgname}" = "X" -a "X${zip_pkgname}" = "X" ];then
        #log_echo "debug" "${func_name}" "File \"${pkg_path_name}\" is not a compressed file."
        return 0
    else
        log_echo "info" "${func_name}" "Start uncompress file \"${cur_path}/${pkg_path_name}\"."        
    fi
    #1、切换路径
    change_dir ${func_name} ${cur_path}/${expand_dirname}
    touch ${ideploy_temp}
    
    #2、解压*.tar.gz包
    if [ "X${gz_pkgname}" != "X" ];then
        #2.1 解压gz
        gunzip -f ${gz_pkgname}
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Gunzip file by command \"gunzip -f ${gz_pkgname}\" failed!"
            rm -f ${ideploy_temp}
            change_dir ${func_name} ${cur_path}
            return 1
        fi
        #2.2 解压tar,替换掉.gz后缀
        tar_pkgname=`echo ${gz_pkgname} | $SED s/\.gz$//g`
        tar -xvf ${tar_pkgname} > ${ideploy_temp}.tmp 2>&1
        if [ $? -ne 0 ];then
            if [ ${recursion_level} -eq 0 ];then
                log_echo "error" "${func_name}" "Gunzip file by command \"tar -xvf ${tar_pkgname}\" failed!"
                #pwd;echo "1rm -f ${ideploy_temp}"
                rm -f ${ideploy_temp}.tmp
                change_dir ${func_name} ${cur_path}
                return 1
            #如果是递归解压，则忽略解压错误，只是告警。为解决问题单：DTS2012061306526 
            else
                log_echo "warn" "${func_name}" "Gunzip file \"${cur_path}/${pkg_path_name}\" with warn."
                echo > ${ideploy_temp}
            fi
        else
            cat ${ideploy_temp}.tmp | $AWK '{ if ( NF >=2) {print $2} else {print $1} } ' > ${ideploy_temp}
            log_echo "info" "${func_name}" "Gunzip file \"${cur_path}/${pkg_path_name}\" successful."
        fi
    fi
    
    #3、解压*.zip包
    if [ "X${zip_pkgname}" != "X" ];then       
        #3.1 解压
        unzip -o ${zip_pkgname} > ${ideploy_temp}.tmp 2>&1
        if [ $? -ne 0 ];then
            if [ ${recursion_level} -eq 0 ];then
                log_echo "error" "${func_name}" "Unzip file by command \"unzip -o  ${zip_pkgname}\" failed!"
                #pwd;echo "2rm -f ${ideploy_temp}"
                rm -f ${ideploy_temp}.tmp
                change_dir ${func_name} ${cur_path}
                return 1
            else
                log_echo "warn" "${func_name}" "Unzip file \"${cur_path}/${pkg_path_name}\" with warn."
                echo > ${ideploy_temp}
            fi
        else
            cat ${ideploy_temp}.tmp | $AWK '{ if ( $1 != "Archive:" ) print $2}' > ${ideploy_temp}
            log_echo "info" "${func_name}" "Unzip file \"${cur_path}/${pkg_path_name}\" successful."
        fi
    fi
    
    #3、递归解压
    if [ "X${recursion}" = "XY" ];then
        #递归层次加1
        ((recursion_level+=1))
        
        log_echo "info" "${func_name}" "Go on expand sub-directory files in level ${recursion_level}"
        while read line
        do
            if [ ! -f "${line}" ];then
                continue
            fi
            
            uncompress_pkg "${line}" "N" "${recursion_level}"
            
            if [ $? -ne 0 ];then
                return 1
            fi
        done < ${ideploy_temp}
    fi
    
    #4、切换回当前路径
    #echo "rm -f ${ideploy_temp}"
    rm -f ${ideploy_temp}
    rm -f ${ideploy_temp}.tmp
    change_dir ${func_name} ${cur_path}
}
function transfer_file_via_sftp
{
    typeset func_name="transfer_file_via_sftp"
    if [ $# -lt 4 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}!"
        return 1
    fi
    
    typeset ftp_server_ip=$1
    typeset ftp_user=$2
    typeset ftp_passwd=$3
    typeset ftp_mode=$4    
    typeset local_path=$5
    typeset server_path=$6
    typeset trans_port=$7
    typeset trans_type=$8
    typeset file_size_compare=$9
    shift 9
    typeset file_names=$@
    
    
    #参数判断
    if [ "X${file_names}" = "X" ];then
        log_echo "warn" "${func_name}" "No files need to transport!"
        return 0
    fi
    
    #打印日志
    log_echo "info" "${func_name}" "Send files by sftp, please wait..."
    
    #判断传输方向
    if [ "X${trans_type}" != "Xput" -a "X${trans_type}" != "Xget" ];then
        trans_type="get"
    fi
   
    #创建临时文件，生成指令使用
    while [ -f ${IDEPLOY_TEMP} ]
    do
        date_num=`date '+%H%M%S'`
        IDEPLOY_TEMP="./.ideploy_temp_${date_num}"
        sleep 1
    done
    touch "${IDEPLOY_TEMP}"

    #清空
    echo " " > "${IDEPLOY_TEMP}"
    
    #执行sftp指令，报文记录到文件
    typeset sftp_msg_file="./ideploy_sftp_message"
    echo "" > ${sftp_msg_file}
    
    #拼接文件
    typeset org_ifs=$IFS
    IFS=,
    for f in ${file_names}
    do
        #file_name=`echo ${f}|$AWK -F/ '{print $NF}'`
        file_relative_path=`echo ${f}|$AWK -F/ '{print substr($0,0,(length($0)-length($NF)))}'`
        
        #创建目录
        if [ "X${file_relative_path}" != "X" ];then
            mkdir -p "${local_path}/${file_relative_path}"
        fi
        
        if [ "X${trans_type}" = "Xget" ];then
            #获取sever上的文件大小
            echo "ls -l \"${server_path}/${f}\"\n" >> "${IDEPLOY_TEMP}"
            echo "${trans_type} \"${server_path}/${f}\" \"${local_path}/${f}\"\n" >> "${IDEPLOY_TEMP}"
        else
            echo "${trans_type} \"${local_path}/${f}\" \"${server_path}/${f}\"\n" >> "${IDEPLOY_TEMP}"
            echo "ls -l \"${server_path}/${f}\"\n" >> "${IDEPLOY_TEMP}"
        fi
    done
    IFS=${org_ifs}
    
	cat ${IDEPLOY_TEMP} | ${GREP} "%"
	if [ $? -eq 0 ]; then
	    #printf输出内容含有%特殊字符要将%转义下
	    replace_printf_special_character "${IDEPLOY_TEMP}"
	fi
	
    #开始执行sftp发包
    printf "`cat ${IDEPLOY_TEMP}`\n" |sftp -o "UserKnownHostsFile /dev/null" -o "StrictHostKeyChecking no" -o "Port ${trans_port}" ${ftp_user}@${ftp_server_ip} 2>&1 | tee -a ${sftp_msg_file} 

    #匹配sftp错误关键字，如果错误则直接退出，等待iDeploy进行发包重试
    typeset sftp_key_count=`grep -c 'key_verify failed for server_host_key' ${sftp_msg_file}`
    if [ ${sftp_key_count} -gt 0 ];then
        log_echo "debug" "${func_name}" "matched ssh verify key, return at once."
        exit 0
    fi

    #统计local的文件大小及给文件增加读权限
    IFS=,
    for f in ${file_names}
    do
        #获取本地文件的大小
        ls -l "${local_path}/${f}" >> ${sftp_msg_file} 2> ${IDEPLOY_NULL}
        #给所有用户增加读权限
        chmod +r "${local_path}/${f}" 2> ${IDEPLOY_NULL}
    done
    IFS=${org_ifs}
    
    #echo "+++++++++++++++++++++++++++++++"
    #cat ${sftp_msg_file}
    #echo "+++++++++++++++++++++++++++++++"
    
    #比较大小
    #echo "==============================================="
    #set -x
    #添加开关，方便屏蔽功能
    typeset need_check_size="true"
    if [ "X${need_check_size}" = "Xtrue" ];then
        IFS=,
        typeset file_on_server=""
        typeset file_on_local=""
        typeset size_of_file_on_server=""
        typeset size_of_file_on_local=""
        typeset is_take_error_log="false"
        typeset is_matche_size_error="false"
        if [ "X${file_size_compare}" = "Xerror" ] ;then
           is_take_error_log="true"    
        fi           
        #替换路径中的相对路径"."，以免后续使用grep匹配时，匹配成任意字符
        typeset tmp_local_path=`echo ${local_path} | $SED s/\./\\\\\\\\./`
        for f in ${file_names}
        do
            file_on_server=`cat ${sftp_msg_file} | $GREP ${server_path}/${f} |$SED 's/sftp>/ /g'| $GREP ".*[-wrx]\{10\}"`
            file_on_local=`cat ${sftp_msg_file} | $GREP ${tmp_local_path}/${f} | $GREP ".*[-wrx]\{10\}"`
	    if [ "X${file_on_local}" = "X" ] ;then
	       file_on_local=`cat ${sftp_msg_file} | $GREP ${local_path}/${f} | $GREP ".*[-wrx]\{10\}"` 
	    fi
            #file_on_server=`cat ${sftp_msg_file} | $GREP ${server_path}/${f} | $GREP -v "^sftp" | $GREP -v "^Fetching"`
            #file_on_local=`cat ${sftp_msg_file} | $GREP ${tmp_local_path}/${f} | $GREP -v "^sftp" | $GREP -v "^Fetching"`

            #echo "------------------------"
            #echo ${file_on_server}
            #echo "------------------------"
            #echo ${file_on_local}
            #echo "------------------------"
            size_of_file_on_server=`echo ${file_on_server} | $AWK '{print $5}'`
            size_of_file_on_local=`echo ${file_on_local} | $AWK '{print $5}'`
            if [ "X${size_of_file_on_server}" = "X${size_of_file_on_local}" ];then
                log_echo "info" "${func_name}" "The size of file \"${f}\" on local is \"${size_of_file_on_local}\"!"
            else
                #大小不一致，说明传输发生错误
                if [ "X${is_take_error_log}" = "Xtrue" ];then
                   is_matche_size_error="true"
                   log_echo "error" "${func_name}" "Get the size of file \"${f}\" on server is \"${size_of_file_on_server}\", and on local is \"${size_of_file_on_local}\"!Please check it manually!"
                else                
                   log_echo "warn" "${func_name}" "Get the size of file \"${f}\" on server is \"${size_of_file_on_server}\", and on local is \"${size_of_file_on_local}\"!Please check it manually!"
                fi   
                #IFS=${org_ifs}
                #return 1
            fi
            #echo "size_of_file_on_server=${size_of_file_on_server}"
            #echo "size_of_file_on_local=${size_of_file_on_local}"
        done
        IFS=${org_ifs}
        if [ "X${is_matche_size_error}" = "Xtrue" ];then
           log_echo "error" "${func_name}" "The sizes of file on server and on current host are unequal. The error logs above are detail information.Please check it manually."
           rm "${IDEPLOY_TEMP}"
           rm "${sftp_msg_file}"
           return 1
        fi   
    fi
    #set +x
    #echo "==============================================="
    
    #过滤报文中的错误信息
    #set -x
    typeset err_key=`cat ${sftp_msg_file}`
    for err in ${err_key}
    do
        case ${err} in
        No|not|Invalid|invalid|denied|Unable)
        ret="1"
        ;;
        *)
        ;;
        esac
        if [ "X${ret}" = "X1" ];then
            log_echo "error" "${func_name}" "Get files via sftp ${FAILED} with error key word \"${err}\"!"
            rm "${IDEPLOY_TEMP}"
            rm "${sftp_msg_file}"
            return 1
        fi
    done
    
    #如果是以ascii模式传输
    if [ "Xascii" = "X${ftp_mode}" ];then
        IFS=,
        for f in ${file_names}
        do
            convert "${local_path}/${f}"
        done
        IFS=${org_ifs}
    fi
    
    #删除临时文件，恢复分隔符
    rm "${IDEPLOY_TEMP}"
    rm "${sftp_msg_file}"
    
}

###################################################################################################
#name:replace_printf_special_character
#func:私有函数，DTS2014040309250,printf输出内容含有时%特殊字符要将%转义下，%是printf自身有意义的符号
#arg1:保存的路径
#arg2:ftp配置文件名称
#arg3:sftp协议还是ftp协议
#arg4:是否需要解压
###################################################################################################
function replace_printf_special_character
{
	typeset IDEPLOY_TEMP="${1}"
	typeset temp_ideploy_file=${IDEPLOY_TEMP}_bak
	#清空
	echo "" > ${temp_ideploy_file}
	cp ${IDEPLOY_TEMP} ${temp_ideploy_file}
	${SED} s/%/%%/g ${temp_ideploy_file} > ${IDEPLOY_TEMP} 2>/dev/null
	if [ $? -ne 0 ];then
	    log_echo "error" "${func_name}" "Replace special character '%' in the file ${IDEPLOY_TEMP} failed. (At: comm_lib :$LINENO)"
		rm -fr ${temp_ideploy_file}
		return 1
	fi
	rm -fr ${temp_ideploy_file}
}

###################################################################################################
#name:get_golbaltool_all_pkg
#func:全局工具获取业务包和脚本包的函数，获取之前判断文件是否存在，如果所有的文件都存在则不需要获取
#arg1:保存的路径
#arg2:ftp配置文件名称
#arg3:sftp协议还是ftp协议
#arg4:是否需要解压
###################################################################################################
function get_golbaltool_all_pkg
{
    typeset func_name="get_golbaltool_all_pkg"    
    typeset config_file=$2
    typeset send_file_list=""
    
    if [ $# -lt 2 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    
    CUR_PATH=`pwd`
    convert  "${CUR_PATH}/${config_file}"
     if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "convert file:${CUR_PATH}/${config_file} to unix format failed"
        return 1
    fi
     #获取脚本包文件名称
    read_value "${CUR_PATH}/${config_file}" "${IDEPLOY_FTP_FILE}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read value of \"${IDEPLOY_FTP_FILE}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
        return 1
    fi
    send_file_list="${RETURN[0]}"
    #去掉前后可能的双引号
    send_file_list=`echo ${send_file_list} | $AWK -F\" '{if ( $1=="" ) {print $2} else {print $1}}'`
    
    #获取业务包名称列表
    read_value "${CUR_PATH}/${config_file}" "${PKG_FTP_FILE}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read value of \"${PKG_FTP_FILE}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
        return 1
    fi
    typeset service_pkg_list="${RETURN[0]}"
    #去掉前后可能的双引号
    service_pkg_list=`echo ${service_pkg_list} | $AWK -F\" '{if ( $1=="" ) {print $2} else {print $1}}'`
    send_file_list="${send_file_list},${service_pkg_list}"
    
    #判断是否需要发文件
    is_need_send_file "${send_file_list}"
    if [ $? -eq 0 ];then
        log_echo "info" "${func_name}" "The send files ${send_file_list} already existed, needn't send."
        return 0
    fi
    
    get_all_pkg $@
}

###################################################################################################
#name:get_golbaltool_script_pkg
#func:全局工具获取脚本包的函数，获取之前判断文件是否存在，如果所有的文件都存在则不需要获取
#arg1:保存的路径
#arg2:ftp配置文件名称
#arg3:sftp协议还是ftp协议
#arg4:是否需要解压
###################################################################################################
function get_golbaltool_script_pkg
{
    typeset func_name="get_golbaltool_script_pkg"    
    typeset config_file=$2
    typeset send_file_list=""
      
    if [ $# -lt 2 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    
    CUR_PATH=`pwd`
     #获取脚本包文件名称
    read_value "${CUR_PATH}/${config_file}" "${IDEPLOY_FTP_FILE}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read value of \"${IDEPLOY_FTP_FILE}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
        return 1
    fi
    send_file_list="${RETURN[0]}"
    #去掉前后可能的双引号
    send_file_list=`echo ${send_file_list} | $AWK -F\" '{if ( $1=="" ) {print $2} else {print $1}}'`
        
    #判断是否需要发文件
    is_need_send_file "${send_file_list}"
    if [ $? -eq 0 ];then
        log_echo "info" "${func_name}" "The send files ${send_file_list} already existed, needn't send."
        return 0
    fi
    
    get_script_pkg $@
}

###################################################################################################
#name:get_golbaltool_apps_pkg
#func:全局工具获取业务包的函数，获取之前判断文件是否存在，如果所有的文件都存在则不需要获取
#arg1:保存的路径
#arg2:ftp配置文件名称
#arg3:sftp协议还是ftp协议
#arg4:是否需要解压
###################################################################################################
function get_golbaltool_apps_pkg
{
    typeset func_name="get_golbaltool_apps_pkg"    
    typeset config_file=$2
    typeset send_file_list=""
      
    if [ $# -lt 2 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    
    CUR_PATH=`pwd`
        
    #获取业务包名称列表
    read_value "${CUR_PATH}/${config_file}" "${PKG_FTP_FILE}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read value of \"${PKG_FTP_FILE}\" from \"${CUR_PATH}/${config_file}\" ${FAILED}!"
        return 1
    fi
    send_file_list="${RETURN[0]}"
    #去掉前后可能的双引号
    send_file_list=`echo ${send_file_list} | $AWK -F\" '{if ( $1=="" ) {print $2} else {print $1}}'`
    
    #判断是否需要发文件
    is_need_send_file "${send_file_list}"
    if [ $? -eq 0 ];then
        log_echo "info" "${func_name}" "The send files ${send_file_list} already existed, needn't send."
        return 0
    fi
    
    get_apps_pkg $@
}

function is_need_send_file
{
    typeset func_name="is_need_send_file"
    typeset send_file_list=$1
    if [ $# -lt 1 ];then
        log_echo "error" "${func_name}" "${PARAMETER_UNMATCHED}"
        return 1
    fi
    
    #判断文件是否存在
    typeset org_ifs=$IFS
    IFS=,
    for file_name in ${send_file_list}
    do
        #去掉前后空格，如果文件名称为空，继续处理下一个
        file_name=`echo ${file_name}`
        if [ "X${file_name}" = "X" ];then
            continue
        fi
         
        if [ ! -f "${file_name}" ];then
            IFS=${org_ifs}
            return 2
        fi
    done
    IFS=${org_ifs}
    
    return 0
}

#------------------------------------------------------
#判断指定的字符串是否是非负整数
#被check_fsys调用
#------------------------------------------------------
function is_integer
{
	#set -x
	typeset func_name="is_integer"
    if [ $# -ne 1 ];then
        log_echo "error" "${func_name}" "${PARA_UNMATCHED}"
        return 1
    fi
	typeset string=$1
	string=`echo ${string}`

    #检查字符串中是否含有非数字的字符
	nstring=`echo ${string} | $SED 's/[0-9][0-9]*//g'`
	nlen="`echo ${nstring} | $AWK '{print length($0)}'`"
	if [ "X${nlen}" != "X0" ]; then
	  	 log_echo "error" "${func_name}" "The number \"${string}\" is not a positive integer"
	  	 return 1
	else
#		nlen=${#string}
#		#最大的整数定为2147483647
#		#检查字符串长度是否大于10位
#		if [ ${nlen} -gt 10 ];then
#			log_echo "error" "${func_name}" "The number \"${string}\" overflow max_integer 2147483647"
#			return 1
#		fi
#		#检查字符串长度等于十位的时候是否大于最大整数
#		if [ ${nlen} -eq 10 ];then
#			if [[ ${string} > "2147483647" ]];then
#				log_echo "error" "${func_name}" "The number \"${string}\" overflow max_integer 2147483647"
#				return 1			
#			else
#				return 0
#			fi
#		#字符串长度小于十位的情况
#		else		
#			return 0	
#		fi	
        return 0
	fi
}

#Begin 2007-06-13
#------------------------------------------------------
#转换文件格式,将windows上文本文件转换成Unix上的文本文件
# tr Cd '\015' <xx.c >xx.new 或tr Cs '\015' '\n' <xx.c > xx.new
#------------------------------------------------------
function convert_files
{
    typeset func_name="convert_files"
    #判断参数是目录还是文件
    typeset param=$1
    typeset files=""
    typeset f=""
    typeset ret=0
    if [ -d ${param} ];then
        search_dir ${param}
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Search files under directory \"${param}\" ${FAILED}!"
            return 1
        fi
        files="${RETURN[0]}"
        for f in ${files}
        do
            convert ${f}
            if [ $? -ne 0 ];then
                log_echo "error" "${func_name}" "Change file format of \"${f}\" ${FAILED}!"
                ret=1
            fi
        done
        if [ ${ret} -eq 1 ];then
            return 1
        fi
    else
        #不是目录
        convert ${param}
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "Change file format of \"${file_name}\" ${FAILED}!"
            return 1
        fi
    fi
    return 0
}

function search_dir
{
    typeset func_name="search_dir"
    typeset dir_path="$1"
    typeset files=""
    files=`du -a ${dir_path}|$AWK '{print $2}'`
    RETURN[0]=${files}
    return 0
}

function convert
{
    typeset func_name="convert_file"
    typeset file_name="$1"
    #进行转换
    #如果传入的参数不是文件,直接返回
    if [ ! -f ${file_name} ];then
        return 0
    fi
    tr -d '\015' < ${file_name} >${file_name}_new
    if [ $? -ne 0 ];then
        return 1
    fi
    #删除旧文件,将更新的文件改名
    cat ${file_name}_new > ${file_name}
    if [ $? -ne 0 ];then
        return 1
    fi
    rm -rf ${file_name}_new 
    if [ $? -ne 0 ];then
        return 1
    fi
    return 0
}


#############################################
#创建超链接日志
#para1:err_msg,show on the log page,for click
#para2:err_url,a relative path for the help page
#############################################
function create_hyperlink_log
{
    typeset func_name="${create_hyperlink_log}"
    typeset err_msg=`echo "$1"`
    typeset err_url=`echo "$2"`
    typeset ideploypkgurl=${IDEPLOY_PKG_URL_FOR_HYPERLINK_LOG}
    
    #如果参数为空，则返回空
    if [ "X" = "X${err_msg}" -o "X" = "X${err_url}" ];then
        echo ""
    else
        #判断传入的url是否是以http或者https起始的路径，是则不对url拼接${IDEPLOY_PKG_URL_FOR_HYPERLINK_LOG}
        typeset tmp=`echo ${err_url} | ${AWK} -F: '{if ( $1 == "http" || $1 == "https" ) print $1}'`
        if [ "X${tmp}" != "X" ];then
            ideploypkgurl=""
        fi
        #实际打印的类似<a href="IDEPLOY_PKG_URL/a/b/c.html">(ERR-MSG:0009)</a>
        echo "${IDEPLOY_LINE_COLOR_LT}a onmouseover=\"this.style.cursor='hand';\" style=\"font-style:italic;font-weight:bold;color:blue;text-decoration:underline\" onclick=\"javascript:window.open(" "'""${ideploypkgurl}${err_url}""'" "," "'""_blank""'" ")\"${IDEPLOY_LINE_COLOR_GT}${err_msg}${IDEPLOY_LINE_COLOR_LT}/a${IDEPLOY_LINE_COLOR_GT}"
    fi
    
}
#End 2007-06-13 

#################################################################################
#创建错误日志超链接，出现see_all_error_logs时，turn_error_on.sh中查看原子操作汇总错误日志时使用
#para1:err_msg,show on the log page,for click
#para2:err_url,a relative path for the help page
#################################################################################
function create_hyperlink_error_log
{
    typeset func_name="${create_hyperlink_error_log}"
    typeset err_msg=`echo "$1"`
    typeset err_url=`echo "$2"`
    #typeset ideploypkgurl="see_all_error_logs"
    
    #如果参数为空，则返回空
    if [ "X" = "X${err_msg}" -o "X" = "X${err_url}" ];then
        echo ""
    else
	    #判断传入的url是否是以http或者https起始的路径，是则不对url拼接${IDEPLOY_PKG_URL_FOR_HYPERLINK_LOG}
        typeset tmp=`echo ${err_url} | ${AWK} -F: '{if ( $1 == "http" || $1 == "https" ) print $1}'`
        if [ "X${tmp}" != "X" ];then
            ideploypkgurl=""
        fi 
        #实际打印的类似<a href="IDEPLOY_PKG_URL/a/b/c.html">(ERR-MSG:0009)</a>
        echo "${IDEPLOY_LINE_COLOR_LT}a onmouseover=\"this.style.cursor='hand';\" style=\"font-style:italic;font-weight:bold;color:blue;text-decoration:underline\" onclick=\"javascript:window.open(" "'""${ideploypkgurl}${err_url}""'" "," "'""_blank""'" ")\"${IDEPLOY_LINE_COLOR_GT}${err_msg}${IDEPLOY_LINE_COLOR_LT}/a${IDEPLOY_LINE_COLOR_GT}"
    fi
    
}

#############################################
#创建超链接faq
#para1:err_msg,show on the log page,for click
#para2:err_url,a relative path for the help page
#############################################
function create_hyperlink_faq
{
    typeset func_name="${create_hyperlink_faq}"
    typeset err_msg=`echo "$1"`
    typeset err_url=`echo "$2"`
    typeset ideploypkgurl=${IDEPLOY_PKG_URL_FOR_HYPERLINK_FAQ}
    
    #如果参数为空，则返回空
    if [ "X" = "X${err_msg}" -o "X" = "X${err_url}" ];then
        echo ""
    else
        #判断传入的url是否是以http或者https起始的路径，是则不对url拼接${IDEPLOY_PKG_URL_FOR_HYPERLINK_FAQ}
        typeset tmp=`echo ${err_url} | ${AWK} -F: '{if ( $1 == "http" || $1 == "https" ) print $1}'`
        if [ "X${tmp}" != "X" ];then
            ideploypkgurl=""
        fi
        #实际打印的类似<a href="IDEPLOY_PKG_URL/a/b/c.html">(ERR-MSG:0009)</a>
        echo "${IDEPLOY_LINE_COLOR_LT}a onmouseover=\"this.style.cursor='hand';\" style=\"font-style:italic;font-weight:bold;color:blue;text-decoration:underline\" onclick=\"javascript:window.open(" "'""${ideploypkgurl}${err_url}""'" "," "'""_blank""'" ")\"${IDEPLOY_LINE_COLOR_GT}${err_msg}${IDEPLOY_LINE_COLOR_LT}/a${IDEPLOY_LINE_COLOR_GT}"
    fi
    
}


#实现cofigure file 的访问和修改功能，供shell文件包含

#####################BEGIN Of Interface############################

#cfg_is_exist_sec			在段键格式文件中是否存在一个段
#cfg_get_sec_names			返回段键配置文件的多个段的名字
#cfg_get_sec_value			返回段键格式某个段下的值(包含键名并去掉注释)
#cfg_is_exist_sec_key		在段键格式文件中查找一个段下的键是否存在
#cfg_add_sec_key			在段键格式文件中的某个字段下添加一个key
#cfg_get_sec_key_value		在段键格式文件中获取一个段下的键的值(如果键有多个则返回第一个值)
#cfg_get_sec_key_values     在段键格式文件中获取一个段下的键的值(如果键有多个则返回多个值)
#cfg_update_sec_key_value	向段键配置文件中更新某个配置项
#cfg_get_sec_key_names		返回段键格式中某个段中的所有键名
#cfg_write_sec_key_value	写入一个键(键不存在添加,存在则覆盖)(是组合操作,组合update和add操作)
#cfg_update_ini             用source_file中键的值替换dest_file中相应键的值
###################END Of Interface #####################################



####################BEGIN OF DEPEND ON ##################################
#file.inc
#err.inc
#env.inc
#file.inc
#ret.inc
################### END OF DEPEND ON ####################################


###################################ret.in BEGIN##############################
#实现返回值功能，供shell文件包含
#ret.inc
#interface:
#ret_init		初始化RETURN数组,清空RETURN数组的元素的值
#ret_set_num	设置RETURN数组的项数
#ret_set_one	设置第一个参数RETURN[0]的值
#############################################################################

#使用例子:
#  在被调用函数中:
#		called_function()
#		{
#			....  
#			ret_init
#			ret_set_num	2 	#有两个变量
#			RETURN[0]="output1"
#			RETURN[1]="output2"
#			return 0
#		}
#  在调用函数中:
#		called_function
#		if [ $? -ne 0 ]; then
#			#此处可通过RETNUM和RETURN获取返回的信息
#		fi
###############################################################
#   Name:          ret_init
#   Description:    初始化RETURN数组,清空RETURN数组的元素的值
#   input:	无
#   output:	无
#   return:
#		$SUCC 成功
################################################################
function ret_init
{
	typeset i=0
	
	ret_clear

	RETNUM=0		# 数组的元素个数
	RETURN[0]=""		# 数组
	return $SUCC
}

###############################################################
#   Name:          ret_set_num
#   Description:   设置RETURN数组的项数
#   input:
#  		   1. number 项数
#   output:	   无
#   return:
#   	           $SUCC 			成功 
#	           $ERR_TYP_NOT_INTEGER 	不是整型数据
#	           $PARA_ERROR 			参数错误 
################################################################
function ret_set_num
{
	if [ $# -ne 1 ];then
		return $PARA_ERROR
	fi
	assert_not_empty "$1"
	
	typeset  number="$1"
	
	is_integer $number
	if [ $? -ne 0 ]; then
		return $ERR_TYP_NOT_INTEGER
	fi
	assert_not_negative "$number"  "ret_set_num:ret number isn't negative"

	
	#清空数组
	ret_clear
		
	RETNUM="$number"
	if [ "-$RETNUM" = "-" ]; then
		RETNUM=1
	fi
	return $SUCC
}

###############################################################
#   Name:          ret_clear
#   Description:   清空RETURN数组
#   input:	   无
#   output:	   无
#   return:
#   	           $SUCC: 成功
################################################################
function ret_clear
{
	typeset i=0
	# 清空数组
	if [ "-$RETNUM" != "-" ]; then
		while [ $i -lt $RETNUM ]
		do
			RETURN[i]=""
			((i=i+1))
		done
	fi	
	return $SUCC
}

###############################################################
#   Name:          ret_set_one
#   Description:   设置第一个参数RETURN[0]的值
#   input:  1.参数值value
#   output: 第一个参数RETURN[0]
#   return:
#   	$SUCC: 		成功
#	$PARA_ERROR 	参数错误
################################################################
function ret_set_one
{
	if [ $# -ne 1 ];then
		return $PARA_ERROR
	fi
	#assert_not_empty "$1"
		
	typeset  value="$@"
	
	ret_clear
	ret_set_num  1
	RETURN[0]="$value"
	
	return $SUCC	
}
###########################ret.inc END############################

############################func.inc BEGIN###############################
#########################################################################
#调用函数和外部命令,不需要/无法跟踪函数或外部命令内部的执行过程时使用
#函数名：func_exec_func
#input:
#  1. cmd   函数名/命令名
#  *. paras 参数
#########################################################################
function func_exec_func
{
	typeset	cmd="$1"	#待执行命令名
	typeset ret=""
		
	shift 1
	 
	# 命令不能为空
	assert_not_empty  "$cmd"
			
	#执行命令
	$cmd "$@"
	ret=$?
		
	#返回命令执行结果
	return $ret
}
############################func.inc END###############################

############################file.inc BEGIN#############################
###############################################################################################
#实现file的操作功能，供shell文件包含  
# Interface:
#  file_is_exist                 判断文件是否存在 
#  file_get_lines_count          返回文件的行数
#  file_replace_line_by_number   将文件的第n行替换为传入的字符串
#  file_replace_line_by_exp      查找传入的表达式,得到行数n,将文件的第n行替换为传入的字符串
#  file_insert_line              在文件指定行前插入指定字符串
#  file_delete_line              删除文件指定行
#  file_select_line              返回指定表达时所在行
#  file_get_owner                返回文件的属主
#  file_set_owner                设置文件属主
#  file_is_executive             判断文件相对于某个用户是否可执行
#  file_is_readable              判断文件相对于某个用户是否可读
#  file_is_writeable             判断文件相对于某个用户是否可写
#  file_create                   创建一个指定文件
#  file_create_dir               创建一个指定目录
#  file_copy                     拷贝文件(保证属主/属性)
#  file_copy_dir                 拷贝目录(保证属主/属性)  
#  file_dir_is_exist             判断目录是否存在
#  file_grep                     返回符合表达式的所有行,即平时的 grep "exp" file 功能
#  file_get_content              返回文件中所有行,要考虑行数过多的处理情况(比如5万行)
#  file_get_content_filter_note  返回文件中所有非注释行(注释符号由调用者当参数传入)
#  file_append_line              在文件尾部添加一行(保证属主/属性)
#  file_get_size                 获取文件大小,bytes
#################################################################################################

##############################################################
#   Name:           file_is_exist()
#   Description:    判断文件是否存在
#   Input:          
#		1.	file name
#		 
#   Output: 
#		
#   Return:  
#       YES--文件存在 
#		NO--文件不存在
#		PARA_ERROR
##############################################################
function file_is_exist
{
	if [ $# -ne 1 ];then
		return $PARA_ERROR
	fi
	typeset file="$1"
	
		
	#检查参数是否为空
	assert_not_empty  "$file" "File name is null!"
	
	#判断文件是否为空
	if [ -f "$file" ]
	then
		return "${YES}"
	else
		return "${NO}"
	fi
}

##############################################################
#   Name:           file_get_lines_count()
#   Description:    返回文件的行数
#   Input:          
#		1.	file name
#		 
#   Output: 
#		        RETURN[0](文件行数)
#   Return:     SUCC--正常 
#		        ERR_FILE_GET_LINES_ERROR--获取文件行数错误
#				PARA_ERROR--------参数个数错误
#				ERR_FILE_NOT_EXIST--文件不存在
##############################################################
function file_get_lines_count
{
    if [ $# -ne 1 ]
    then
    	return $PARA_ERROR
    fi
    
    typeset file="$1"	
	if [ ! -f $file ]
	then
		return $ERR_FILE_NOT_EXIST
	fi
		
	#获取文件行数
	typeset lines_count=`cat "$file" 2>${IDEPLOY_NULL} | wc -l 2>${IDEPLOY_NULL}`	
	if [ $? -ne 0 ]
	then
	    return ${ERR_FILE_GET_LINES_ERROR}
	fi
	lines_count=`echo $lines_count`
	
	ret_set_one "${lines_count}"	
	return "${SUCC}"
}

##############################################################
#   Name:           file_get_line_num_by_str()
#   Description:    返回文件的行数
#   Input:          
#		1.	file name
#		2.      string
#   Output: 
#		        RETURN[0] RETURN[1] RETURN[2] ....(被找到的匹配字符串的行的line number)
#			RETNUM   (文件行数)
#   Return:     SUCC--正常 
#		        ERR_FILE_GET_LINES_ERROR--获取文件行数错误
#				PARA_ERROR--------参数个数错误
#				ERR_FILE_NOT_EXIST--文件不存在
##############################################################

function file_get_line_number_by_str
{
	typeset no=""
	typeset exp_str=""
	typeset str=""

	file_name="$1"
	exp_str="$2"
	shift 
	shift
	str="$@"	#(参数的剩余部分均是传入的字符串）	
	
	#检查参数是否为空，及文件是否存在
	assert_not_empty  "$file_name"
	assert_not_empty  "$exp_str"
	#assert_file_exist "$file_name"

	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return "${ERR_FILE_NOT_EXIST}"
	fi	
		
	# 修改 
	# 如果该行为注释，则输出空行，（这样可以保持行数不变）
	#no=`cat $file_name | ${AWK} '{if($0 ~ /^[ 	]*#/ ) {print "";}else{print $0;}}' | ${SED} -n "/$exp_str/=" | ${SED} -n '1p'`
	no_list=`cat $file_name  | ${SED} -n "/$exp_str/=" | ${AWK} '{printf("%s ",$1);}'`
	if [ "X$no_list" = "X" ]; then		
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	
	typeset -i line_sum=0
	for num in $no_list
	do
		RETURN[$line_sum]=$num
		((line_sum+=1))
	
	done
	RETNUM=$line_sum
	
	return 0


}

##############################################################
#   Name:           file_replace_line_by_number()
#   Description:    替换指定行号的号
#   Input:          
#		1.	file name
#		2.  line no
#       3.  express string
#   Output: 
#		
#   Return:     SUCC--正常 
#		        ERR_FILE_NOT_EXIST--文件不存在
#               ERR_FILE_GET_LINES_ERROR--获取文件行数失败
#               ERR_FILE_LINENO_TOO_GREAT--文件行数过大 
#               ERROR--未知错误
##############################################################
function file_replace_line_by_number
{
	typeset file_name="$1"
	typeset line_no="$2"
	shift
	shift
	typeset str="$@"	#(参数的剩余部分均是传入的字符串）
	
	typeset max_line=""
	typeset tmp_file=""
	typeset no=""
	
	#检查参数是否为空，及文件是否存在
	assert_not_empty  "$file_name"
	assert_not_empty  "$line_no"
	assert_not_empty  "$str"
	#assert_file_exist "$file_name"
	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return "${ERR_FILE_NOT_EXIST}"
	fi
	
	is_integer "$line_no"
	if [ $? -ne 0 ]
	then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	
	if [ $line_no -lt 1 ];then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	
	#获取文件行数
	func_exec_func file_get_lines_count "$file_name"
	if [ $? -ne 0 ]; then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	max_line=`echo ${RETURN[0]}`
	
	if [ $line_no -gt $max_line ]; then		
		return "${ERR_FILE_LINENO_TOO_GREAT}"
	fi
	
	# 如果文件只有一行
	if [ "$max_line" -eq 1 ]; then
		echo "$str" > $file_name
		return "${SUCC}"
	fi
	
#	file_new_tmp
#	tmp_file="${RETURN[0]}"
	# 问题单a01d85894   安装过程临时文件过多   修改开始
	cat << HERE | ed $file_name 1>${IDEPLOY_NULL} 2>&1
	#cat << HERE | ed $file_name #>${IDEPLOY_NULL} 2>$tmp_file
$line_no
c
$str
.
w
q
HERE
	
#	is_error_exist=`cat $tmp_file | wc -w | ${AWK} '{print $1}'`
#	if [ $is_error_exist -gt 0 ];then
#		return "${ERROR}"
#	fi
        # 问题单a01d85894   安装过程临时文件过多   修改开始

	return "${SUCC}"
}
##############################################################
#   Name: file_replace_line_by_exp          
#   Description: 替换包含特定字符串的行   
#   Input:          
#		1.	file name
#		2.  express string(要替换行包含的特征字符串)
#       3.  express string(要替换的字符串)
#		 
#   Output: 
#		
#   Return:  
#       SUCC--正常 
#       ERR_FILE_NOT_EXIST--文件不存在
#		ERR_FILE_GET_LINES_ERROR--获取文件行数错误
#
##############################################################
function file_replace_line_by_exp
{
	typeset no=""
	typeset exp_str=""
	typeset str=""

	file_name="$1"
	exp_str="$2"
	shift 
	shift
	str="$@"	#(参数的剩余部分均是传入的字符串）	
	
	#检查参数是否为空，及文件是否存在
	assert_not_empty  "$file_name"
	assert_not_empty  "$exp_str"
	#assert_file_exist "$file_name"

	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return "${ERR_FILE_NOT_EXIST}"
	fi	
		
	# 修改 
	# 如果该行为注释，则输出空行，（这样可以保持行数不变）
	#no=`cat $file_name | ${AWK} '{if($0 ~ /^[ 	]*#/ ) {print "";}else{print $0;}}' | ${SED} -n "/$exp_str/=" | ${SED} -n '1p'`
	no_list=`cat $file_name  | ${SED} -n "/$exp_str/=" | ${AWK} '{printf("%s ",$1);}'`
	if [ "X$no_list" = "X" ]; then		
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	##把找到的行数替换
	for no in $no_list
	do
		file_replace_line_by_number  "$file_name"   "$no"   "$str"
		ret=$?
	done
	
	return "${ret}"
}
##########################################################################
#函数名: file_insert_line()
#
#功能: 在文件指定行前插入指定字符串
#输入:  1. file name 
#       2. line no 
#       3. expr string
#	    
#输出: 
#     无
#返回: 
#     SUCC--正常 
#	  ERR_FILE_NOT_EXIST--文件不存在
#	  ERR_FILE_GET_LINES_ERROR－－获取行号错误，或者给出的行号参数有误
#########################################################################
function file_insert_line
{	
	typeset file_name=$1
	typeset line_no=$2
	typeset expr_str=$3
	
	#检查参数是否为空，及文件是否存在
	assert_not_empty  "$file_name"
	assert_not_empty  "$line_no"
	assert_not_empty  "$expr_str"
	
	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return "${ERR_FILE_NOT_EXIST}"
	fi	
	
	is_integer $line_no
	if [ $? -ne 0 ];then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	
	#获取文件行数
	func_exec_func file_get_lines_count "$file_name"
	if [ $? -ne 0 ]; then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	max_line=`echo ${RETURN[0]}`
		
	if [ $line_no -lt 1 -o $line_no -gt `expr $max_line + 1` ];then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	
	if [ $line_no -le $max_line ]; then
		cat << HERE | ed $file_name >${IDEPLOY_NULL} 2>&1
$line_no
i
$expr_str
.
w
q
HERE
	else
		echo $expr_str >> $file_name
	fi
	
	if [ $? -ne 0 ];then
	     return "${FAILURE}"
	fi
	
    return "${SUCC}"	
}

##############################################################
#   Name: file_delete_line          
#   功能: 删除文件指定行
#   输入:  1. file name 
#          2. line no 
#	    
#   输出: 
#          无
#   返回: 
#          SUCC--正常 
#          ERR_FILE_SED_PRINT--用sed命令打印文件失败
#          ERR_FILE_NOT_EXIST
#		   ERR_FILE_GET_LINES_ERROR
##############################################################
function file_delete_line
{
    typeset file_name=$1
	typeset line_no=$2
	typeset max_line=""
	typeset line_no_aft=0
	typeset line_no_bef=0
	
	#检查参数是否为空，及文件是否存在
	assert_not_empty  "$file_name"
	assert_not_empty  "$line_no"

	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return "${ERR_FILE_NOT_EXIST}"
	fi	
	
	is_integer $line_no
	if [ $? -ne 0 ];then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	
	#获取文件行数
	func_exec_func file_get_lines_count "$file_name"
	if [ $? -ne 0 ]; then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	max_line=`echo ${RETURN[0]}`
		
	if [ $line_no -lt 1 -o $line_no -gt $max_line ];then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	
	cat << HERE | ed $file_name >${IDEPLOY_NULL} 2>&1
$line_no
d
w
q
HERE

	if [ $? -ne 0 ];then
	     return "${FAILURE}"
	fi
	
	return "${SUCC}"	
}
##############################################################
#   Name: file_select_line          
#   Description: 返回包含特征字符串的行的行号(多行的话,只返回第-行)   
#   Input:          
#		1.	file name
#		2.  express string(待查找行包含的特征字符串)
#   Output: 
#		   RETURN[0](包含特征字符串的行的行号)
#   Return:  
#       SUCC--成功 
#		ERR_GET_LINE_NO--获取文件行号失败
#		ERR_CFG_FILE_NOT_EXIST--文件不存在
#
##############################################################
function file_select_line
{
    typeset file_name=$1
    typeset expr_str=$2
    
    #检查参数是否为空，及文件是否存在
	assert_not_empty  "$file_name"
	assert_not_empty  "$expr_str"
	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return ${ERR_CFG_FILE_NOT_EXIST}
	fi
	
	#获取包含特定字符串的行号
	line_no=`cat "${file_name}" | ${GREP} -n "$expr_str" | ${SED} -n '1p' | ${AWK} -F: '{print $1}'`
	if [ "X$line_no" = "X" ]
	then
	    return "${ERR_GET_LINE_NO}"
	fi
	line_no=`echo $line_no`
	
	ret_set_one "${line_no}"
	return "${SUCC}"
}
##############################################################
#   Name:  file_get_owner         
#   Description: 返回指定文件   
#   Input:          
#		1.	file name
#		 
#   Output: 
#		   RETURN[0](文件属主)
#          RETURN[1](文件所属群)
#   Return:  
#       SUCC--正常 
#		ERR_FILE_GET_OWNER_FAIL--获取文件属主失败
#       ERR_FILE_GET_GROUP_FAIL--获取文件所属组失败
#
##############################################################
function file_get_owner
{	
	if [ $# -ne 1 ]
	then
		return $PARA_ERROR
	fi
	
	typeset file=$1
	
	if [ ! -f $file -a ! -d $file ]
	then
		return $ERR_FILE_NOT_EXIST
	fi
	
	typeset owner
	typeset group
	
	#检查参数是否为空，及文件是否存在
	assert_not_empty  "$file"
	assert_file_exist "$file"	
	
	#获取文件属主
	owner=`ls -dl "$file" 2>${IDEPLOY_NULL} | ${AWK} '{print $3}' 2>${IDEPLOY_NULL}`
	if [ "X$owner" = "X" ]
	then
	    return "${ERR_FILE_GET_OWNER_FAIL}"
	fi
	group=`ls -dl "$file" 2>${IDEPLOY_NULL} | ${AWK} '{print $4}' 2>${IDEPLOY_NULL}`
	if [ "X$group" = "X" ]
	then
	    return "${ERR_FILE_GET_GROUP_FAIL}"
	fi
	
	ret_set_num 2
	RETURN[0]="$owner"
	RETURN[1]="$group"
	return "${SUCC}"
}
##############################################################
#   Name: file_set_owner          
#   Description: 设置文件属主和组
#   Input:          
#		1.	file name
#		2.  file owner
#       3.  file group
#   Output: 
#		
#   Return:  
#       SUCC--修改成功
#       ERR_FILE_CHG_OWNER_FAIL--改变文件属主错误
##############################################################
function file_set_owner
{
    typeset file=$1
    typeset owner=$2
    typeset group=$3
	
	#检查参数是否为空，及文件是否存在
    assert_not_empty   "$file"
    assert_not_empty   "$owner"
    assert_not_empty   "$group"
	assert_file_exist  "$file"	
	assert_user_exist  "$owner"
	assert_group_exist "$group"
	
	#修改文件属主
	chown "${owner}:${group}" "$file"
	if [ $? -ne 0 ]
	then
	    return "${ERR_FILE_CHG_OWNER_FAIL}"
	fi	
	return "${SUCC}"	
}

##############################################################
#   Name: file_is_executive           
#   Description: 判断文件相对于某个用户是否可执行   
#   Input:          
#		1.	file name
#		2.  user name  
#   Output: 
#		
#   Return:  
#		YES--可执行
#       NO--不可执行
#		ERROR--- 错误
##############################################################              
function file_is_executive
{
    typeset file_name=$1 
    typeset usr_name=$2
    typeset owner_name=""
    typeset user_group=""
    typeset attr=""
     
    #检查参数是否为空，及文件是否存在
    assert_not_empty  "$file_name"
	assert_not_empty  "$usr_name"
	assert_file_exist "$file_name"
	
	#返回文件属性
	typeset tmp=`ls -dl "$file_name" 2>${IDEPLOY_NULL} | ${AWK} '{print $1}' 2>${IDEPLOY_NULL}`
	tmp=`echo $tmp | tr -d 's'`
	
	#判断用户是否为root
	if [ "X$usr_name" = "Xroot" ]
	then
	    
	    return "${YES}"
	fi
	
	#获取文件属主
	func_exec_func file_get_owner "$file_name"
	ret=$?
	if [ "$ret" -ne 0 ]
	then
	    return "$ERROR"
	fi
    owner_name="${RETURN[0]}"
    group_name="${RETURN[1]}"

	#debug note
	#返回用户所属组 //该函属还未实现
	user_get_user_group "$usr_name"
	if [ $? -ne 0 ]
	then
	    return $ERROR
	fi
	user_group="${RETURN[0]}"

	#判断用户属性
	if [ "X$usr_name" = "X$owner_name" ]
	then
	    #属主
	    attr=0  
	elif [ "X$user_group" = "X$group_name" ]
	then
	    #组
	    attr=1
  	else
  	    #其它
  	    attr=2
  	fi

	case $attr in
	0)
	  #当用户为属主时，判断文件相对其是否可写
	  func_exec_func str_mid "$tmp"  "4"  "1"
	  ret=$?
	  if [ "$ret" -ne 0 ]
	  then
	      return "$ERROR"
	  fi
	  mark="${RETURN[0]}"	
	  if [ "X$mark" = "Xx" ]
	  then
	      return "${YES}"
	  else
	      return "${NO}"
	  fi
	  ;;
	1)
	  #当用户为组时，判断文件相对其是否可写
	  func_exec_func str_mid "$tmp"  "7"  "1"
	  ret=$?
	  if [ "$ret" -ne 0 ]
	  then
	      return "$ERROR"
	  fi
	  mark="${RETURN[0]}"	
	  if [ "X$mark" = "Xx" ]
	  then
	      return "${YES}"
	  else
	      return "${NO}"
	  fi
	  ;;
	2)
	  #当用户为其他时，判断文件相对其是否可写
	  func_exec_func str_mid "$tmp" "10"  "1"
	  ret=$?
	  if [ "$ret" -ne 0 ]
	  then
	      return "$ERROR"
	  fi
	  mark="${RETURN[0]}"	
	  if [ "X$mark" = "Xx" ]
	  then
	      return "${YES}"
	  else
	      return "${NO}"
	  fi
	  ;;
	*)
	   :
	esac  
	return "${ERROR}"	
}
##############################################################
#   Name: file_is_writeable          
#   Description: 判断文件相对于某个用户是否可写    
#   Input:          
#		1.	file name
#		2.  user name
#   Output: 
#		
#   Return:  
#		YES--可写
#       NO--不可写
#       ERROR--错误
##############################################################
function file_is_writeable
{   
    typeset file_name=$1 
    typeset usr_name=$2
    typeset owner_name=""
    typeset user_group=""
    typeset attr=""

    #检查参数是否为空，及文件是否存在
    assert_not_empty  "$file_name"
	assert_not_empty  "$usr_name"
	assert_file_exist "$file_name"
	
	#返回文件属性
	typeset tmp=`ls -dl "$file_name" 2>${IDEPLOY_NULL} | ${AWK} '{print $1}' 2>${IDEPLOY_NULL}`
	tmp=`echo $tmp | tr -d 's'`
	
	#判断用户是否为root
	if [ "X$usr_name" = "Xroot" ]
	then
	    return "${YES}"
	fi
	
	#获取文件属主
	func_exec_func file_get_owner "$file_name"
	if [ "$?" -ne 0 ]
	then
	    return "$ERROR"
	fi
    owner_name="${RETURN[0]}"
    group_name="${RETURN[1]}"

	#返回用户所属组 
	user_get_user_group "$usr_name"
	if [ $? -ne 0 ]
	then
	    return $ERROR
	fi
	user_group="${RETURN[0]}"

	
	#判断用户属性
	if [ "X$usr_name" = "X$owner_name" ]
	then
	    #属主
	    attr=0  
	elif [ "X$user_group" = "X$group_name" ]
	then
	    #组
	    attr=1
  	else
  	    #其它
  	    attr=2
  	fi

	case $attr in
	0)
	  #当用户为属主时，判断文件相对其是否可写
	  func_exec_func str_mid "$tmp"  "3"  "1"
	  ret=$?
	  if [ "$ret" -ne 0 ]
	  then
	      return "$ERROR"
	  fi
	  mark="${RETURN[0]}"	
	  if [ "X$mark" = "Xw" ]
	  then
	      return "${YES}"
	  else
	      return "${NO}"
	  fi
	  ;;
	1)
	  #当用户为组时，判断文件相对其是否可写
	  func_exec_func str_mid "$tmp"  "6"  "1"
	  ret=$?
	  if [ "$ret" -ne 0 ]
	  then
	      return "$ERROR"
	  fi
	  mark="${RETURN[0]}"	
	  if [ "X$mark" = "Xw" ]
	  then
	      return "${YES}"
	  else
	      return "${NO}"
	  fi
	  ;;
	2)
	  #当用户为其他时，判断文件相对其是否可写
	  func_exec_func str_mid "$tmp" "9"  "1"
	  ret=$?
	  if [ "$ret" -ne 0 ]
	  then
	      return "$ERROR"
	  fi
	  mark="${RETURN[0]}"	
	  if [ "X$mark" = "Xw" ]
	  then
	      return "${YES}"
	  else
	      return "${NO}"
	  fi
	  ;;
	*)
	   return "${ERROR}"
	esac  
	return "${ERROR}"	
}
##############################################################
#   Name: file_is_readable          
#   Description: 判断文件相对于某个用户是否可读    
#   Input:          
#		1.	file name
#		2.  user name
#   Output: 
#		
#   Return:  
#		YES--可读
#       NO--不可读
#       ERROR--错误
##############################################################
function file_is_readable
{   
    typeset file_name=$1 
    typeset usr_name=$2
    typeset owner_name=""
    typeset user_group=""
    typeset attr=""
     
    #检查参数是否为空，及文件是否存在
    assert_not_empty  "$file_name"
	assert_not_empty  "$usr_name"
	assert_file_exist "$file_name"
	
	#返回文件属性
	typeset tmp=`ls -dl "$file_name" 2>${IDEPLOY_NULL} | ${AWK} '{print $1}' 2>${IDEPLOY_NULL}`
	tmp=`echo $tmp | tr -d 's'`
	
	#判断用户是否为root
	if [ "X$usr_name" = "Xroot" ]
	then
	    return "${YES}"
	fi
	
	#获取文件属主
	func_exec_func file_get_owner "$file_name"
	if [ $? -ne 0 ]
	then
	    return "$ERROR"
	fi
    owner_name="${RETURN[0]}"
    group_name="${RETURN[1]}"
  	
	#返回用户所属组
	user_get_user_group "$usr_name"
	if [ $? -ne 0 ]
	then
	    return $ERROR
	fi
	user_group="${RETURN[0]}"
	
	#判断用户属性
	if [ "X$usr_name" = "X$owner_name" ]
	then
	    #属主
	    attr=0
	elif [ "X$user_group" = "X$group_name" ]
	then
	    #组
	    attr=1
  	else
  	    #其它
  	    attr=2
  	fi

	case $attr in
	0)
	  #当用户为属主时，判断文件相对其是否可写
	  func_exec_func str_mid "$tmp"  "2"  "1"
	  ret=$?
	  if [ "$ret" -ne 0 ]
	  then
	      return "$ERROR"
	  fi
	  mark="${RETURN[0]}"	
	  if [ "X$mark" = "Xr" ]
	  then
	      return "${YES}"
	  else
	      return "${NO}"
	  fi
	  ;;
	1)
	  #当用户为组时，判断文件相对其是否可写
	  func_exec_func str_mid "$tmp"  "5"  "1"
	  ret=$?
	  if [ "$ret" -ne 0 ]
	  then
	      return "$ERROR"
	  fi
	  mark="${RETURN[0]}"	
	  if [ "X$mark" = "Xr" ]
	  then
	      return "${YES}"
	  else
	      return "${NO}"
	  fi
	  ;;
	2)
	  #当用户为其他时，判断文件相对其是否可写
	  func_exec_func str_mid "$tmp"  "8"  "1"
	  ret=$?
	  if [ "$ret" -ne 0 ]
	  then
	      return "$ERROR"
	  fi
	  mark="${RETURN[0]}"	
	  if [ "X$mark" = "Xr" ]
	  then
	      return "${YES}"
	  else
	      return "${NO}"
	  fi
	  ;;
	*)
	   RETURN $ERROR
	esac  
	return "${ERROR}"
}
##############################################################
#   Name: file_create          
#   Description: 创建一个文件   
#   Input:          
#		1.	file name
#		2.  overwrite(如果文件已经存在，是否覆盖(0:不覆盖, 1:覆盖))
#   Output: 
#		
#   Return:  
#       SUCC--成功
#       ERR_FILE_ALREADY_EXIST=文件已经存在,且不覆盖
#		ERROR----创建文件错误
#
##############################################################
function file_create
{
    typeset file_name=$1
	typeset overwrite=$2
	
	#检查参数是否为空，及文件是否存在
	assert_not_empty  "$file_name"
	assert_not_empty  "$overwrite"

    #判断文件是否存在
	func_exec_func file_is_exist "$file_name"
	typeset ret=$?
	#文件存在且覆盖
	if [ "$ret" -eq 0 -a "X$overwrite" = "X1" ]
	then
	    func_exec_func file_delete "$file_name"
	    ret=$?
	    if [ "$ret" -ne 0 ]
	    then
	        return "$ret"
	    fi
	    touch "$file_name"
	  
	#文件存在且不覆盖
	elif [ "$ret" -eq 0 -a "X$overwrite" = "X0" ]
	then
	    return "${ERR_FILE_ALREADY_EXIST}"
	#文件不存在
	else
		
		if [ `echo $file_name | ${GREP} -c "/"` -gt 0 ];then
			father_dir=`dirname $file_name`
			file_dir_is_exist $father_dir
			ret_dir=$?
			if [ $ret_dir -ne 0 ];then
				file_create_dir "$father_dir" "1"
				if [ $? -ne 0 ];then
					return $?
				fi			
			fi
			touch "$file_name"
			if [ $? -ne 0 ];then
				return $ERROR
			fi	
			
		fi
	    return "${SUCC}"	 
	fi
}
##############################################################
#   Name: file_create_dir          
#   Description: 创建一个目录  
#   Input:          
#		1.	file name
#		2.  overwrite(如果文件已经存在，是否覆盖(0:不覆盖, 1:覆盖))
#   Output: 
#		
#   Return:  
#       SUCC--创建成功 
#		ERR_FILE_ALREADY_EXIST--目录已经存在,且不覆盖
#
##############################################################                  
function file_create_dir
{
	
    typeset dir_name=$1
	typeset overwrite=$2
	
	#检查参数是否为空
	assert_not_empty  "$dir_name"
	assert_not_empty  "$overwrite"
	
	#判断目录是否存在
	func_exec_func file_dir_is_exist "$dir_name"
	typeset ret=$?
	#目录存在且覆盖
	if [ "$ret" -eq 0 -a "X$overwrite" = "X1" ]
	then
	    func_exec_func file_rm_dir "$dir_name" 2>${IDEPLOY_NULL}
	    ret=$?
	    if [ "$ret" -ne 0 ]
	    then
	        return "$ret"
	    fi
	    mkdir -p "$dir_name"     #2>${IDEPLOY_NULL}
	    if [ $? -ne 0 ]
	    then
            return "${ERR_FILE_MKDIR_FAIL}"	    
	    fi
	    return "${SUCC}"	   
	#目录存在且不覆盖
	elif [ "$ret" -eq 0 -a "X$overwrite" = "X0" ]
	then
	    return "${ERR_FILE_ALREADY_EXIST}" 
	#目录不存在
	else
	    mkdir -p "$dir_name" #2>${IDEPLOY_NULL}
	    if [ $? -ne 0 ]
	    then
	        return "${ERR_FILE_MKDIR_FAIL}"
	    fi
	    return "${SUCC}"
	fi  		
}
##############################################################
#   Name: file_copy          
#   Description: 拷贝文件时,保持源文件属性不变    
#   Input:          
#		1.	source file
#		2.  destination file
#       3.  0 或 1(当目标文件存在时，是否覆盖，1表示覆盖，0表示不覆盖) 
#   Output: 
#		
#   Return:  
#       SUCC--正常 
#		ERR_FILE_ALREADY_EXIST--文件存在且不覆盖
#       ERR_FILE_CP_FAIL--文件拷贝失败
#		PARA_ERROR 参数个数错误
#		ERR_FILE_NOT_EXIST  --文件不存在
##############################################################
function file_copy
{
    if [ $# -ne 3 ];then
    	return $PARA_ERROR
    fi   
    
    typeset src=$1
	typeset des=$2
	typeset overwrite=$3
	
	if [  ! -f $src ];then
		return $ERR_FILE_NOT_EXIST
	fi
	
	if [ $overwrite != "0" -a $overwrite != "1" ];then
		return $PARA_ERROR
	fi
			
	assert_not_empty  "$src"
	assert_not_empty  "$des"
	assert_not_empty  "$overwrite"
	assert_file_exist "$src"
	
	func_exec_func file_is_exist "$des"
	# ret忘了赋值
	ret=$?
	if [ $ret -eq 0 -a "X$overwrite" = "X1" ]
	then
	    cp -p "$src" "$des" 2>${IDEPLOY_NULL}
	    if [ $? -ne 0 ]
	    then
	        return "${ERR_FILE_CP_FAIL}"
	    fi
	    return "${SUCC}"
	elif [ "$ret" -eq 0 -a "X$overwrite" = "X0" ]
	then
	    return "${ERR_FILE_ALREADY_EXIST}"	 
	else
	    cp -p "$src" "$des" 2>${IDEPLOY_NULL}
	    if [ $? -ne 0 ]
	    then
	        return "${ERR_FILE_CP_FAIL}"
	    fi
	fi
	
    return "${SUCC}"
}
##############################################################
#   Name: file_copy_dir          
#   Description: 拷贝目录时,保持源目录属性不变    
#   Input:          
#		1.	source dir
#		2.  destination dir
#       3.  0 或 1(当目标文件存在时，是否覆盖，1表示覆盖，0表示不覆盖) 
#   Output: 
#		
#   Return:  
#       SUCC--正常 
#		ERR_FILE_ALREADY_EXIST--文件存在且不覆盖
#       ERR_CP_DIR_FAIL--文件拷贝失败
#		PARA_ERROR 参数个数错误
#		ERR_DIR_NOT_EXIST  --文件不存在
##############################################################
function file_copy_dir
{

	if [ $# -ne 3 ];then
    	return $PARA_ERROR
    fi   
    
    typeset src=$1
	typeset des=$2
	typeset overwrite=$3
	
	if [ ! -d $src  ];then
		return $ERR_DIR_NOT_EXIST
	fi
	
	if [ $overwrite != "0" -a $overwrite != "1" ];then
		return $PARA_ERROR
	fi
	
	
	func_exec_func file_dir_is_exist "$des"
	#ret忘了赋值
	reta=$?
	if [ $reta -eq 0 -a "X$overwrite" = "X1" ]
	then
	    func_exec_func file_rm_dir "$des"
	    ret=$?
	    if [ "$ret" -ne 0 ]
	    then
	        return "$ret"
	    fi
	    cp -pr "$src" "$des"
	    if [ $? -ne 0 ]
	    then
	        return "${ERR_CP_DIR_FAIL}"
	    fi
	    return "${SUCC}"
	#ret忘了赋值 使用了不对的ret变量
	elif [ "$reta" -eq 0 -a "X$overwrite" = "X0" ]
	then
	    return "${ERR_DIR_ALREADY_EXIST}"
	else
	    cp -pr "$src" "$des"
	    if [ $? -ne 0 ]
	    then
	        return "${ERR_CP_DIR_FAIL}"
	    fi
	    return "${SUCC}"	
	fi  
	
}
##############################################################
#   Name: file_dir_is_exist          
#   Description: 判断指定目录是否存在   
#   Input:          
#		1.	file name
#
#   Output: 
#		
#   Return: 
#		YES-----目录存在
#		NO------目录不存在
#
##############################################################
function file_dir_is_exist
{

    typeset dir_name="$1"
	
	#检查参数是否为空
	assert_not_empty  "$dir_name"
	
	#判断目录是否存在
	if [ -d "$dir_name" ]
	then
		return "${YES}"
	else
		return "${NO}"
	fi
}
##############################################################
#   Name: file_grep          
#   Description: 返回包含特征字符串的所有行    
#   Input:          
#		1.	file name
#		2.  express string(待查找字符串的包含的特征字符串)
#   Output: 
#		RETURN[](包含特征字符串的行)
#   Return:  
#       SUCC--正常 
#		PARA_ERROR--- 参数个数错误
#		ERR_FILE_NOT_EXIST--文件不存在
#
##############################################################
function file_grep
{
	if [ $# -ne 2 ]
	then
		return $PARA_ERROR
	fi
	
	typeset file_name=$1
	typeset expr_str=$2
    typeset count=0
    
    if [ ! -f $file_name ]
    then
    	return $ERR_FILE_NOT_EXIST
    fi
  
    #返回包含特征字符串的所有行
    file_new_tmp
    typeset tmp_file="${RETURN[0]}"
	cat "${file_name}" | ${GREP} "$expr_str" > $tmp_file
	while read line
    do
        RETURN[$count]="`echo $line`"
        ((count=count+1))
    done < $tmp_file
	# 问题单a01d85894  解决安装过程临时文件过多
	rm -rf $tmp_file
        # 问题单a01d85894  解决安装过程临时文件过多
	RETNUM=$count
	return "$SUCC"
}
##############################################################
#   Name:  file_get_content         
#   Description: 返回文件内容  
#   Input:          
#		1.	file name
#		 
#   Output: 
#		输出文件内容
#   Return:  
#       SUCC--正常 
#		ERR_FILE_CAT_FAIL--cat文件失败
#		PARA_ERROR---------参数错误
#		ERR_FILE_NOT_EXIST------文件不存在
##############################################################
function file_get_content
{
	if [ $# -ne 1 ];then
		return $PARA_ERROR
	fi
    typeset file_name=$1
	if [ ! -f $file_name ]
	then
		return $ERR_FILE_NOT_EXIST
	fi
		
	#输出文件内容到屏幕		
	cat "$file_name" 2>${IDEPLOY_NULL} 
	if [ $? -ne 0 ]
	then
	    return "${ERR_FILE_CAT_FAIL}"
	fi	
	return "${SUCC}"	 
}         
##############################################################
#   Name: file_get_content_filter_note          
#   Description:    
#   Input:          
#		1.	file name
#		2.  express string(表示注释的字符串)
#   Output: 
#		
#   Return:  
#       SUCC--正常 
#		ERR_FILE_CAT_FAIL--cat文件失败并获取清空注释后的内容
#
##############################################################
function file_get_content_filter_note
{   
    typeset file_name=$1
	typeset expr_str=$2
	typeset tmp_file="/tmp/file_get_content_filter_note"
	
	#检查参数是否为空，文件是否存在
	assert_not_empty  "$file_name"
	assert_not_empty  "$expr_str"
	assert_file_exist "$file_name"
	
	#输出文件清除注释后的内容到屏幕		
	cat "$file_name" 2>${IDEPLOY_NULL} | ${AWK} -F"${expr_str}" '{print $1}' 2>${IDEPLOY_NULL}
	if [ $? -ne 0 ]
	then
	    return "${ERR_FILE_CAT_FAIL}"
    fi
	return "${SUCC}"
}
##############################################################
#   Name: file_append_line          
#   Description:    
#   Input:          
#		1.	file name
#		2.  express string(待加到文件末尾的字符串) 
#   Output: 
#		
#   Return:  
#       SUCC--添加成功
#		ERR_APPEND_LINE_FAIL--添加一行到文件末尾失败
#		PARA_ERROR 参数个数错误
#		ERR_FILE_NOT_EXIST  --文件不存在
##############################################################
function file_append_line
{
	if [ $# -ne 2 ];then
		return $PARA_ERROR
	fi
			
    typeset file_name=$1
	typeset expr_str=$2
	
	if [  ! -f "$file_name" ];then
		return $ERR_FILE_NOT_EXIST
	fi
	
	#在文件末尾追加一行	
	echo "$expr_str" >> "$file_name" 2>${IDEPLOY_NULL}
	if [ $? -ne 0 ]
	then
	    return "${ERR_APPEND_LINE_FAIL}"
	fi
	return "${SUCC}"
}
##############################################################
#   Name:  file_get_size         
#   Description:    
#   Input:          
#		1.	file name
#		 
#   Output: 
#		RETURN[0](文件的大小(bytes))
#   Return:  
#       SUCC--正常 
#		ERR_FILE_GET_SIZE_FAIL--获取文件大小错误
#		PARA_ERROR  ---参数错误
#		ERR_FILE_NOT_EXIST--文件不存在 
##############################################################
function file_get_size
{
	if [ $# -ne 1 ];then
		return $PARA_ERROR
	fi
    typeset file=$1
	if [ ! -f $file -a ! -d $file ];then
		return $ERR_FILE_NOT_EXIST
	fi
		
	#获取文件大小
	file_size=`ls -al "$file" 2>${IDEPLOY_NULL} | ${AWK} '{print $5}' 2>${IDEPLOY_NULL}` 
	if [ "X$file_size" = "X" ]
	then
	    return "${ERR_FILE_GET_SIZE_FAIL}"
	fi
	file_size=`echo $file_size`
	
	ret_set_one ${file_size}
	return "${SUCC}"
} 
##############################################################
#   Name:  file_copy_rm_src         
#   Description: 拷贝源文件到目标文件，并撤除源文件  
#   Input:          
#		1.	source file name
#		2.  destination file name 
#   Output: 
#		
#   Return:  
#       SUCC--成功
#		ERR_FILE_CP_RM_SRC--拷贝文件删除源文件时失败
#
##############################################################
function file_copy_rm_src
{
    typeset src=$1
	typeset des=$2
	
	#检查参数是否为空，文件是否存在
	assert_not_empty  "$src"
	assert_not_empty  "$des"
	assert_not_empty  "$overwrite"
	assert_file_exist "$src"
	
	#拷贝文件到目标，并撤除源文件
	cp "$src" "$des" 2>${IDEPLOY_NULL} && rm "$src" 2>${IDEPLOY_NULL}
	if [ $? -ne 0 ]
	then
	    return "${ERR_FILE_CP_RM_SRC}"
	fi
	return "${SUCC}"
}    

##############################################################
#   Name:  file_new_tmp         
#   Description: 生成临时文件 
#   Input:          
#		1.  dir 临时文件存放的路径, 如果省略则为 /tmp
#
#   Output: 
#		RETURN[0]:生成的临时文件的全路径
#   Return:  
#       SUCC--成功
#		
#
##############################################################
function file_new_tmp
{
    typeset dir_name="$1"
    typeset date_time=""
   
	if [ "X$dir_name" = "X" ]
	then
		dir_name="${HOME}"
	fi
	
	assert_dir_exist "$dir_name" "Dir name is null!"
	
    date_time=`date '+%Y%m%d%H%M%S'`
    g_tmp_file="${dir_name}/breeze_${date_time}_$$_${g_tmp_count}_tmp"
    ((g_tmp_count+=1))

    func_exec_func file_create "$g_tmp_file" "1"
    if [ "$?" -ne 0 ]
    then
        return $ERR_FILE_CREAT
    fi
    
    ret_set_one "${g_tmp_file}"
    return "${SUCC}"
}

##############################################################
#   Name:  file_delete         
#   Description: 撤除文件
#   Input:          
#		1.  file(要撤除的文件)
#
#   Output: 
#		
#   Return:  
#       SUCC--成功
#		ERR_FILE_DELETE_FAIL--撤除文件失败
#		PARA_ERROR  ------参数错误
#		ERR_FILE_NOT_EXIST-----文件不存在
##############################################################
function file_delete
{
	if [ $# -ne 1 ];then
		return $PARA_ERROR
	fi
    typeset file=$1	
	if [ ! -f $file ];then
		return $ERR_FILE_NOT_EXIST
	fi
	#检查参数是否为空，文件是否存在	
	assert_not_empty  "$file"
	file_is_exist  "$file"
	if [ $? -ne 0 ];then
		return ${ERR_FILE_NOT_EXIST}
	fi
	
	#拷贝文件到目标，并撤除源文件
	rm -rf "$file" 2>${IDEPLOY_NULL}
	if [ $? -ne 0 ]
	then
	    return "${ERR_FILE_DELETE_FAIL}"
	fi
	return "${SUCC}"	    
}

##############################################################
#   Name:  file_rm_dir         
#   Description: 撤除文件夹
#   Input:          
#		1.  dir_name(要撤除的文件夹)
#
#   Output: 
#		
#   Return:  
#       SUCC--成功
#		ERR_DIR_DELETE_FAIL--撤除文件失败
#		PARA_ERROR-----参数错误
##############################################################
function file_rm_dir
{
	if [ $# -ne 1 ];then
		return $PARA_ERROR
	fi
    typeset dir=$1	
	
	func_exec_func os_is_system_dir "$dir"
	ret=$?
	if [ "$ret" -eq 0 ]
	then
	    return "$ret"
	fi
	
	#撤除源文件
	rm -rf "$dir" 2>${IDEPLOY_NULL} 
	if [ $? -ne 0 ]
	then
	    return "${ERR_DIR_DELETE_FAIL}"
	fi
	return "${SUCC}"		    
}

##############################################################
#   Name:  file_select_line_from_line         
#   Description: 从某一行开始返回第一个包含指定字符串的行的行号
#   Input:          
#		1.  file name
#       2.  start lineno
#       3.  express string
#   Output: 
#		
#   Return:  
#       SUCC--成功
#		ERR_FILE_DELETE_FAIL--撤除文件失败
#
##############################################################
function file_select_line_from_line
{
    typeset file_name=$1	
    typeset start_line=$2
    typeset expr_str=$3
	
	#检查参数是否为空，文件是否存在	
	assert_not_empty  "$file_name"
	assert_not_empty  "$start_line"
	assert_not_empty  "$expr_str"	
	assert_file_exist  "$file_name" "There is no ${file_name}"
	
	#获取文件行数
	func_exec_func file_get_lines_count "$file_name"
	if [ $? -ne 0 ]; then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	max_line=`echo ${RETURN[0]}`
	
	if [ "$start_line" -gt "$max_line" ]; then		
		return "${ERR_FILE_LINENO_TOO_GREAT}"
	fi
		
	func_exec_func file_new_tmp 
	ret=$?
	if [ "$ret" -ne 0 ]
	then
	    return "$ret"
	fi
	typeset tmp_file="${RETURN[0]}"	

	${SED} -n "${start_line},${max_line}p" "$file_name" >> "$tmp_file"
	if [ $? -ne 0 ]
	then
	#  问题单a01d85894  解决安装过程临时文件过多  修改开始
	rm -rf $tmp_file
        return "${ERR_FILE_SED_PRINT}"		
	fi
	
	func_exec_func file_select_line "$tmp_file" "${expr_str}"
	ret=$?
	rm -rf $tmp_file
	#  问题单a01d85894  解决安装过程临时文件过多  修改开始
	if [ "$ret" -ne 0 ]
	then
	    return "$ret"
	fi
	line_no="${RETURN[0]}"
	#begin 注意一定要 - 1 因为本身算第1行
	line_no=`expr "$line_no" - 1 + "$start_line" 2>${IDEPLOY_NULL}`
	#end 注意一定要 - 1 因为本身算第1行
	if [ "X$line_no" = "X" ]
	then
	    return "${ERR_EXPR_ERROR}"
	fi
	
	ret_set_one "${line_no}"
	return "${SUCC}"	 
}

##############################################################
#   Name:  file_get_comment_from_lineno       
#   Description: 从某一行开始返回第一个包含指定字符串的行的行号
#   Input:          
#		1.  file name
#       2.  start lineno
#       3.  end_lineno
#   Output: 
#		
#   Return:  
#       SUCC--成功
#		ERR_FILE_LINENO_TOO_GREAT--文件行号过大
#       ERR_FILE_SED_PRINT--SED打印失败
#       ERR_FILE_GET_LINES_ERROR--获取文件行号失败
#
##############################################################
function file_get_comment_from_lineno
{
    typeset file_name=$1	
    typeset start_line=$2
    typeset end_lineno=$3
	
	#检查参数是否为空，文件是否存在	
	assert_not_empty  "$file"
	assert_not_empty  "$start_line"
	assert_not_empty  "$end_lineno"	
	assert_dir_exist  "$file_name"
	
	#获取文件行数
	func_exec_func file_get_lines_count "$file_name"
	if [ $? -ne 0 ]; then
		return "${ERR_FILE_GET_LINES_ERROR}"
	fi
	max_line=`echo ${RETURN[0]}`
	
	if [ "$start_line" -gt "$max_line" -o "$end_line" -gt "$max_line" ]; then		
		return "${ERR_FILE_LINENO_TOO_GREAT}"
	fi
			
	${SED} -n "${start_line},${end_line}p" "$file_name" 
	if [ $? -ne 0 ]
	then
        return "${ERR_FILE_SED_PRINT}"		
	fi
	 
	return "${SUCC}"	 
}



###########################file.inc END################################

###########################assert.inc  BEGIN##################################


#实现assert功能，供shell文件包含
# 当断言失败时,会输出断言信息,并退出所在的shell进程,退出码为$ASSERT_ERROR, 此错误码定义在err.inc中,
# 断言函数在非调试状态下总是返回0,不进行判断

#interface:
#	assert_not_empty		assert输入参数1非空
#	assert_dir_exist		assert输入参数1代表的目录存在
#	assert_file_exist   	assert输入参数1代表的文件存在
#	assert_not_negative		assert输入参数1代表的字符串是非负整数
#	assert_user_exist		assert输入参数1代表的用户存在
#   assert_group_exist		assert输入参数1代表的组存在


##############################################################################
#   Name:           assert_not_empty
#   Description:    assert输入的参数1所代表字符串不是空字符串
#	input:
#  		1. 要断言的字符串
#	    2. 断言错误时,附在断言后面的附加输出信息
#   Output: 无
#  		assert失败，退出程序,退出码$ASSERT_ERROR
#  		assert成功，返回0
#   Return:  
#  		assert成功，返回0
##################################################################################
function assert_not_empty
{
	typeset str="$1"
	#去除变量前后的空格
	str=`echo ${str}`
	shift
	typeset desc="$@"	
	
	#在非调试状态下不进行assert
	if [ "$BRZ_DEBUG" = "0" ]; then
		return 0
	fi
		
	if [ "X${str}" = "X" ]; then
		echo "ASSERT NOT EMPTY FAILURE:$desc"
		exit ${ASSERT_ERROR}
	fi
			
	return 0
}

##############################################################################
#   Name:           assert_dir_exist
#   Description:    assert输入的参数1代表的目录存在
#	input:
#  		1. 要断言的字符串
#	    2. 断言错误时,附在断言后面的附加输出信息
#   Output: 无
#  		assert失败，退出程序,退出码$ASSERT_ERROR
#  		assert成功，返回0
#   Return:  
#  		assert成功，返回0
##################################################################################
function assert_dir_exist
{
	typeset dir="$1"
	shift
	typeset desc="$@"	
		
	#在非调试状态下不进行assert
	if [ "$BRZ_DEBUG" = "0" ]; then
		return 0
	fi
	
	assert_not_empty	"$dir"    "$desc"
	
	if [ ! -d "$dir" ]; then
		echo "ASSERT DIRECTORY NOT EXIST FAILURE:$desc"
		exit "$ASSERT_ERROR"
	fi
	
	return 0
}

##############################################################################
#   Name:           assert_file_exist
#   Description:    assert输入的参数1代表的文件存在
#	input:
#  		1. 要断言的字符串
#	    2. 断言错误时,附在断言后面的附加输出信息
#   Output: 无
#  		assert失败，退出程序,退出码$ASSERT_ERROR
#  		assert成功，返回0
#   Return:  
#  		assert成功，返回0
##################################################################################
function assert_file_exist
{
	typeset file="$1"
	shift
	typeset desc="$@"	

	#在非调试状态下不进行assert
	if [ "$BRZ_DEBUG" = "0" ]; then
		return 0
	fi
		
	assert_not_empty	"$file"   "$desc"
	
	if [ ! -f "$file" ]; then
		echo "ASSERT FILE NOT EXIST FAILURE:$desc"
		exit "$ASSERT_ERROR"
	fi
	
	return 0
}

##############################################################################
#   Name:           assert_not_negative
#   Description:    assert输入的参数1代表的字符串是非负整数
#	input:
#  		1. 要断言的字符串
#	    2. 断言错误时,附在断言后面的附加输出信息
#   Output: 无
#  		assert失败，退出程序,退出码$ASSERT_ERROR
#  		assert成功，返回0
#   Return:  
#  		assert成功，返回0
##################################################################################
function assert_not_negative
{
	typeset para="$1"
	shift
	typeset desc="$@"
	typeset var=""
	
	#在非调试状态下不进行assert
	if [ "$BRZ_DEBUG" = "0" ]; then
		return 0
	fi	
	assert_not_empty	"$para"  "$desc"
	
	# 由于expr $para - 0在para为0时返回1，所以对这种情况特殊处理
	if [ "$para" = "0" ]; then
		return 0
	fi
	
	expr $para - 0  >${IDEPLOY_NULL} 2>&1
	if [ $? -ne 0 ]; then
		echo "ASSERT NOT NEGATIVE:$desc"
		exit "$ASSERT_ERROR"	
	fi
	
	if [ "$para" -lt 0 ]; then
		echo "ASSERT NOT NEGATIVE:$desc"
		exit "$ASSERT_ERROR"			
	fi
	
	return 0
}

##############################################################################
#   Name:           assert_user_exist
#   Description:    assert输入参数1代表的用户存在
#	input:
#  		1. 要断言的字符串
#	    2. 断言错误时,附在断言后面的附加输出信息
#   Output: 无
#  		assert失败，退出程序,退出码$ASSERT_ERROR
#  		assert成功，返回0
#   Return:  
#  		assert成功，返回0
##################################################################################
function assert_user_exist
{
	typeset para="$1"
	shift
	typeset desc="$@"
	
	#在非调试状态下不进行assert
	if [ "$BRZ_DEBUG" = "0" ]; then
		return 0
	fi	
	
	assert_not_empty	"$para"  "$desc"
	
	id "$para" 2>${IDEPLOY_NULL}
	if [ $? -ne 0 ]; then
		echo "ASSERT USER EXIST:$desc"
		exit "$ASSERT_ERROR"	
	fi
	
	return 0	
}


##############################################################################
#   Name:           assert_group_exist
#   Description:    assert输入参数1代表的组存在
#	input:
#  		1. 要断言的字符串
#	    2. 断言错误时,附在断言后面的附加输出信息
#   Output: 无
#  		assert失败，退出程序,退出码$ASSERT_ERROR
#  		assert成功，返回0
#   Return:  
#  		assert成功，返回0
##################################################################################
function assert_group_exist
{
	typeset para="$1"
	shift
	typeset desc="$@"
	
	#在非调试状态下不进行assert
	if [ "$BRZ_DEBUG" = "0" ]; then
		return 0
	fi	
	
	assert_not_empty	"$para"  "$desc"
	
	id "$para" 2>${IDEPLOY_NULL}
	if [ $? -ne 0 ]; then
		echo "ASSERT USER EXIST:$desc"
		exit "$ASSERT_ERROR"	
	fi
	
	return 0	
}
#################################assert.inc  END##########################

###############################cfg_file.inc  BEGIN########################
##########################################################################
#函数名: cfg_is_exist_sec
#功能: 判断是否段键格式文件中存在一个段名
#
#输入:  1.文件名
#	    2.要找的段名	   
#输出: 无
#
#返回: 	0:存在
#       ERR_CFG_PARA_ERROR:参数个数错误
#		ERR_CFG_FILE_NOT_EXIST:文件不存在
#       ERR_CFG_FILE_SEC_NOT_EXIST:段不存在
#########################################################################
function cfg_is_exist_sec
{
	typeset func_name=cfg_is_exist_sec
	typeset file_name="$1"
	typeset sec_name="$2"

	if [ $# -ne 2 ];then
		return $ERR_CFG_PARA_ERROR
	fi
	
	#判断参数是否为空
	assert_not_empty "$file_name"  "File name is null!"
	#判断参数是否为空
	assert_not_empty "$sec_name"  "Section name is null!"

	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return $ERR_CFG_FILE_NOT_EXIST
	fi	
			
	func_exec_func file_select_line "$file_name" "^[ 	]*\[${sec_name}\]"	##注意要转义
	if [ $? -ne 0 ];then
		return $ERR_CFG_FILE_SEC_NOT_EXIST
	fi

	return 0
	
}

##########################################################################
#函数名: cfg_get_sec_names
#功能: 返回段键配置文件的多个段的名字
#
#输入:  1.文件名
#输出: RETNUM=段的个数 RETURN[0-?]多个段名
#
#返回: 0:成功 
#      ERR_CFG_PARA_ERROR:参数个数错误
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#	   ERROR:没有取到有效的记录
#########################################################################
function cfg_get_sec_names
{
	typeset func_name=cfg_is_exist_sec
	typeset file_name="$1"
	typeset ret_count=0
	
	if [ $# -ne 1 ];then
		return $ERR_CFG_PARA_ERROR
	fi	
	
	#判断参数是否为空
	assert_not_empty "$file_name" "File name is null!"

	#杨强修改开始
	#原因：多余
	#assert_not_empty "$sec_name"
	#杨强修改结束
	
	##assert_file_exist "$file_name"	

	
	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return $ERR_CFG_FILE_NOT_EXIST
	fi	
	
	
	file_new_tmp
	if [ $? -ne 0 ];then
		echo "create temp file is failed!"
		return $ERROR
	fi
	typeset tmp_file="${RETURN[0]}"
	${GREP} "^[ 	]*\[.*\]" "$file_name"|
	${AWK} -F\[ '{print $2}'|${AWK} -F\] '{print $1}' > $tmp_file
	while read line_buf 
	do		
		RETURN[$ret_count]=$line_buf
		((ret_count+=1))	
	done < $tmp_file
	# 问题单a01d85894   解决临时文件过多
	rm -rf $tmp_file
        # 问题单a01d85894   解决临时文件过多
	RETNUM=$ret_count
	if [ $ret_count -eq 0 ];then
		return $ERROR
	fi		
	return 0	
	
}

##########################################################################
#函数名: cfg_get_sec_value
#功能: 返回段键格式某个段下的值(去掉注释#)
#
#输入:  1.文件名
#	    2.段名
#输出: RETNUM=行数 RETURN[0-?]每一行的数据
#
#返回: 0:成功 
#      ERR_CFG_PARA_ERROR:参数个数错误
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#      ERR_CFG_FILE_SEC_NOT_EXIST
#	   ERROR:未知错误
#########################################################################
function cfg_get_sec_value
{
	typeset func_name=cfg_is_exist_sec
	
	typeset file_name="$1"
	typeset sec_name="$2"
	
	typeset ret_count=0		

	if [ $# -ne 2 ];then
		return $ERR_CFG_PARA_ERROR
	fi
	
	assert_not_empty "$file_name" "File name is null!"
	assert_not_empty "$sec_name" "Section name is null!"
		
	cfg_is_exist_sec "$file_name" "$sec_name"
	typeset rt=$?
	if [ $rt -ne 0 ]
	then
		if [ $rt -eq $ERR_CFG_FILE_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_NOT_EXIST
		elif [ $rt -eq $ERR_CFG_FILE_SEC_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_SEC_NOT_EXIST
		else
			return $ERROR
		fi
	fi	
	
	file_new_tmp
	if [ $? -ne 0 ];then
		echo "create temp file is failed!"
		return $ERROR
	fi
	typeset tmp_file="${RETURN[0]}"
	#杨强修改开始
	#原因：去掉多读入的一行（下一sec的头）和空行
	#${SED} -n "/^[ 	]*\[[ 	]*${sec_name}[ 	]*\]/,/^[ 	]*\[.*\]/p" "$file_name" |${AWK} -F# '{print $1}' |while read line_buf  
	${AWK} -F# '{print $1}' "$file_name" |     #去掉注释
	${SED} '/^[ 	]*$/d' |                    #删掉空行
	${SED} -n "/^[     ]*\[[   ]*${sec_name}[  ]*\]/,/^[       ]*\[.*\]/p" | #查找段内容
	${SED} '/^[        ]*\[.*\]/d' > $tmp_file     #去掉本段和下段的开头
	while read line_buf  
	#杨强修改结束
	do		
		RETURN[$ret_count]=$line_buf
		((ret_count+=1))
	done < $tmp_file
	# 问题单a01d85894   解决临时文件过多
	rm -rf $tmp_file
        # 问题单a01d85894   解决临时文件过多
	RETNUM=$ret_count
	if [ $ret_count -eq 0 ];then
		return $ERROR
	fi	
	return 0		
}

######################################################################
#函数名: cfg_is_exist_sec_key
#功能:	查找是否段键格式中存在一个段,并存在一个键
#
#方法:到该配置文件中找出该段出来
#输入: 1文件名 2段名 3键
#输出: 无
#返回: 0 成功
#	   ERR_CFG_PARA_ERROR:参数个数不对
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#      ERR_CFG_FILE_SEC_NOT_EXIST:段不存在
#      ERR_CFG_FILE_KEY_NOT_EXIST:键不存在
#	   ERROR:未知错误
###################################################################
function cfg_is_exist_sec_key
{

	typeset func_name=cfg_is_exist_sec_key

	typeset file_name="$1"
	typeset sec_name="$2"
	typeset key_name="$3"
	
	if [ $# -ne 3 ];then
		return $ERR_CFG_PARA_ERROR
	fi
	
	assert_not_empty "$file_name" "File name is null!"
	assert_not_empty "$sec_name" "Section name is null!"
	assert_not_empty "$key_name" "Key name is null!"
	
	#修改问题单A01E33223，将判断文件函数修改为file_is_exist，使得用户可以
	#根据返回码判断错误，而不是直接exit
	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return ${ERR_CFG_FILE_NOT_EXIST}
	fi
	
	#杨强修改开始 判断错误类型
#	cfg_is_exist_sec "$file_name" "$sec_name"
#	if [ $? -ne 0 ];then
#		return $ERR_CFG_SEC_NOT_EXIST
#	fi
	typeset rt	
	cfg_is_exist_sec "$file_name" "$sec_name"
	rt=$?
	if [ $rt -ne 0 ]
	then
		if [ $rt -eq $ERR_CFG_FILE_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_NOT_EXIST
		elif [ $rt -eq $ERR_CFG_FILE_SEC_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_SEC_NOT_EXIST
		else
			return $ERROR
		fi
	fi
	#杨强修改结束 判断错误类型

	# Begin  处理特殊情况，键中带有 [] 符号的情况，要加上转义符
	key_name=`echo "${key_name}" | ${SED} 's/\[/\\\[/g' | ${SED} 's/\]/\\\]/g'`
	# End    处理特殊情况，键中带有 [] 符号的情况，要加上转义符
	
	##sed命令找出之间的,再在这之间找出key_name
	RETNUM="`${SED} -n \"/^[  	]*\[[ 	]*${sec_name}[ 	]*\]/,/^[ 	]*\[/p\" $file_name|${GREP} -c \"^[ 	]*${key_name}[ 	]*=\" 2>${IDEPLOY_NULL}`"
	
	if [ $? -ne 0 -o $RETNUM -eq 0 ]
	then
		return $ERR_CFG_FILE_KEY_NOT_EXIST
	fi 

	return 0
	
}
######################################################################
#函数名: cfg_add_sec_key
#功能:	添加一个key
#
#方法:给一个文件里添加一个key
#输出: 无
#输入: 1文件名 2段名 3键 4值 5是否添加sec
#返回: 0 成功
#	   ERR_CFG_PARA_ERROR:参数个数不对
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#	   ERR_CFG_FILE_SEC_NOT_EXIST:段不存在
#	   ERR_CFG_SEC_KEY_ALREADY_EXIST:键已经存在了
#	   ERROR:添加不成功
###################################################################
function cfg_add_sec_key
{
    set -o noglob
	typeset func_name=cfg_add_sec_key
	
	typeset file_name="$1"
	typeset sec_name="$2"
	typeset key_name="$3"
	typeset key_value="$4"
	#当判断sec不存在时，是否需要添加sec，true表示需要添加sec，其他表示不添加，报错
	typeset add_sec_if_inexist="$5"
	
	typeset line_no
	
	if [ $# -lt 4 ];then
		return $ERR_CFG_PARA_ERROR
	fi
	
	assert_not_empty "$file_name" "File name is null!"
	assert_not_empty "$sec_name" "Section name is null!"
	assert_not_empty "$key_name" "Key name is null!"	
	
	file_is_exist "$file_name"
	if [ $? -ne 0 ];then
		return $ERR_CFG_FILE_NOT_EXIST
	fi	
	
	##段是否存在
	cfg_is_exist_sec "$file_name" "$sec_name"
	if [ $? -ne 0 ];then
	    if [ "X${add_sec_if_inexist}" = "Xtrue" ];then
	        echo >> "$file_name"
	        echo "[${sec_name}]" >> "$file_name"
	        echo "${key_name}=${key_value}"  >> "$file_name"
	        echo >> "$file_name"
	        return 0
	    else
	        return $ERR_CFG_FILE_SEC_NOT_EXIST
	    fi
	fi
	
	cfg_is_exist_sec_key "$file_name" "$sec_name" "$key_name"
	if [ $? -eq 0 ];then
		return $ERR_CFG_SEC_KEY_ALREADY_EXIST
	fi	
	
	func_exec_func file_select_line "$file_name" "^[ 	]*\[${sec_name}\]"	##注意要转义
	if [ $? -ne 0 ];then
		return $ERROR
	fi
	
	line_no=`echo ${RETURN[0]}`
	((line_no+=1))
	
	##前插入一行
	func_exec_func file_insert_line "$file_name" "$line_no" "${key_name}=${key_value}"
	if [ $? -ne 0 ];then
		return $ERROR
	fi
	
	return 0
}



######################################################################
#函数名: cfg_update_sec_key_value
#功能:	写入一个键(键不存在返回错误)
#
#方法: 
#输入: 1文件名 2段名 3键 4值
#输出: 无
#返回: 0 成功
#	   ERR_CFG_PARA_ERROR:参数个数不对
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#	   ERR_CFG_FILE_SEC_NOT_EXIST:段不存在
#	   ERR_CFG_FILE_KEY_NOT_EXIST:键不存在
#	   ERROR:添加不成功
###################################################################
function cfg_update_sec_key_value
{
    set -o noglob
	typeset func_name=cfg_update_sec_key_value
	
	#START 李博修改问题单A01E33176参数错误的问题
	if [ $# -ne 4 ];then
		return $ERR_CFG_PARA_ERROR
	fi
	#END 李博修改问题单A01E33176参数错误的问题
	
	typeset file_name="$1"
	typeset sec_name="$2"
	typeset key_name="$3"
	
	assert_not_empty "$file_name" "File name is null!"
	assert_not_empty "$sec_name" "Section name is null!"
	assert_not_empty "$key_name" "Key name is null!"
	
 	shift 3
#	typeset key_value
#	set -A key_value "$@"
	typeset key_value="$@"
	
	typeset -i sec_line_start
	typeset -i sec_line_end
	typeset key_line_buf

	##判断键是否存在
	cfg_is_exist_sec_key  "$file_name" "$sec_name"  "$key_name"
	typeset rt=$?
	if [ $rt -ne 0 ]
	then
		if [ $rt -eq $ERR_CFG_FILE_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_NOT_EXIST
		elif [ $rt -eq $ERR_CFG_FILE_SEC_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_SEC_NOT_EXIST
		elif [ $rt -eq $ERR_CFG_FILE_KEY_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_KEY_NOT_EXIST
		else
			return $ERROR
		fi
	fi

	##查找段所在的起始行和结束行
	sec_line_start="`${SED} -n \"/^[ 	]*\[${sec_name}\]/=\" $file_name`"
	sec_line_start="`echo $sec_line_start`"
	((sec_line_start+=1))
	sec_line_end="`${SED} -n \"$sec_line_start,/^[ 	]*\[.*\]/p\" $file_name | wc -l`"
	sec_line_end="`echo $sec_line_end`"
	((sec_line_end=sec_line_start+sec_line_end-1))
	
	##处理键名中的[和]
	typeset tmp_key_name="`echo $key_name | ${SED} 's/\[/\\\[/g' | ${SED} 's/\]/\\\]/g'`"
	
	##生成临时文件名
	#问题单a01d85894  解决临时文件过多 修改开始
	func_exec_func file_new_tmp
	if [ $? -ne 0 ];then
		return $ERROR
	fi
	#typeset tmp_file="$BRZ_HOME_PATH/lib/func/temp_$$.tmp"
	typeset tmp_file="${RETURN[0]}"
        #问题单a01d85894  解决临时文件过多 修改开始

	##查找键所在行并修改键值
	typeset -i i=0 
	typeset line_no=1
	typeset -i j=1   #指向当前行
	typeset -i k=2   #指向当前域
	typeset -i nf=0  #记录匹配行中以'#'符分隔的域数
	typeset note=""  #记录域信息
	typeset note_temp=""
	typeset line_max=`wc -l ${file_name}|$AWK '{print $1}'`    #记录文本的行数
	#set -x
	while [ "${j}" -le "${line_max}" ]
	do
		key_line_buf=`${SED} -n "${j}"p "${file_name}"`      #读取行
		if [ ${i} -ne 1 -a $line_no -ge $sec_line_start -a $line_no -le $sec_line_end ];then
			echo "$key_line_buf" | $GREP "^[ 	]*$tmp_key_name[ 	]*=.*$" 1>${IDEPLOY_NULL} 2>${IDEPLOY_NULL}
			if [ $? -eq 0 ];then
				typeset length1=`echo "$key_line_buf"|$AWK -F' #' '{print length($1)}' 2>${IDEPLOY_NULL}`
				typeset length2=`echo "$key_line_buf"|$AWK -F'\t#' '{print length($1)}' 2>${IDEPLOY_NULL}`
				if [ ${length1} -ne ${length2} ];then
					if [ ${length1} -lt ${length2} ];then    #空格+井号的分隔符在前
						note=`echo "$key_line_buf"|$AWK -F' #' '{print substr($0,(length($1) + 2))}'`
					else    #TAB+井号的分隔符在前
						note=`echo "$key_line_buf"|$AWK -F'\t#' '{print substr($0,(length($1) + 2))}'`
					fi
					key_line_buf="$key_name=${key_value}     $note"
				else #行中无注释
					key_line_buf="$key_name=${key_value}"
				fi
				((i+=1))
			fi    #end匹配成功，进行处理
		fi       #end在指定段中查找指定的键名$tmp_key_name
		echo "$key_line_buf" >> $tmp_file   #输出行
		((line_no+=1))
	((j+=1))
	done 
	
	##注意要保持目标不变
	cp $tmp_file $file_name
	rm -f $tmp_file

	#杨强修改结束 速度太慢
	
	return 0	
}
######################################################################
#函数名: cfg_write_sec_key_value
#功能:	写入一个键(键不存在添加,存在则覆盖):组合update和add
#
#方法: 
#输入: 1文件名 2段名 3键 4值
#输出: 无
#返回: 0 成功
#	   ERR_CFG_PARA_ERROR:参数个数不对
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#	   ERR_CFG_FILE_SEC_NOT_EXIST:段不存在
#	   ERROR:添加不成功
###################################################################
#cfg_write_sec_key_value()
#{	
#	return $ERR_ABSTRACT_FUNC
#}
function cfg_write_sec_key_value
{
	set -o noglob
	typeset func_name=cfg_write_sec_key_value

	if [ $# -lt 4 ];then
		return $ERR_CFG_PARA_ERROR
	fi
	
	typeset file_name="$1"
	typeset sec_name="$2"
	typeset key_name="$3"
	typeset key_value="$4"
	typeset add_sec_if_inexist="$5"
	
	assert_not_empty "$file_name" "File name is null!"
	assert_not_empty "$sec_name" "Section name is null!"
	assert_not_empty "$key_name" "Key name is null!"

	cfg_is_exist_sec_key  "$file_name" "$sec_name"  "$key_name"
	typeset rt=$?
	if [ $rt -ne 0 ]
	then
		if [ $rt -eq $ERR_CFG_FILE_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_NOT_EXIST
		elif [ $rt -eq $ERR_CFG_FILE_SEC_NOT_EXIST -a "X${add_sec_if_inexist}" != "Xtrue" ]
		then
			return $ERR_CFG_FILE_SEC_NOT_EXIST
		elif [ $rt -ne $ERR_CFG_FILE_KEY_NOT_EXIST -a $rt -ne $ERR_CFG_FILE_SEC_NOT_EXIST ]
		then
			return $ERROR
		fi
	fi

	if [ $rt -eq 0 ]
	then
		cfg_update_sec_key_value "$file_name" "$sec_name"  "$key_name" "$key_value"
		if [ $? -ne 0 ];then
			return $ERROR
		fi
	else
		cfg_add_sec_key "$file_name" "$sec_name"  "$key_name" "$key_value" "$add_sec_if_inexist"
		if [ $? -ne 0 ];then
			return $ERROR
		fi
	fi
	return 0	 
	
}

##############################################################################################
#函数名: cfg_get_sec_key_value
#功能: 在段键格式文件中的指定字段下获取某个键的值(如果相同键有多个则返回第一个)
#
#输入: 1文件名 2段名 3键 
#输出: RETURN[0]为其键值 
#返回: 0 成功
#	   ERR_CFG_PARA_ERROR:参数个数不对
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#	   ERR_CFG_FILE_SEC_NOT_EXIST:段不存在
#	   ERR_CFG_FILE_KEY_NOT_EXIST:键不存在
#	   ERROR:获取失败
###########################################################################################
function cfg_get_sec_key_value
{	
#	######公用的直接返回错误
#	return $ERR_ABSTRACT_FUNC
	
	cfg_get_sec_key_values "$@"
	typeset rt=$?
	if [ $rt -ne 0 ]
	then
		return $rt
	fi
	
	ret_set_one "${RETURN[0]}"	
	return 0
}


##############################################################################################
#函数名: cfg_get_sec_key_values
#功能: 在段键格式文件中的指定字段下获取某个键的值(如果键有多个则返回多个值)
#
#输入: 1文件名 2段名 3键
#输出: RETURN[0-?-1]为其值 RETNUM=?(从1开始)表示 返回的值的个数
#返回: 0 成功
#	   ERR_CFG_PARA_ERROR:参数个数不对
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#	   ERR_CFG_FILE_SEC_NOT_EXIST:段不存在
#	   ERR_CFG_FILE_KEY_NOT_EXIST:键不存在
#	   ERROR:获取失败
###########################################################################################
function cfg_get_sec_key_values
{
    set -o noglob
	typeset func_name=cfg_get_sec_key_values
	
	if [ $# -ne 3 ];then
		return $ERR_CFG_PARA_ERROR
	fi
	
	typeset file_name="$1"
	typeset sec_name="$2"
	typeset key_name="$3"	

	typeset line_buf=""
	typeset key_buf=""
	
	typeset loc_line_index=0
	typeset ret_num=0
	
	assert_not_empty "$file_name" "File name is null!"
	assert_not_empty "$sec_name" "Section name is null!"
	assert_not_empty "$key_name" "Key name is null!"

	cfg_is_exist_sec_key  "$file_name" "$sec_name"  "$key_name"
	typeset rt=$?
	if [ $rt -ne 0 ]
	then
		if [ $rt -eq $ERR_CFG_FILE_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_NOT_EXIST
		elif [ $rt -eq $ERR_CFG_FILE_SEC_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_SEC_NOT_EXIST
		elif [ $rt -eq $ERR_CFG_FILE_KEY_NOT_EXIST ]
		then
			return $ERR_CFG_FILE_KEY_NOT_EXIST
		else
			return $ERROR
		fi
	fi	
	##杨强修改结束
	
	cfg_get_sec_value "$file_name" "$sec_name" 
	if [ $? -ne 0 ];then
		return $ERROR
	fi
	
	while [ $loc_line_index -lt $RETNUM ]
	do	
		line_buf="`echo ${RETURN[loc_line_index]} | $AWK -F# '{print $1}'`"
		line_buf="`echo $line_buf`"
		((loc_line_index+=1))
		
		# 如果是空行,则继续读下一行
		if [ -z "$line_buf" ]; then
			continue
		fi
		
		key_buf="`echo "${line_buf}" | ${AWK} -F= '{print $1}'`"
		key_buf="`echo $key_buf`"
		##杨强修改开始 多余
#		key_buf=`echo ${key_buf}`
		##杨强修改结束 多余	
		if [ "$key_buf" = "$key_name" ]; then	# 如果找到，则添加到返回字符串后面
			
                        typeset -i line_buf_length="`echo "${line_buf}" | ${AWK} '{print length($0)}'`"
                        typeset -i first_equal_index="`echo "${line_buf}" | ${AWK} '{print index($0,"=")}'`"
                        ((first_equal_index=first_equal_index+1))
                        #RETURN[$ret_num]="`echo "$line_buf" | ${AWK} -F= '{print $2}'`"
			RETURN[$ret_num]="`echo "${line_buf}" | ${AWK} -v i="${first_equal_index}" -v j="${line_buf_length}" '{print substr($0,i,j)}'`"
                        RETURN[$ret_num]="`echo ${RETURN[ret_num]}`"
#			RETURN[$ret_num]=`echo ${RETURN[$ret_num]}`
#			|${AWK} '
#			{
#				for(i=1;i<=NF;i++)
#				{
#					printf("%s",$i);
#					if ( i < NF )
#					{
#						printf(" ");
#					}
#				}
#			}'`			##注意：该处若换成其它的直接echo $..，不会去掉前后空格
			
			((ret_num+=1))
		fi
	done
	
	#杨强修改开始 清除多余的数据
	while [ $RETNUM -gt $ret_num ]
	do
		((RETNUM-=1))
		RETURN[$RETNUM]=""
	done
	#杨强修改结束 清除多余的数据

	#杨强修改开始 多余
	#comment by 方学维 38744 这里比较特殊不能使用 ret_set_num 函数进行设置
	#不然RETURN[]数组中的数据会被清空
	#RETNUM=$ret_num
	#comment by 方学维 38744 这里比较特殊不能使用 ret_set_num 函数进行设置
	#杨强修改结束 多余
	
	if [ $ret_num -lt 1 ];then
		return $ERROR
	fi	
	return 0
}

##############################################################################################
#函数名: cfg_get_sec_key_names
#功能: 返回段键格式中某个段中的所有键名
#
#输入: 1文件名 2段名
#输出: RETURN[?]为其键名 RETNUM=? 表示有多少个键名
#返回: 0 成功
#	   ERR_CFG_PARA_ERROR:参数个数不对
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#	   ERR_CFG_FILE_SEC_NOT_EXIST:段不存在
#	   ERROR:获取失败
###########################################################################################
function cfg_get_sec_key_names
{
	typeset file_name="$1"
	typeset sec_name="$2"
	#杨强修改开始
	#原因：多余
	#typeset key_name="$3"	
	#杨强修改结束
 
	typeset line_buf=""
	
	typeset loc_line_index=0
	typeset ret_num=0
	
	#杨强修改开始
	#原因：应只有两个参数
	#if [ $# -ne 3 ];then
	if [ $# -ne 2 ]; then
	#杨强修改结束
		return $ERR_CFG_PARA_ERROR
	fi
	
	assert_not_empty "$file_name" "File name is null!"
	assert_not_empty "$sec_name" "Section name is null!"
	#杨强修改开始
	#原因：多余
	#assert_not_empty "$key_name"
	#杨强修改结束

	file_is_exist "$file_name"
	if [ $? -ne 0  ];then		
		return $ERR_CFG_FILE_NOT_EXIST		
	fi		
	
	cfg_is_exist_sec "$file_name" "$sec_name"
	if [ $? -ne 0 ];then
		return $ERR_CFG_FILE_SEC_NOT_EXIST
	fi
	
	#杨强修改开始
	#原因：多余
	#cfg_is_exist_sec_key  "$file_name" "$sec_name"  "$key_name"
	#if [ $? -ne 0 ];then
	#	return $ERR_CFG_SEC_KEY_NOT_EXIST
	#fi	
	#杨强修改结束
	
	cfg_get_sec_value "$file_name" "$sec_name" 
	if [ $? -ne 0 ];then
		return $ERROR
	fi
	
	while true
	do
	
		if [ $loc_line_index -ge $RETNUM ];then
			break
		fi


		line_buf="${RETURN[loc_line_index]}"
		((loc_line_index+=1))	
	
		# 如果是空行,则继续读下一行
		if [ "X$line_buf" = "X" ]; then
			continue
		fi
				
		# 如果是注释,则继续读下一行
		ncount=`echo "$line_buf" | ${GREP} -v "^[ 	]*#"|wc -l`
		if [ $ncount -eq 0 ]; then
			continue
		fi		
		line_buf=`echo "$line_buf"|${AWK} -F= '{print $1}'|${AWK} '{print $1}'`
		if [ "$line_buf" != "" ];then
			RETURN[$ret_num]="$line_buf"
			((ret_num+=1))				
		fi
	done	
		
	RETNUM=$ret_num
		
	if [ $ret_num -ge 1 ];then
		return 0
	else
		return $ERROR
	fi	

}

##############################################################################################
#函数名: cfg_update_ini
#功能: 以文件 source_file 中的键值替换文件 dest_file 中对应的键值
#
#输入: 1文件file1 2文件file2
#输出: 无
#返回: 0 成功
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#      ERR_CFG_FILE_SEC_NOT_EXIST:对应段不存在
#      ERR_CFG_FILE_KEY_NOT_EXIST:对应键不存在
#      ERR_CFG_FILE_KEY_DUPLICATE:键重复
#	   ERROR:获取失败
###########################################################################################
function cfg_update_ini
{
	typeset source_file="$1"
	typeset dest_file="$2"
	
	if [ $# -ne 2 ];then
		return $ERR_CFG_PARA_ERROR
	fi			
	
	#测试参数是否合法
	assert_not_empty "$source_file" "Source file name is null!"
	assert_not_empty "$dest_file" "Dest file name is null!"
	
	#检查文件是否存在
	if [ ! -f "$source_file" -o ! -f "$dest_file" ]
	then
		return $ERR_CFG_FILE_NOT_EXIST
	fi
	
	#复制键值
	typeset -i i
	typeset -i j
	typeset -i sec_count
	typeset -i key_count
	typeset section
	typeset keys
	typeset oldvalue
	typeset newvalue
	
	#读取 source_file 中的段列表
	cfg_get_sec_names "$source_file"
	if [ $? -ne 0 ]
	then
		return $ERROR
	fi	
	sec_count=$RETNUM
	set -A section "${RETURN[@]}"

	i=0
	while [ $i -lt $sec_count ]
	do
		cfg_is_exist_sec "$dest_file" "${section[i]}"
		if [ $? -eq 0 ]
		then
			cfg_get_sec_key_names "$source_file" "${section[i]}"
			if [ $? -ne 0 ]
			then
				return $ERROR
			fi	
			key_count=$RETNUM
			set -A keys "${RETURN[@]}"
			
			j=0
			while [ $j -lt $key_count ]
			do
				cfg_is_exist_sec_key "$source_file" "${section[i]}" "${keys[j]}"
				if [ $RETNUM -ne 1 ]
				then
					return $ERR_CFG_FILE_KEY_DUPLICATE
				fi
				
				cfg_is_exist_sec_key "$dest_file" "${section[i]}" "${keys[j]}"
				if [ $? -eq 0 ]
				then
					if [ $RETNUM -ne 1 ]
					then
						return $ERR_CFG_FILE_KEY_DUPLICATE
					fi
					
					#读取新键值
					cfg_get_sec_key_values "$source_file" "${section[i]}" "${keys[j]}"
					if [ $? -ne 0 ]
					then
						return $ERROR
					fi
					newvalue="${RETURN[0]}"
					
					#读取旧键值
					cfg_get_sec_key_values "${dest_file}" "${section[i]}" "${keys[j]}"
					if [ $? -ne 0 ]
					then
						return $ERROR
					fi
					oldvalue="${RETURN[0]}"
					#如果新值与旧值不相等，则将新值写入，否则不写
                    if [ "X${oldvalue}" != "X${newvalue}" ]
					then
					    #写入键值
					    cfg_update_sec_key_value "$dest_file" "${section[i]}" "${keys[j]}" "${newvalue}"
					    if [ $? -ne 0 ]
					    then
						    return $ERROR
					    fi
					fi
				else
					return $ERR_CFG_FILE_KEY_NOT_EXIST
				fi
				((j=j+1))
			done
		else
			return $ERR_CFG_FILE_SEC_NOT_EXIST
		fi
		((i=i+1))
	done
	return 0
}

##################################################################################
#函数名: add_file_record
#功能: 将框架生成的文件记录到${HOME}/breeze/ideploy/ideploy_file_history文件中
#
#输入: 将要记录的文件名称
#ideploy_file_history 格式
#           文件名称                                                    
#      /home/cjp/oamtest1/install.sh,
#输出: 无
#返回: 0 成功
#	   ERR_CFG_FILE_NOT_EXIST:文件不存在
#	   ERROR:获取失败
###########################################################################################
function add_file_record
{     
	#当前路径
	typeset cur_path=`pwd`
	#切换到家目录
	typeset home_path=`cd;pwd`
  	#切回当前路径
  	cd ${cur_path}
  	#文件名称
	typeset historyFile="${home_path}/ideploy_file_history"
	
	#文件不存在就创建
	if [ !  -f ${historyFile} ]
	then
	   touch ${historyFile}
	   chmod 666 ${historyFile}
	fi
    while [  "X$1" != "X"  ]
    do
      #当前文件中是否已经包含这个文件记录
      count=`grep -c '^'"$1"',' ${historyFile}`
      #当前文件没有这条记录
      if [ ${count} -eq 0 ]
      then
         echo "$1",  >>${historyFile}
      fi
      shift
   done 
}
#########################################################################################
#   Name:           get_mac_by_nc_alias
#   Description:    1、通过网卡别名获取网卡mac地址
#                  
#   input
#       1. 网卡别名<比如eth1》
#   Return:  
#       SUCC                              获取成功
#       ERR_GET_NETOWRK_CARD_MAC_ERR      获取网卡mac地址失败
#########################################################################################
function get_mac_by_nc_alias
{
    typeset nc_alias=$1
    typeset func_name="get_mac_by_nc_alias"
    
    #if nc alias is empty, return failed.
    if [ "X" = "X$nc_alias" ];then
        return 1
    fi
    
    ifconfig ${nc_alias} 2>/dev/null | $AWK -v n=${nc_alias} '{ if ( $1 == n ) print $5 }'    
}

#########################################################################################
#   Name:           modify_vcs_lltab_cfg_file
#   Description:    1、修改/etc/llttab 文件的网卡mac地址信息 
#                  
#   input
#       1. bond的mac地址 2. bond_slave0的mac地址 3.bond_slave1的mac地址
#   Return:  
#       SUCC                              修改成功
#       ERR_MOD_VCS_LLTTAB_FILE_ERR       修改/etc/llttab 文件失败
#########################################################################################
function modify_vcs_lltab_cfg_file
{
    typeset func_name="modify_vcs_lltab_cfg_file"
    if [ $# -ne 3 ];then
        log_echo "error" "${func_name}" "The number of parameters for this method must be 3!"
        return 1
    fi
    typeset llttab_config_file="/etc/llttab"
    typeset gab_cmd="/etc/init.d/gab"
    typeset llt_cmd="/etc/init.d/llt"
    typeset bond_mac_address=$1
    typeset slave0_mac_address=$2
    typeset slave1_mac_address=$3
    
    if [ ! -f "${llttab_config_file}" ];then
        log_echo "error" "${func_name}" "The file ${llttab_config_file} inexistent."
        return ${ERR_MOD_VCS_NOT_EXISTS}
    fi
    
    mv ${llttab_config_file} ${llttab_config_file}.bak
    cat ${llttab_config_file}.bak |$SED "s/${slave0_mac_address}/${bond_mac_address}/g"|$SED "s/${slave1_mac_address}/${bond_mac_address}/g" > ${llttab_config_file}
    #echo "s/${slave0_mac_address}/${bond_mac_address}/g'|$SED 's/${slave1_mac_address}/${bond_mac_address}/g" >> ${llttab_config_file}.bak
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Modify vcs file ${llttab_config_file} failed."
        cp ${llttab_config_file}.bak ${llttab_config_file}
        return ${ERR_MOD_VCS_LLTTAB_FILE_ERR}
    fi
   log_echo "info" "${func_name}" "Modify the file ${llttab} successfully" 
   
}
#########################################################################################
#   Name:           decrypt
#   Description:    配置项解密 
#                  
#   input
#       1. 加密后的配置项
#   Return:  
#       0                              解密成功
#       ResultMsg                      解密后的字符串
#########################################################################################
function config_value_decrypt
{
   if [ $# -ne 1 ]; then
     log_echo "error" "config_value_decrypt" "The parameter number error,required 1 parameter."
     return 1
   fi

   SPLIT_CHAR='&'
   Message=$1
   AscMessage=""
   ResultMsg=""
   Message=`echo $Message | awk '{print $0}' | sed "s/$SPLIT_CHAR/ /g"`
   for list in $Message
   do
      TMP=`echo $((16#$list))`
      TMP=`echo $TMP|awk '{print substr($0,2,length($0))}'`
      AscMessage=$AscMessage$TMP
   done
   #echo $AscMessage
   MessageLen=`echo $AscMessage|awk '{print length($0)}'`
   let iCount=$MessageLen/3
   i=0
   while [ $i -lt $iCount ]
   do
    let j=$i*3+1
    let end=$j+2 
    arg=${j}-${end}
    
    #239不支持expr
    #MTEMP=`expr substr "$AscMessage" $j 3`
    MTEMP=`echo $AscMessage|cut -c $arg`
    let MTEMP=$MTEMP-100
    MTEMP=`echo $MTEMP|awk '{printf "%c",$0}'`
    ResultMsg=$ResultMsg$MTEMP
    let i=$i+1
  done
  return 0
}
#########################################################################################
#   Name:           standard_decrypt
#   Description:    标准配置项解密 
#                  
#   input
#       1. 加密后的配置项
#   Return:  
#       0                              解密成功
#       RETURN[0]                      解密后的字符串
#########################################################################################
function standard_decrypt
{
    typeset func_name="standard_decrypt"

    if [ $# -ne 1 ]; then
        log_echo "error" "${func_name}" "The parameter number error,required 1 parameter."
        return 1
    fi
    
    #由于UPD场景会在script子目录的脚本调用解密方法，脚本的执行路径不是script会导致解密失败
    typeset tmp_dir="${IDEPLOY_TMP_DIR}"
    if [ ! -d "${tmp_dir}" ];then
        tmp_dir="${CUR_PATH}/script/tmp"
    fi
    
    #生成临时文件
    file_new_tmp "${tmp_dir}"
    
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Create temp file failed."
        return 1
    fi
    
    typeset temp_file="${RETURN[0]}"
    
    RETURN[0]=""
    
    typeset message=$1
    typeset decryptor=""
    
    #根据操作系统类型获得解密器，默认取Linux系统
    case ${OS_TYPE} in
    hp)
        decryptor="aes128_hp"
    ;;
    aix)
        decryptor="aes128_aix"
    ;;
    sun)
        decryptor="aes128_sun"
    ;;
    *)
        decryptor="aes128_suse"
        if [ -e /etc/redhat-release ];then
            decryptor="aes128_redhat"
        fi
    ;;
    esac
    
    typeset decryptor_path="${SCRIPT_DIR}/${decryptor}"
    if [ ! -f "${decryptor_path}" ];then
        decryptor_path="${CUR_PATH}/script/${decryptor}"
    fi
    
    #首先判断文件是否存在
    if [ ! -f "${decryptor_path}" ];then
        log_echo "error" "${func_name}" "decrypt executable file ${decryptor_path} doesn't exist, \
        please make sure it is in the package script directory."
        return 1
    fi
    
    #判断文件是否可执行，若不可执行则尝试增加执行权限
    if [ ! -x "${decryptor_path}" ];then
        log_echo "info" "${func_name}" "decrypt executable file ${decryptor_path} is not executable, \
        now try to add executable right."
        
        chmod +x "${decryptor_path}"
        if [ $? -ne 0 ];then
            log_echo "error" "${func_name}" "add executable right for file ${decryptor_path} failed."
            return 1
        fi
        log_echo "info" "${func_name}" "add executable right for file ${decryptor_path} success."
    fi
    
    typeset decrypt_option=""
    if [ -z "${CONFIG_TRANSPORT_AES_ENCRYPT_KEY}" ];then
        decrypt_option="0"
    else
		typeset colon_cuntt=`echo "${CONFIG_TRANSPORT_AES_ENCRYPT_KEY}" | ${GREP} -c ":"`
		if [ ${colon_cuntt} -gt 0 ]; then
			typeset ivparamforkey=`echo "${CONFIG_TRANSPORT_AES_ENCRYPT_KEY}" |$AWK -F: '{print $1}'`
			typeset encryptedkey=`echo "${CONFIG_TRANSPORT_AES_ENCRYPT_KEY}" |$AWK -F: '{print $2}'`
			#对解密的密钥进行解密
			decrypt_option=`"${decryptor_path}" "decode" "1" "${encryptedkey}" "${ivparamforkey}"`
			if [ $? -ne 0 ];then
				log_echo "error" "${func_name}" "get the decrypt key failed."
				rm -f "${temp_file}"
				return 1
			fi
		else
			#对解密的密钥进行解密
			decrypt_option=`"${decryptor_path}" "decode" "1" "${CONFIG_TRANSPORT_AES_ENCRYPT_KEY}"`
			if [ $? -ne 0 ];then
				log_echo "error" "${func_name}" "get the decrypt key failed."
				rm -f "${temp_file}"
				return 1
			fi
		fi
                 
    fi
    
    typeset decrypt_code=""
	typeset colon_cunt=`echo "${message}" | ${GREP} -c ":"`
	if [ ${colon_cunt} -gt 0 ]; then
		typeset ivparam=`echo "${message}" |$AWK -F: '{print $1}'`
		typeset encryptedstr=`echo "${message}" |$AWK -F: '{print $2}'`
	    #调用解密器进行解密，赋值方式无法获取到解密程序的退出码，故采用临时文件
		decrypt_code=`"${decryptor_path}" "decode" "${decrypt_option}" "${encryptedstr}" "${ivparam}"`   
		if [ $? -ne 0 ];then                        
			log_echo "error" "${func_name}" "decrypt input string failed, please make sure input is a valid code."
			rm -f "${temp_file}"
			return 1              
		fi
	else
		#调用解密器进行解密，赋值方式无法获取到解密程序的退出码，故采用临时文件
		decrypt_code=`"${decryptor_path}" "decode" "${decrypt_option}" "${message}"`    
		if [ $? -ne 0 ];then                        
			log_echo "error" "${func_name}" "decrypt input string failed, please make sure input is a valid code."
			rm -f "${temp_file}"
			return 1              
		fi
	fi
    
    #将结果赋值到RETURN[0]变量
    RETURN[0]="${decrypt_code}"
    rm -f "${temp_file}"
    
    return 0
}

#########################################################################################
#   Name:           get_cfgtable_record_num
#   Description:    获取表量的记录数 
#                  
#   input
#       1. table_name  表量名称
#   Return:  
#       0                              获取成功
#       1                              获取失败
#       RETURN[0]                     表量的记录数
#########################################################################################
function get_cfgtable_record_num
{
    typeset func_name="get_cfgtable_record_num"
    typeset file_name="${CONFIG_DIR}/${CONFIG}"
    typeset table_name=$1
    typeset table_record_num_key="${table_name}.size"
    
    RETURN[0]=""
    if [ $# -lt 1 ];then
        log_echo "error" "${func_name}" "Please input the config table name."
        return 1
    fi
    
    if [ ! -f ${file_name} ];then
        log_echo "error" "${func_name}" "\"${file_name}\" ${IS_NOT_A_FILE}!"
        return 1
    fi
    
    if [ ! -r ${file_name} ];then
        log_echo "error" "${func_name}" "You have no permission for read \"${file_name}\"!"
        return 1
    fi
    
    count=`cat ${file_name}|$AWK -F= -v k="${table_record_num_key}" '{ if ( $1 == k ) print $2 }'|wc -l`
    if [ ${count} -ge 2 ];then
        log_echo "error" "${func_name}" "The format of \"${CONFIG}\" is ${WRONG}."
        return 1
    elif [ ${count} -lt 1 ];then
        log_echo "error" "${func_name}" "This isn't config table name ${table_name}."
        return 1
    else
        read_value "${table_record_num_key}"
    fi
    
}

#########################################################################################
#   Name:           get_cfgtable_field_name_list
#   Description:    获取表量的字段名称列表 
#                  
#   input
#       1. table_name  表量名称
#   Return:  
#       0                              获取成功
#       1                              获取失败
#       RETURN_NUM                     字段个数
#       RETURN[0]~RETURN[${RETURN_NUM}-1]      字段名称列表
#########################################################################################
function get_cfgtable_field_name_list
{
    typeset func_name="get_cfgtable_field_name_list"
    typeset file_name="${CONFIG_DIR}/${CONFIG}"
    typeset table_name=$1
    typeset table_field_name_list_key="${table_name}.field_name_list"
    
    RETURN[0]=""
    RETURN_NUM=0
    if [ $# -lt 1 ];then
        log_echo "error" "${func_name}" "Please input the config table name."
        return 1
    fi
    
    if [ ! -f ${file_name} ];then
        log_echo "error" "${func_name}" "\"${file_name}\" ${IS_NOT_A_FILE}!"
        return 1
    fi
    
    if [ ! -r ${file_name} ];then
        log_echo "error" "${func_name}" "You have no permission for read \"${file_name}\"!"
        return 1
    fi
    
    count=`cat ${file_name}|$AWK -F= -v k="${table_field_name_list_key}" '{ if ( $1 == k ) print $2 }'|wc -l`
    if [ ${count} -ge 2 ];then
        log_echo "error" "${func_name}" "The format of \"${CONFIG}\" is ${WRONG}."
        return 1
    elif [ ${count} -lt 1 ];then
        log_echo "error" "${func_name}" "This isn't config table name ${table_name}."
        return 1
    fi
    
    read_value "${table_field_name_list_key}"
    if [ $? -ne 0 ];then
        log_echo "error" "${func_name}" "Read the field name list of config table ${table_name} failed."
        return 1
    fi
    typeset table_field_name=${RETURN[0]}
    
    RETURN_NUM=`echo "${table_field_name}" | $AWK -F, '{print NF}'`
    typeset i=0
    while [ ${i} -lt ${RETURN_NUM} ]
    do
        RETURN[${i}]=`echo "${table_field_name}" | $AWK -v k=${i} -F, '{print $(k+1)}'`
        ((i=i+1))
    done
    
    return 0
    
}

#########################################################################################
#   Name:          get_cfgtable_field_value
#   Description:    获取表量的字段值 
#                  
#   input
#       1. table_name      表量名称
#       1. row_num         记录号
#       1. field_name      字段名称
#   Return:  
#       0                              获取成功
#       1                              获取失败
#       RETURN[0]                      字段值
#########################################################################################
function get_cfgtable_field_value
{
    typeset func_name="get_cfgtable_field_value"
    typeset file_name="${CONFIG_DIR}/${CONFIG}"
    typeset table_name=$1
    typeset row_num=$2
    typeset field_name=$3
    typeset table_field_key="${table_name}.${row_num}.${field_name}"
    
    RETURN[0]=""
	
	if [ a${table_name} == a ];then
        log_echo "error" "${func_name}" "\${table_name} can not be null."
        return 1
    fi

    if [ a${row_num} == a ];then
        log_echo "error" "${func_name}" "\${record_index} can not be null."
        return 1
    fi   
		
    if [ $# -lt 3 ];then
        log_echo "error" "${func_name}" "Please input the config table name, row number, field name."
        return 1
    fi
    
    if [ ! -f ${file_name} ];then
        log_echo "error" "${func_name}" "\"${file_name}\" ${IS_NOT_A_FILE}!"
        return 1
    fi
    
    if [ ! -r ${file_name} ];then
        log_echo "error" "${func_name}" "You have no permission for read \"${file_name}\"!"
        return 1
    fi
    
    count=`cat ${file_name}|$AWK -F= -v k="${table_field_key}" '{ if ( $1 == k ) print $2 }'|wc -l`
    if [ ${count} -ge 2 ];then
        log_echo "error" "${func_name}" "The format of \"${CONFIG}\" is ${WRONG}."
        return 1
    elif [ ${count} -lt 1 ];then
        log_echo "error" "${func_name}" "\${table_name} or \${record_index} is not exist."
        return 1
    fi
    
    read_value "${table_field_key}"   
}

#########################################################################################
#   Name:          get_pkg_name
#   Description:    获取表量的字段值 
#                  
#   input
#       1. source_file      压缩包绝对路径
#   Return:  
#       0                              获取成功
#       1                              获取失败
#       RETURN[0]                      压缩包名称
#       RETURN[1]                      压缩包所在目录
#########################################################################################
function get_pkg_name
{
    typeset func_name="get_pkg_name"
	typeset source_file="$1"
	RETURN[0]=""
	typeset pkg_name=`echo "${source_file}" | ${AWK} -F /  '{print $NF}'`
	typeset pkg_dir=`echo ${source_file%"${pkg_name}"*}`
	
	if [ ! -f "${source_file}" ]; then 
        #if file doesn't exist, then use regex to match; else continue
        typeset pkg_pattern="${pkg_name}"
        #get substring of the source_file string to get pkg dir
        pkg_dir=`echo ${source_file%"${pkg_pattern}"*}`
        cd ${pkg_dir}
        typeset pkg_name=`ls | ${GREP} -E ${pkg_pattern}`
        typeset match_line=`ls | ${GREP} -E ${pkg_pattern} | wc -l`
        if [ ${match_line} -ne 1 ]; then
            if [ ${match_line} -eq 0 ]; then
                log_echo "debug" "${func_name}" "Can't find pkg file matches ${pkg_pattern} in directory ${pkg_dir}."
                return 1
            elif [ ${match_line} -gt 1 ]; then
                log_echo "debug" "${func_name}" "Pkg file matching ${pkg_pattern} in directory ${pkg_dir} is more than one : ${pkg_name}."
                return 1
            fi
        fi
    fi
    
	#没有后缀的包名
	typeset pkg_name_no_postfix=`echo "${pkg_name}" | ${AWK} -F .  '{print $1}'`
	
	RETURN[0]="${pkg_name}"
	RETURN[1]="${pkg_dir}"
	RETURN[2]="${pkg_name_no_postfix}"
	return 0
}

#########################################################################################
#   Name:          get_temp_untar_dir
#   Description:    获取解压替换时的临时目录
#                  
#   input
#       1. source_file      压缩包绝对路径
#       2. dest_dir         目标路径
#   Return:  
#       0                              获取成功
#       1                              获取失败
#       RETURN[0]                      临时解压目录
#       RETURN[1]                      压缩包名称
#       RETURN[2]                      压缩包所在目录
#########################################################################################
function get_temp_untar_dir
{
	typeset func_name="get_temp_untar_dir"
	typeset source_file="$1"
	typeset dest_dir="$2"
	
	get_pkg_name "${source_file}"
	if [ $? -ne 0 ];then
        log_echo "ERROR" "${func_name}" "Get compressed package name failed."
        return 1
    fi
	pkg_name="${RETURN[0]}"
	pkg_dir="${RETURN[1]}"
	
	#没有后缀的包名
	typeset pkg_name_no_postfix=`echo "${pkg_name}" | ${AWK} -F .  '{print $1}'`
	typeset user_name=`whoami`
	#temp untar dir
	typeset temp_untar_dir="${IDEPLOY_CUR_PATH}/${user_name}/${dest_dir}/${pkg_name_no_postfix}"
	 
	RETURN[0]="${temp_untar_dir}"
	RETURN[1]="${pkg_dir}"
	RETURN[2]="${pkg_name}"
	RETURN[3]="${pkg_name_no_postfix}"
	return 0
}

#########################################################################################
#   Name:          read_xml_node_value
#   Description:   获取指定XML中指定节点的值
#                  
#   input
#       1. java_path        使用指定的jre，需要指定java可执行文件路径。如果使用系统默认jre，则传参数:java即可。 
#       2. source_file      XML 路径，需要为绝对路径
#       3. node             目标节点的XPath表达式或者目标属性节点的XPath表达式
#   Return:  
#       0                   获取成功
#       1                   获取失败
#       RETURN_NUM          结果数量
#       RETURN[0] ~ RETURN[${RETURN_NUM}-1] 各个结果字段
#########################################################################################
function read_xml_node_value
{
    log_echo "INFO" "${func_name}" "in read xml node value function."
    typeset func_name="read_xml_node_value"
    
    #参数个数校验
    if [ $# -lt 3 ];then
        log_echo "ERROR" "${func_name}" "read_xml_node_value need at least 3 parameters."
        return 1
    fi
    
    #参数获取
    typeset java_path="$1"
    typeset src_file_path="$2"
    typeset node_path="$3"
    
    #java参数必须文件存在或者是java关键字
    if [ ! -f "${java_path}" -a "X${java_path}" != "Xjava" ];then
        log_echo "ERROR" "${func_name}" "java path ${java_path} is inexist, please check again."
        return 1
    fi
    
    #xml 文件必须存在
    if [ ! -f "${src_file_path}" ];then
        log_echo "ERROR" "${func_name}" "xml file:${src_file_path} is inexist, please check again."
        return 1
    fi
    
    #node 路径表达式不允许为空
    if [ -z "${node_path}" ];then
        log_echo "ERROR" "${func_name}" "node xpath expression is empty."
        return 1
    fi
    
    #xml 读取jar包需要存在
    typeset xmltool_lib_path="${SCRIPT_DIR}/rule_script/lib/XmlTool.jar"
    if [ ! -f "${xmltool_lib_path}" ];then
        log_echo "ERROR" "${func_name}" "xml jar lib is inexist, please upload it first."
        return 1
    fi
    
    #生成临时文件
    file_new_tmp "${tmp_dir}"
    if [ $? -ne 0 ];then
        log_echo "ERROR" "${func_name}" "Create temp file failed."
        return 1
    fi
    
    typeset temp_file="${RETURN[0]}"
    RETURN[0]=""
    
    #执行命令，读取指定节点的值，返回结果以##SEP##分隔
    "${java_path}" -jar "${xmltool_lib_path}" "xml_node_value_read" "${src_file_path}" "${node_path}" > "${temp_file}"
    if [ $? -ne 0 ];then
        typeset tmpValue=`cat ${temp_file}`
        log_echo "ERROR" "${func_name}" "read node from xml file:${src_file_path} failed. detail is:${tmpValue}."
        rm -f "${temp_file}"
        return 1
    fi
    
    #将结果赋值到临时变量
    typeset result_string=`cat "${temp_file}"`
    rm -f "${temp_file}"
    
    #计算结果个数，-v RS 更改awk记录分隔符，不再使用换行符为分隔，从而支持节点值中有空格。
    RETURN_NUM=`echo "${result_string}" | $AWK -F"##SEP##" -v RS="@@NOTEXIST@@" '{print NF}'`
    
    log_echo "INFO" "${func_name}" "number of result is:${RETURN_NUM}"
    
    typeset i=0
    while [ ${i} -lt ${RETURN_NUM} ]
    do
        RETURN[${i}]=`echo "${result_string}" | $AWK -v k=${i} -v RS="@@NOTEXITS@@" -F"##SEP##" '{print $(k+1)}'`
        ((i=i+1))
    done
    
    log_echo "INFO" "${func_name}" "read xml node value success."
    return 0
}

#########################################################################################
#   Name:          validate_param_empty
#   Description:   校验参数是否为空
#                  
#   input
#       1. param        要校验的参数 
#   Return:  
#       0                   参数不为空
#       1                   参数为空
#########################################################################################
function validate_param_empty
{
    typeset func_name="validate_param_empty"
    
	typeset param_name="${1}"
	typeset param_value="${2}"
	
	if [ "X${param_value}" = "X##NULL##" -o "X${param_value}" = "Xnull" -o "X${param_value}" = "X" ]; then
	    log_echo "error" "${func_name}" "Parameter <${param_name}> is empty."
	    return 1
	fi
	return 0
}

#########################################################################################
#   Name:          getOriginalFile
#   Description:   收集升级前配置文件
#                  
#   input
#       1. param        包含绝对路径的文件名 
#   Return:  
#       0                   成功
#       1                   失败
#########################################################################################
function getOriginalFile
{
	#set -x
    typeset func_name="getOriginalFile"
	typeset type="OriginalFile"
    typeset param=`echo ${1}`
	
	log_echo "info" "${func_name}" "Begin getOriginalFile ..."
	
	getConfigFile ${type} ${param}
	if [ $? -ne 0 ];then
		log_echo "error" "${func_name}" "GetOriginalFile failed!"
		return 1
	fi
	
	log_echo "info" "${func_name}" "GetOriginalFile success."
    return 0
}


#########################################################################################
#   Name:          getModifiedFile
#   Description:   收集升级后配置文件
#                  
#   input
#       1. param        包含绝对路径的文件名 
#   Return:  
#       0                   成功
#       1                   失败
#########################################################################################
function getModifiedFile
{
	#set -x
    typeset func_name="getModifiedFile"
	typeset type="ModifiedFile"
    typeset param=`echo ${1}`
	
	log_echo "info" "${func_name}" "Begin getModifiedFile ..."
	
	getConfigFile ${type} ${param}
	if [ $? -ne 0 ];then
		log_echo "error" "${func_name}" "GetModifiedFile failed!"
		return 1
	fi
	
	log_echo "info" "${func_name}" "GetModifiedFile success."
    return 0
}

#########################################################################################
#   Name:          getRollbackFile
#   Description:   收集回滚后配置文件
#                  
#   input
#       1. param        包含绝对路径的文件名 
#   Return:  
#       0                   成功
#       1                   失败
#########################################################################################
function getRollbackFile
{
	#set -x
    typeset func_name="getRollbackFile"
	typeset type="RollbackFile"
    typeset param=`echo ${1}`
	
	log_echo "info" "${func_name}" "Begin getRollbackFile ..."
	
	getConfigFile ${type} ${param}
	if [ $? -ne 0 ];then
		log_echo "error" "${func_name}" "GetRollbackFile failed!"
		return 1
	fi
	
	log_echo "info" "${func_name}" "GetRollbackFile success."
    return 0
}


#getOriginalFile,收集升级前配置文件
#getModifiedFile,收集升级后配置文件
#getRollbackFile,收集回滚后配置文件
function getConfigFile
{
    #set -x
    typeset func_name="getConfigFile"
	typeset mode="$1"
    typeset namelistfile="$2"
	

	#检查文件是否存在
    if [ ! -f ${namelistfile} ];then
	    log_echo "error" "${func_name}" "File \"${namelistfile}\" does not exist."
        return 1
    fi
   
	#创建目标目录，目录存在则删除重建
	
	typeset dest_dir=""
	if [ "XOriginalFile" = "X${mode}" ];then
		dest_dir="${IDEPLOY_PKG_PATH}/backupconf"
	elif [ "XModifiedFile" = "X${mode}" ]; then
		dest_dir="${IDEPLOY_PKG_PATH}/modifiedconf"
	else
		dest_dir="${IDEPLOY_PKG_PATH}/rollbackedconf"
	fi
	
	if [ -d ${dest_dir} ];then
		rm -fr ${dest_dir} && mkdir -p ${dest_dir}
		if [ $? -ne 0 ];then
			log_echo "error" "${func_name}" "Clean directory \"${dest_dir}\" failed!"
			return 1
		fi
	else
		mkdir -p ${dest_dir}
		if [ $? -ne 0 ];then
			log_echo "error" "${func_name}" "Make directory \"${dest_dir}\" failed!"
			return 1
		fi
	fi
	
	#按行读取文件，解析文件路径
	while read line
    do	
	   typeset line_str="${line}"
	   if [ "X" = "X${line_str}" ];then
		continue
	   fi
	    
	   typeset src_dir=`echo ${line_str%/*}`	
	   typeset file_dir=${dest_dir}${src_dir}
	   typeset file_pattern=`echo "${line_str}" | $AWK -F /  '{print $NF}'`
	   
	   if [ ! -d ${src_dir} ];then		            
		   log_echo "warn" "${func_name}" " Can not find \"${line_str}\"."
		   continue
	   fi
	   
	   cd ${src_dir}
	   if [ $? -ne 0 ];then
		   log_echo "error" "${func_name}" "cd \"${src_dir}\" failed!"
		   return 1
	   fi
	   
       file_name=`ls -a | $GREP -E "${file_pattern}"`
       typeset match_line=`ls -a | ${GREP} -E "${file_pattern}" | wc -l`
	   
	   if [ ${match_line} -eq 0 ];then
		   log_echo "warn" "${func_name}" " Can not find \"${line_str}\"."
		   continue
	   fi
	   
	   for real_file_name in ${file_name}
	      do
				typeset full_file_name=${src_dir}/${real_file_name}
				if [ "X${full_file_name}" != "X${line_str}" ];then
					if [ -d ${full_file_name} ];then		            
						continue
					fi
				fi
				
				if [ ! -f ${full_file_name} ];then
					log_echo "error" "${func_name}" "\"${full_file_name}\" is not file. GetConfigFile has been stopped!"
					return 1
				fi
				
				if [ ! -d ${file_dir} ];then
					mkdir -p ${file_dir}
					if [ $? -ne 0 ];then
					log_echo "ERROR" "${func_name}"  "Make directory \"${file_dir}\" failed!"
					return 1
					fi
				fi
				
				cp ${full_file_name} ${file_dir}
				if [ $? -ne 0 ];then
					log_echo "error" "${func_name}" "Copy \"${full_file_name}\" to \"${file_dir}\" failed!"
					return 1
				fi
		  done

    done < "${namelistfile}"
	if [ $? -ne 0 ];then
		log_echo "error" "${func_name}" "Read \"${namelistfile}\" failed!"
		return 1
	fi
	
	log_echo "info" "${func_name}" "GetConfigFile to \"${dest_dir}\" success."
    return 0
}